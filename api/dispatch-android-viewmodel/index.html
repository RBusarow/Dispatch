<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" charset="UTF-8">
    <title>dispatch-android-viewmodel</title>
</head><body><link href="../images/logo-icon.svg" rel="icon" type="image/svg"><script>var pathToRoot = "../";</script>
    <script type="text/javascript" src="../scripts/sourceset_dependencies.js" async></script><link href="../styles/style.css" rel="Stylesheet"><link href="../styles/jetbrains-mono.css" rel="Stylesheet"><link href="../styles/main.css" rel="Stylesheet"><link href="../styles/prism.css" rel="Stylesheet"><link href="../styles/logo-styles.css" rel="Stylesheet"><script type="text/javascript" src="../scripts/clipboard.js" async></script><script type="text/javascript" src="../scripts/navigation-loader.js" async></script><script type="text/javascript" src="../scripts/platform-content-handler.js" async></script><script type="text/javascript" src="../scripts/main.js" defer></script><script type="text/javascript" src="../scripts/prism.js" async></script><script>const storage = localStorage.getItem("dokka-dark-mode")
const savedDarkMode = storage ? JSON.parse(storage) : false
if(savedDarkMode === true){
    document.getElementsByTagName("html")[0].classList.add("theme-dark")
}</script>

  
    <div class="navigation-wrapper" id="navigation-wrapper">
      <div id="leftToggler"><span class="icon-toggler"></span></div>
      <div class="library-name"><a href="../index.html"><span>Dispatch</span></a></div>
      <div></div>
      <div class="pull-right d-flex"><button id="theme-toggle-button"><span id="theme-toggle"></span></button>
        <div id="searchBar"></div>
      </div>
    </div>
    <div id="container">
      <div id="leftColumn">
        <div id="sideMenu"></div>
      </div>
      <div id="main">
        <div class="main-content" id="content" pageids="dispatch-android-viewmodel::////PointingToDeclaration//1284309248">
          <div class="breadcrumbs"></div>
          <div class="cover ">
            <h1 class="cover"><span><span>dispatch-android-viewmodel</span></span></h1>
            <div class="platform-hinted UnderCoverText" data-platform-hinted="data-platform-hinted"><div class="content sourceset-depenent-content" data-active="" data-togglable=":dispatch-android-viewmodel:dokkaHtmlPartial/release"><p class="paragraph">The artifact I hope you don't need, but if you're not doing dependency injection, you probably do.</p><h2 class=""> Contents</h2><!-- TOC --><ul><li><p class="paragraph">#examples</p></li><li><p class="paragraph">#difference-from-androidx</p></li><li><p class="paragraph">#custom-coroutinescope-factories</p></li><li><p class="paragraph">#automatic-cancellation-in-oncleared</p></li><li><p class="paragraph">#viewmodelscope-is-not-lifecyclescope</p></li><li><p class="paragraph">#extending-viewmodel</p></li><li><p class="paragraph">#minimum-gradle-config</p></li></ul><!-- END --><h2 class=""> Examples</h2><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">import dispatch.android.*<br><br>// DispatchViewModel is just a ViewModel with a lazy viewModelScope<br>class SomeViewModel : DispatchViewModel() {<br>  // ...<br><br>  init {<br><br>    // auto-creates a MainImmediateCoroutineScope which is closed in onCleared()<br>    viewModelScope. //...<br><br>    // multiple invocations use the same instance<br>    viewModelScope.launch {  }<br><br>    // it works as a normal CoroutineScope (because it is)<br>    viewModelScope.launchMain {  }<br><br>  }<br>}<br><br>class SomeApplication : Application() {<br>  override fun onCreate() {<br>    super.onCreate()<br>    // A custom factory can be set to add elements to the CoroutineContext<br>    ViewModelScopeFactory.set { MainImmediateCoroutineScope() + SomeCustomElement() }<br>  }<br>}<br><br>class SomeViewModelTest {<br><br>  val viewModel = SomeViewModel()<br><br>  @Before<br>  fun setUp() {<br>    // This custom factory can be used to use custom scopes for testing<br>    ViewModelScopeFactory.set { TestProvidedCoroutineScope() }<br>  }<br><br>  @After<br>  fun tearDown() {<br>    // The factory can also be reset to default<br>    ViewModelScopeFactory.reset()<br>  }<br><br>  @Test<br>  fun someTest() = runBlocking {<br>    // the AndroidX version is public, so it's public here as well.<br>    viewModel.viewModelScope.launch {  }<br>  }<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class=""> Difference from AndroidX</h2><p class="paragraph">This module is essentially a fork of <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-master-dev:lifecycle/lifecycle-viewmodel-ktx/src/main/java/androidx/lifecycle/ViewModel.kt;l=42">androidx-lifecycle-viewmodel-ktx</a> — the library which gives us the <a href="https://developer.android.com/topic/libraries/architecture/coroutines#viewmodelscope">viewModelScope</a> property.</p><p class="paragraph">It exists entirely so that we can have a settable factory. This gives us a lot more options for JVM or instrumented tests, with custom dispatchers or other custom <code class="lang-kotlin">CoroutineContext</code> elements.</p><h2 class=""> Custom CoroutineScope factories</h2><p class="paragraph">The way <code class="lang-kotlin">androidx-lifecycle-viewModel</code> constructs its <a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">CoroutineScope</a> is <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-master-dev:lifecycle/lifecycle-viewmodel-ktx/src/main/java/androidx/lifecycle/ViewModel.kt;l=42">hard-coded</a>, which eliminates the possibility of using a custom <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/">CoroutineContext</a> such as a <a href="https://rbusarow.github.io/Dispatch/api/dispatch-core/dispatch.core/-dispatcher-provider/index.html">DispatcherProvider</a> or <a href="https://rbusarow.github.io/Dispatch/api/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher/index.html">IdlingDispatcher</a>. With <a href="https://rbusarow.github.io/Dispatch/api/dispatch-android-lifecycle/index.html">dispatch-android-lifecycle</a>, we can set a custom factory.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">class SomeViewModelTest {<br><br>  @Before<br>  fun setUp() {<br>    // This custom factory can be used to use custom scopes for testing<br>    ViewModelScopeFactory.set { TestProvidedCoroutineScope() }<br><br>    // it could also return a specific instance<br>    val someTestScope = TestProvidedCoroutineScope()<br>    ViewModelScopeFactory.set { someTestScope }<br>  }<br><br>  @After<br>  fun tearDown() {<br>    // The factory can also be reset to default<br>    ViewModelScopeFactory.reset()<br>  }<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class=""> Automatic cancellation in onCleared()</h2><p class="paragraph">Just like AndroidX, this version of <code class="lang-kotlin">viewModelScope</code> is automatically cancelled in <code class="lang-kotlin">ViewModel.onCleared()</code>.</p><h2 class=""> viewModelScope is not lifecycleScope</h2><p class="paragraph">It's important to remember that <code class="lang-kotlin">onCleared()</code> is only called when a <code class="lang-kotlin">ViewModel</code> is about to be destroyed -- when its associated <code class="lang-kotlin">LifecycleOwner</code>(s) are all destroyed. This means that a <code class="lang-kotlin">viewModelScope</code> is active while the <code class="lang-kotlin">LifecycleOwner</code> is in the backstack.</p><p class="paragraph">Consider this example:</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">// Don't do this<br>class SomeViewModel : DispatchViewModel() {<br><br>  init {<br>    viewModelScope.launch {<br>      // this job will continue forever even if the ViewModel is on the backstack.<br>      someRepository.dataFlow.collect {<br>        parseData(it)<br>      }<br>    }<br>  }<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><p class="paragraph">A <code class="lang-kotlin">CoroutineScope</code> in a <code class="lang-kotlin">ViewModel</code> is better utilized for single-shot requests which shouldn't be restarted in the event of a configuration change.  "Observer" behavior should be scoped to the associated view.</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">// Maybe do this<br>class SomeFragment : Fragment() {<br><br>  val viewModel: SomeViewModel by viewModels()<br><br>  init {<br>    lifecycleScope.launchWhenResumed {<br>      viewModel.dataFlow.collect {  }<br>    }<br>  }<br>}<br><br>class SomeViewModel : DispatchViewModel() {<br><br>  // a single shot request is made using the viewModelScope<br>  val lazyData by lazy {<br>    CompletableDeferred&lt;Data&gt;().apply {<br>      viewModelScope.launch {<br>        complete(someRepository.getData())<br>      }<br>    }<br>  }<br><br>  // collection of the Flow is done using the view's lifecycleScope,<br>  // meaning that it will stop as soon as the screen is in the backstack<br>  val dataFlow = someRepository.dataFlow.onEach {<br>    parseData(it)<br>  }<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div><h2 class=""> Extending ViewModel</h2><p class="paragraph">Since nothing about the <code class="lang-kotlin">clear</code> event is actually exposed outside of <code class="lang-kotlin">ViewModel</code>, it's necessary to extend <code class="lang-kotlin">ViewModel</code> in order to consume it for cancelling the <code class="lang-kotlin">viewModelScope</code>. This is especially galling since <code class="lang-kotlin">ViewModel</code> could absolutely have just been an interface to begin with.</p><h2 class=""> Minimum Gradle Config</h2><p class="paragraph">Add to your module's <code class="lang-kotlin">build.gradle.kts</code>:</p><div class="sample-container"><pre><code class="block lang-kotlin" theme="idea">repositories {<br>  mavenCentral()<br>}<br><br>dependencies {<br><br>  implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.5.0")<br>  implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.5.0")<br>  implementation(platform("com.rickbusarow.dispatch:dispatch-bom:1.0.0-beta10"))<br>  implementation("com.rickbusarow.dispatch:dispatch-android-viewmodel")<br>}</code></pre><span class="top-right-position"><span class="copy-icon"></span><div class="copy-popup-wrapper popup-to-left"><span class="copy-popup-icon"></span><span>Content copied to clipboard</span></div></span></div></div></div>
          </div>
          <h2 class="">Packages</h2>
          <div class="table"><a data-name="-1882708973%2FPackages%2F1284309248" anchor-label="dispatch.android.viewmodel" id="-1882708973%2FPackages%2F1284309248" data-filterable-set=":dispatch-android-viewmodel:dokkaHtmlPartial/release"></a>
            <div class="table-row" data-filterable-current=":dispatch-android-viewmodel:dokkaHtmlPartial/release" data-filterable-set=":dispatch-android-viewmodel:dokkaHtmlPartial/release">
              <div>
                <div class="main-subrow ">
                  <div class=""><span class="inline-flex">
                      <div><a href="dispatch.android.viewmodel/index.html">dispatch.android.viewmodel</a></div>
<span class="anchor-wrapper"><span class="anchor-icon" pointing-to="-1882708973%2FPackages%2F1284309248"></span>
                        <div class="copy-popup-wrapper "><span class="copy-popup-icon"></span><span>Link copied to clipboard</span></div>
                      </span></span></div>
                  <div class="pull-right"></div>
                </div>
                <div></div>
              </div>
            </div>
          </div>
        </div>
        <div class="footer"><span class="go-to-top-icon"><a href="#content" id="go-to-top-link"></a></span><span>© 2022 Copyright</span><span class="pull-right"><span>Generated by </span><a href="https://github.com/Kotlin/dokka"><span>dokka</span><span class="padded-icon"></span></a></span></div>
      </div>
    </div>
  
</body></html>


