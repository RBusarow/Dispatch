{
  "config": {
    "lang": [
      "en"
    ],
    "prebuild_index": false,
    "separator": "[\\s\\-]+"
  },
  "docs": [
    {
      "location": "",
      "text": "Dispatch Utilities for kotlinx.coroutines which make them type-safe, easier to test, and more expressive. Use the predefined types and factories or define your own, and never inject a Dispatchers object again. val presenter = MyPresenter(MainCoroutineScope()) class MyPresenter @Inject constructor ( /** * Defaults to the Main dispatcher */ val coroutineScope: MainCoroutineScope ) { fun loopSomething () = coroutineScope.launchDefault { } suspend fun updateSomething () = withMainImmediate { } } class MyTest { @Test fun `no setting the main dispatcher` () = runBlockingProvidedTest { // automatically use TestCoroutineDispatcher for every dispatcher type val presenter = MyPresenter(coroutineScope = this ) // this call would normally crash due to the main looper presenter.updateSomething() } } Contents Injecting dispatchers Types and Factories Referencing dispatchers Builder Extensions Android Lifecycle Android Espresso Android ViewModel Testing Modules Full Gradle Config License Injecting dispatchers Everywhere you use coroutines, you use a CoroutineContext . If we embed the CoroutineDispatchers settings we want into the context, then we don't need to pass them around manually. The core of this library is DispatcherProvider - an interface with properties corresponding to the 5 different CoroutineDispatchers we can get from the Dispatchers singleton. It lives inside the CoroutineContext , and gets passed from parent to child coroutines transparently without any additional code. interface DispatcherProvider : CoroutineContext.Element { override val key: CoroutineContext.Key * get () = Key val default: CoroutineDispatcher val io: CoroutineDispatcher val main: CoroutineDispatcher val mainImmediate: CoroutineDispatcher val unconfined: CoroutineDispatcher companion object Key : CoroutineContext.Key DispatcherProvider } val someCoroutineScope = CoroutineScope( Job() + Dispatchers.Main + DispatcherProvider() ) The default implementation of this interface simply delegates to that Dispatchers singleton, as that is what we typically want for production usage. Types and Factories A CoroutineScope may have any type of CoroutineDispatcher . What if we have a View class which will always use the Main thread, or one which will always do I/O? There are marker interfaces and factories to ensure that the correct type of CoroutineScope is always used. Type Dispatcher DefaultCoroutineScope Dispatchers.Default IOCoroutineScope Dispatchers.IO MainCoroutineScope Dispatchers.Main MainImmediateCoroutineScope Dispatchers.Main.immediate UnconfinedCoroutineScope Dispatchers.Unconfined val mainScope = MainCoroutineScope() val someUIClass = SomeUIClass(mainScope) class SomeUIClass ( val coroutineScope: MainCoroutineScope) { fun foo () = coroutineScope.launch { // because of the dependency type, // we re guaranteed to be on the main dispatcher even though we didn t specify it } } Referencing dispatchers These dispatcher settings can then be accessed via extension functions upon CoroutineScope , or the coroutineContext , or directly from extension functions: Builder Extensions Default IO Main Main.immediate Unconfined Job launchDefault launchIO launchMain launchMainImmediate launchUnconfined Deferred asyncDefault asyncIO asyncMain asyncMainImmediate asyncUnconfined suspend T withDefault withIO withMain withMainImmediate withUnconfined Flow T flowOnDefault flowOnIO flowOnMain flowOnMainImmediate flowOnUnconfined class MyClass ( val coroutineScope: IOCoroutineScope) { fun accessMainThread () = coroutineScope.launchMain { // we re now on the main thread as defined by the interface } } Android Lifecycle The AndroidX.lifecycle library offers a lifecycleScope extension function to provide a lifecycle-aware CoroutineScope , but there are two shortcomings: 1. It delegates to a hard-coded Dispatchers.Main CoroutineDispatcher , which complicates unit and Espresso testing by requiring the use of Dispatchers.setMain . 2. It pauses the dispatcher when the lifecycle state passes below its threshold, which leaks backpressure to the producing coroutine and can create deadlocks . Dispatch-android-lifecycle and dispatch-android-lifecycle-extensions completely replace the AndroidX version. import dispatch.android.lifecycle.* import dispatch.core.* import kotlinx.coroutines.flow.* class MyActivity : Activity() { init { lifecycleScope.launchOnCreate { viewModel.someFlow.collect { channel.send( $it ) } } } } The LifecycleCoroutineScope may be configured with any dispatcher, since MainImmediateCoroutineScope is just a marker interface. Its lifecycle-aware functions cancel when dropping below a threshold, then automatically restart when entering into the desired lifecycle state again. This is key to preventing the backpressure leak of the AndroidX version, and it's also more analogous to the behavior of LiveData to which many developers are accustomed. There are two built-in ways to define a custom LifecycleCoroutineScope - by simply constructing one directly inside a Lifecycle class, or by statically setting a custom LifecycleScopeFactory . This second option can be very useful when utilizing an IdlingCoroutineScope . Android Espresso Espresso is able to use IdlingResource to infer when it should perform its actions, which helps to reduce the flakiness of tests. Conventional thread-based IdlingResource implementations don't work with coroutines, however. IdlingCoroutineScope utilizes IdlingDispatchers , which count a coroutine as being \"idle\" when it is suspended. Using statically defined factories, service locators, or dependency injection, it is possible to utilize idling-aware dispatchers throughout a codebase during Espresso testing. class IdlingCoroutineScopeRuleWithLifecycleSample { val customDispatcherProvider = IdlingDispatcherProvider() @JvmField @Rule val idlingRule = IdlingDispatcherProviderRule { IdlingDispatcherProvider(customDispatcherProvider) } /** * If you don t provide CoroutineScopes to your lifecycle components via a dependency injection framework, * you need to use the `dispatch-android-lifecycle-extensions` and `dispatch-android-viewmodel` artifacts * to ensure that the same `IdlingDispatcherProvider` is used. */ @Before fun setUp () { LifecycleScopeFactory. set { MainImmediateCoroutineScope(customDispatcherProvider) } ViewModelScopeFactory. set { MainImmediateCoroutineScope(customDispatcherProvider) } } @Test fun testThings () = runBlocking { // Now any CoroutineScope which uses the DispatcherProvider // in TestAppComponent will sync its idle state with Espresso } } Android ViewModel The AndroidX ViewModel library offers a viewModelScope extension function to provide an auto-cancelled CoroutineScope , but again, this CoroutineScope is hard-coded and uses Dispatchers.Main . This limitation needn't exist. Dispatch-android-viewmodel doesn't have as many options as its lifecycle counterpart, because the ViewModel.onCleared function is protected and ViewModel does not expose anything about its lifecycle. The only way for a third party library to achieve a lifecycle-aware CoroutineScope is through inheritance. CoroutineViewModel is a simple abstract class which exposes a lazy viewModelScope property which is automatically cancelled when the ViewModel is destroyed. The exact type of the viewModelScope can be configured statically via ViewModelScopeFactory . In this way, you can use IdlingCoroutineScopes for Espresso testing, TestProvidedCoroutineScopes for unit testing, or any other custom scope you'd like. If you're using the AAC ViewModel but not dependency injection, this artifact should be very helpful with testing. import dispatch.android.viewmodel.* import kotlinx.coroutines.flow.* import timber.log.* class MyViewModel : CoroutineViewModel() { init { MyRepository.someFlow.onEach { Timber.d( $it ) }.launchIn(viewModelScope) } } The LifecycleCoroutineScope may be configured with any dispatcher, since MainImmediateCoroutineScope is just a marker interface. Its lifecycle-aware functions cancel when dropping below a threshold, then automatically restart when entering into the desired lifecycle state again. This is key to preventing the backpressure leak of the AndroidX version, and it's also more analogous to the behavior of LiveData to which many developers are accustomed. There are two built-in ways to define a custom LifecycleCoroutineScope - by simply constructing one directly inside a Lifecycle class, or by statically setting a custom LifecycleScopeFactory . This second option can be very useful when utilizing an IdlingCoroutineScope . Testing Testing is why this library exists. TestCoroutineScope and TestCoroutineDispatcher are very powerful when they can be used, but any reference to a statically defined dispatcher (like a Dispatchers property) removes that control. To that end, there's a configurable TestDispatcherProvider : class TestDispatcherProvider ( override val default: CoroutineDispatcher = TestCoroutineDispatcher(), override val io: CoroutineDispatcher = TestCoroutineDispatcher(), override val main: CoroutineDispatcher = TestCoroutineDispatcher(), override val mainImmediate: CoroutineDispatcher = TestCoroutineDispatcher(), override val unconfined: CoroutineDispatcher = TestCoroutineDispatcher() ) : DispatcherProvider As well as a polymorphic TestProvidedCoroutineScope which may be used in place of any type-specific CoroutineScope : val testScope = TestProvidedCoroutineScope() val someUIClass = SomeUIClass(testScope) class SomeUIClass ( val coroutineScope: MainCoroutineScope) { fun foo () = coroutineScope.launch { // ... } } There's also testProvided , which delegates to runBlockingTest but which includes a TestDispatcherProvider inside the TestCoroutineScope . class Subject { // this would normally be a hard-coded reference to Dispatchers.Main suspend fun sayHello () = withMain { } } @Test fun `sayHello should say hello` () = runBlockingProvided { val subject = SomeClass( this ) // uses main TestCoroutineDispatcher safely with no additional setup subject.getSomeData() shouldPrint hello } Modules artifact features dispatch-android-espresso IdlingDispatcher IdlingDispatcherProvider dispatch-android-lifecycle-extensions lifecycleScope dispatch-android-lifecycle LifecycleCoroutineScope launchOnCreate launchOnStart launchOnResume onNextCreate onNextStart onNextResume dispatch-android-viewmodel CoroutineViewModel viewModelScope dispatch-core Dispatcher-specific types and factories Dispatcher-specific coroutine builders dispatch-detekt Detekt rules for common auto-imported-the-wrong-thing problems dispatch-test-junit4 TestCoroutineRule dispatch-test-junit5 CoroutineTest CoroutineTestExtension dispatch-test TestProvidedCoroutineScope TestDispatcherProvider runBlockingProvided and testProvided Full Gradle Config repositories { mavenCentral() } dependencies { /* production code */ // core coroutines implementation( org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.7 ) implementation( org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.7 ) // everything provides :core via api , so you only need this if you have no other implementation dispatch artifacts implementation( com.rickbusarow.dispatch:dispatch-core:1.0.0-beta03 ) // extensions for Flow and Channel implementation( com.rickbusarow.dispatch:dispatch-extensions:1.0.0-beta03 ) // LifecycleCoroutineScope for Android Fragments, Activities, etc. implementation( com.rickbusarow.dispatch:dispatch-android-lifecycle:1.0.0-beta03 ) // lifecycleScope extension function with a settable factory. Use this if you don t DI your CoroutineScopes // This provides :dispatch-android-lifecycle via api , so you don t need to declare both implementation( com.rickbusarow.dispatch:dispatch-android-lifecycle-extensions:1.0.0-beta03 ) // ViewModelScope for Android ViewModels implementation( com.rickbusarow.dispatch:dispatch-android-viewmodel:1.0.0-beta03 ) /* jvm testing */ // core coroutines-test testImplementation( org.jetbrains.kotlinx:kotlinx-coroutines-test:1.3.7 ) // you only need this if you don t have the -junit4 or -junit5 artifacts testImplementation( com.rickbusarow.dispatch:dispatch-test:1.0.0-beta03 ) // CoroutineTestRule and :dispatch-test // This provides :dispatch-test via api , so you don t need to declare both // This can be used at the same time as :dispatch-test-junit5 testImplementation( com.rickbusarow.dispatch:dispatch-test-junit4:1.0.0-beta03 ) // CoroutineTest, CoroutineTestExtension, and :dispatch-test // This provides :dispatch-test via api , so you don t need to declare both // This can be used at the same time as :dispatch-test-junit4 testImplementation( com.rickbusarow.dispatch:dispatch-test-junit4:1.0.0-beta03 ) /* Android testing */ // core android androidTestImplementation( androidx.test:runner:1.2.0 ) androidTestImplementation( androidx.test.espresso:espresso-core:3.2.0 ) // IdlingDispatcher, IdlingDispatcherProvider, and IdlingCoroutineScope androidTestImplementation( com.rickbusarow.dispatch:dispatch-android-espresso:1.0.0-beta03 ) } License Copyright (C) 2020 Rick Busarow Licensed under the Apache License, Version 2.0 (the License ); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.",
      "title": "Intro"
    },
    {
      "location": "#dispatch",
      "text": "Utilities for kotlinx.coroutines which make them type-safe, easier to test, and more expressive. Use the predefined types and factories or define your own, and never inject a Dispatchers object again. val presenter = MyPresenter(MainCoroutineScope()) class MyPresenter @Inject constructor ( /** * Defaults to the Main dispatcher */ val coroutineScope: MainCoroutineScope ) { fun loopSomething () = coroutineScope.launchDefault { } suspend fun updateSomething () = withMainImmediate { } } class MyTest { @Test fun `no setting the main dispatcher` () = runBlockingProvidedTest { // automatically use TestCoroutineDispatcher for every dispatcher type val presenter = MyPresenter(coroutineScope = this ) // this call would normally crash due to the main looper presenter.updateSomething() } }",
      "title": "Dispatch"
    },
    {
      "location": "#contents",
      "text": "Injecting dispatchers Types and Factories Referencing dispatchers Builder Extensions Android Lifecycle Android Espresso Android ViewModel Testing Modules Full Gradle Config License",
      "title": "Contents"
    },
    {
      "location": "#injecting-dispatchers",
      "text": "Everywhere you use coroutines, you use a CoroutineContext . If we embed the CoroutineDispatchers settings we want into the context, then we don't need to pass them around manually. The core of this library is DispatcherProvider - an interface with properties corresponding to the 5 different CoroutineDispatchers we can get from the Dispatchers singleton. It lives inside the CoroutineContext , and gets passed from parent to child coroutines transparently without any additional code. interface DispatcherProvider : CoroutineContext.Element { override val key: CoroutineContext.Key * get () = Key val default: CoroutineDispatcher val io: CoroutineDispatcher val main: CoroutineDispatcher val mainImmediate: CoroutineDispatcher val unconfined: CoroutineDispatcher companion object Key : CoroutineContext.Key DispatcherProvider } val someCoroutineScope = CoroutineScope( Job() + Dispatchers.Main + DispatcherProvider() ) The default implementation of this interface simply delegates to that Dispatchers singleton, as that is what we typically want for production usage.",
      "title": "Injecting dispatchers"
    },
    {
      "location": "#types-and-factories",
      "text": "A CoroutineScope may have any type of CoroutineDispatcher . What if we have a View class which will always use the Main thread, or one which will always do I/O? There are marker interfaces and factories to ensure that the correct type of CoroutineScope is always used. Type Dispatcher DefaultCoroutineScope Dispatchers.Default IOCoroutineScope Dispatchers.IO MainCoroutineScope Dispatchers.Main MainImmediateCoroutineScope Dispatchers.Main.immediate UnconfinedCoroutineScope Dispatchers.Unconfined val mainScope = MainCoroutineScope() val someUIClass = SomeUIClass(mainScope) class SomeUIClass ( val coroutineScope: MainCoroutineScope) { fun foo () = coroutineScope.launch { // because of the dependency type, // we re guaranteed to be on the main dispatcher even though we didn t specify it } }",
      "title": "Types and Factories"
    },
    {
      "location": "#referencing-dispatchers",
      "text": "These dispatcher settings can then be accessed via extension functions upon CoroutineScope , or the coroutineContext , or directly from extension functions:",
      "title": "Referencing dispatchers"
    },
    {
      "location": "#builder-extensions",
      "text": "Default IO Main Main.immediate Unconfined Job launchDefault launchIO launchMain launchMainImmediate launchUnconfined Deferred asyncDefault asyncIO asyncMain asyncMainImmediate asyncUnconfined suspend T withDefault withIO withMain withMainImmediate withUnconfined Flow T flowOnDefault flowOnIO flowOnMain flowOnMainImmediate flowOnUnconfined class MyClass ( val coroutineScope: IOCoroutineScope) { fun accessMainThread () = coroutineScope.launchMain { // we re now on the main thread as defined by the interface } }",
      "title": "Builder Extensions"
    },
    {
      "location": "#android-lifecycle",
      "text": "The AndroidX.lifecycle library offers a lifecycleScope extension function to provide a lifecycle-aware CoroutineScope , but there are two shortcomings: 1. It delegates to a hard-coded Dispatchers.Main CoroutineDispatcher , which complicates unit and Espresso testing by requiring the use of Dispatchers.setMain . 2. It pauses the dispatcher when the lifecycle state passes below its threshold, which leaks backpressure to the producing coroutine and can create deadlocks . Dispatch-android-lifecycle and dispatch-android-lifecycle-extensions completely replace the AndroidX version. import dispatch.android.lifecycle.* import dispatch.core.* import kotlinx.coroutines.flow.* class MyActivity : Activity() { init { lifecycleScope.launchOnCreate { viewModel.someFlow.collect { channel.send( $it ) } } } } The LifecycleCoroutineScope may be configured with any dispatcher, since MainImmediateCoroutineScope is just a marker interface. Its lifecycle-aware functions cancel when dropping below a threshold, then automatically restart when entering into the desired lifecycle state again. This is key to preventing the backpressure leak of the AndroidX version, and it's also more analogous to the behavior of LiveData to which many developers are accustomed. There are two built-in ways to define a custom LifecycleCoroutineScope - by simply constructing one directly inside a Lifecycle class, or by statically setting a custom LifecycleScopeFactory . This second option can be very useful when utilizing an IdlingCoroutineScope .",
      "title": "Android Lifecycle"
    },
    {
      "location": "#android-espresso",
      "text": "Espresso is able to use IdlingResource to infer when it should perform its actions, which helps to reduce the flakiness of tests. Conventional thread-based IdlingResource implementations don't work with coroutines, however. IdlingCoroutineScope utilizes IdlingDispatchers , which count a coroutine as being \"idle\" when it is suspended. Using statically defined factories, service locators, or dependency injection, it is possible to utilize idling-aware dispatchers throughout a codebase during Espresso testing. class IdlingCoroutineScopeRuleWithLifecycleSample { val customDispatcherProvider = IdlingDispatcherProvider() @JvmField @Rule val idlingRule = IdlingDispatcherProviderRule { IdlingDispatcherProvider(customDispatcherProvider) } /** * If you don t provide CoroutineScopes to your lifecycle components via a dependency injection framework, * you need to use the `dispatch-android-lifecycle-extensions` and `dispatch-android-viewmodel` artifacts * to ensure that the same `IdlingDispatcherProvider` is used. */ @Before fun setUp () { LifecycleScopeFactory. set { MainImmediateCoroutineScope(customDispatcherProvider) } ViewModelScopeFactory. set { MainImmediateCoroutineScope(customDispatcherProvider) } } @Test fun testThings () = runBlocking { // Now any CoroutineScope which uses the DispatcherProvider // in TestAppComponent will sync its idle state with Espresso } }",
      "title": "Android Espresso"
    },
    {
      "location": "#android-viewmodel",
      "text": "The AndroidX ViewModel library offers a viewModelScope extension function to provide an auto-cancelled CoroutineScope , but again, this CoroutineScope is hard-coded and uses Dispatchers.Main . This limitation needn't exist. Dispatch-android-viewmodel doesn't have as many options as its lifecycle counterpart, because the ViewModel.onCleared function is protected and ViewModel does not expose anything about its lifecycle. The only way for a third party library to achieve a lifecycle-aware CoroutineScope is through inheritance. CoroutineViewModel is a simple abstract class which exposes a lazy viewModelScope property which is automatically cancelled when the ViewModel is destroyed. The exact type of the viewModelScope can be configured statically via ViewModelScopeFactory . In this way, you can use IdlingCoroutineScopes for Espresso testing, TestProvidedCoroutineScopes for unit testing, or any other custom scope you'd like. If you're using the AAC ViewModel but not dependency injection, this artifact should be very helpful with testing. import dispatch.android.viewmodel.* import kotlinx.coroutines.flow.* import timber.log.* class MyViewModel : CoroutineViewModel() { init { MyRepository.someFlow.onEach { Timber.d( $it ) }.launchIn(viewModelScope) } } The LifecycleCoroutineScope may be configured with any dispatcher, since MainImmediateCoroutineScope is just a marker interface. Its lifecycle-aware functions cancel when dropping below a threshold, then automatically restart when entering into the desired lifecycle state again. This is key to preventing the backpressure leak of the AndroidX version, and it's also more analogous to the behavior of LiveData to which many developers are accustomed. There are two built-in ways to define a custom LifecycleCoroutineScope - by simply constructing one directly inside a Lifecycle class, or by statically setting a custom LifecycleScopeFactory . This second option can be very useful when utilizing an IdlingCoroutineScope .",
      "title": "Android ViewModel"
    },
    {
      "location": "#testing",
      "text": "Testing is why this library exists. TestCoroutineScope and TestCoroutineDispatcher are very powerful when they can be used, but any reference to a statically defined dispatcher (like a Dispatchers property) removes that control. To that end, there's a configurable TestDispatcherProvider : class TestDispatcherProvider ( override val default: CoroutineDispatcher = TestCoroutineDispatcher(), override val io: CoroutineDispatcher = TestCoroutineDispatcher(), override val main: CoroutineDispatcher = TestCoroutineDispatcher(), override val mainImmediate: CoroutineDispatcher = TestCoroutineDispatcher(), override val unconfined: CoroutineDispatcher = TestCoroutineDispatcher() ) : DispatcherProvider As well as a polymorphic TestProvidedCoroutineScope which may be used in place of any type-specific CoroutineScope : val testScope = TestProvidedCoroutineScope() val someUIClass = SomeUIClass(testScope) class SomeUIClass ( val coroutineScope: MainCoroutineScope) { fun foo () = coroutineScope.launch { // ... } } There's also testProvided , which delegates to runBlockingTest but which includes a TestDispatcherProvider inside the TestCoroutineScope . class Subject { // this would normally be a hard-coded reference to Dispatchers.Main suspend fun sayHello () = withMain { } } @Test fun `sayHello should say hello` () = runBlockingProvided { val subject = SomeClass( this ) // uses main TestCoroutineDispatcher safely with no additional setup subject.getSomeData() shouldPrint hello }",
      "title": "Testing"
    },
    {
      "location": "#modules",
      "text": "artifact features dispatch-android-espresso IdlingDispatcher IdlingDispatcherProvider dispatch-android-lifecycle-extensions lifecycleScope dispatch-android-lifecycle LifecycleCoroutineScope launchOnCreate launchOnStart launchOnResume onNextCreate onNextStart onNextResume dispatch-android-viewmodel CoroutineViewModel viewModelScope dispatch-core Dispatcher-specific types and factories Dispatcher-specific coroutine builders dispatch-detekt Detekt rules for common auto-imported-the-wrong-thing problems dispatch-test-junit4 TestCoroutineRule dispatch-test-junit5 CoroutineTest CoroutineTestExtension dispatch-test TestProvidedCoroutineScope TestDispatcherProvider runBlockingProvided and testProvided",
      "title": "Modules"
    },
    {
      "location": "#full-gradle-config",
      "text": "repositories { mavenCentral() } dependencies { /* production code */ // core coroutines implementation( org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.7 ) implementation( org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.7 ) // everything provides :core via api , so you only need this if you have no other implementation dispatch artifacts implementation( com.rickbusarow.dispatch:dispatch-core:1.0.0-beta03 ) // extensions for Flow and Channel implementation( com.rickbusarow.dispatch:dispatch-extensions:1.0.0-beta03 ) // LifecycleCoroutineScope for Android Fragments, Activities, etc. implementation( com.rickbusarow.dispatch:dispatch-android-lifecycle:1.0.0-beta03 ) // lifecycleScope extension function with a settable factory. Use this if you don t DI your CoroutineScopes // This provides :dispatch-android-lifecycle via api , so you don t need to declare both implementation( com.rickbusarow.dispatch:dispatch-android-lifecycle-extensions:1.0.0-beta03 ) // ViewModelScope for Android ViewModels implementation( com.rickbusarow.dispatch:dispatch-android-viewmodel:1.0.0-beta03 ) /* jvm testing */ // core coroutines-test testImplementation( org.jetbrains.kotlinx:kotlinx-coroutines-test:1.3.7 ) // you only need this if you don t have the -junit4 or -junit5 artifacts testImplementation( com.rickbusarow.dispatch:dispatch-test:1.0.0-beta03 ) // CoroutineTestRule and :dispatch-test // This provides :dispatch-test via api , so you don t need to declare both // This can be used at the same time as :dispatch-test-junit5 testImplementation( com.rickbusarow.dispatch:dispatch-test-junit4:1.0.0-beta03 ) // CoroutineTest, CoroutineTestExtension, and :dispatch-test // This provides :dispatch-test via api , so you don t need to declare both // This can be used at the same time as :dispatch-test-junit4 testImplementation( com.rickbusarow.dispatch:dispatch-test-junit4:1.0.0-beta03 ) /* Android testing */ // core android androidTestImplementation( androidx.test:runner:1.2.0 ) androidTestImplementation( androidx.test.espresso:espresso-core:3.2.0 ) // IdlingDispatcher, IdlingDispatcherProvider, and IdlingCoroutineScope androidTestImplementation( com.rickbusarow.dispatch:dispatch-android-espresso:1.0.0-beta03 ) }",
      "title": "Full Gradle Config"
    },
    {
      "location": "#license",
      "text": "Copyright (C) 2020 Rick Busarow Licensed under the Apache License, Version 2.0 (the License ); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an AS IS BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.",
      "title": "License"
    },
    {
      "location": "CHANGELOG/",
      "text": "Change log for Dispatch Version 1.0.0-beta03 Renames The project has been renamed from DispatcherProvider to Dispatch. Maven coordinates for existing modules have changed. The base Maven coordinate has changed from com.rickbusarow.DispatcherProvider to com.rickbusarow.dispatch . Base package names have been updated. New artifacts dispatch-android-espresso adds support for IdlingResource dispatchers in Espresso testing. dispatch-android-lifecycle adds an alternative to the Androidx LifecycleScope functionality, with lots of configuration options. dispatch-android-lifecycle-extensions adds the lifecycleScope extension property, but with a configurable factory (useful for Espresso testing). dispatch-android-viewmodel adds an alternative to Androidx viewModelScope with configuration options. dispatch-detekt adds Detekt rules to warn against accidentally using a hard-coded CoroutineDispatcher. dispatch-test-junit4 adds a JUnit4 Rule for automatically providing and cleaning up a TestProvidedCoroutineScope . dispatch-test-junit5 adds JUnit5 Extension support for automatically providing and cleaning up a TestProvidedCoroutineScope . Version 1.0.0-beta02 Test features Added TestBasicDispatcherProvider factory which uses CommonPool for default and io , but a shared single-threaded ExecutorCoroutineDispatcher for main and mainImmediate to provide \"natural\" dispatch behavior in tests without Dispatchers.setMain(...) . Bug fixes and improvements runBlockingTestProvided now uses the same TestCoroutineDispatcher as its ContinuationInterceptor and in its TestDispatcherProvider (#15). runBlockingProvided now uses TestBasicDispatcherProvider as its DispatcherProvider . Version 1.0.0-beta01 Flow Add non-suspending flowOn___() operators for the Flow api. Misc Lots of Kdocs. Maven artifacts. Lower JDK version to 1.6",
      "title": "Change Log"
    },
    {
      "location": "CHANGELOG/#change-log-for-dispatch",
      "text": "",
      "title": "Change log for Dispatch"
    },
    {
      "location": "CHANGELOG/#version-100-beta03",
      "text": "",
      "title": "Version 1.0.0-beta03"
    },
    {
      "location": "CHANGELOG/#renames",
      "text": "The project has been renamed from DispatcherProvider to Dispatch. Maven coordinates for existing modules have changed. The base Maven coordinate has changed from com.rickbusarow.DispatcherProvider to com.rickbusarow.dispatch . Base package names have been updated.",
      "title": "Renames"
    },
    {
      "location": "CHANGELOG/#new-artifacts",
      "text": "dispatch-android-espresso adds support for IdlingResource dispatchers in Espresso testing. dispatch-android-lifecycle adds an alternative to the Androidx LifecycleScope functionality, with lots of configuration options. dispatch-android-lifecycle-extensions adds the lifecycleScope extension property, but with a configurable factory (useful for Espresso testing). dispatch-android-viewmodel adds an alternative to Androidx viewModelScope with configuration options. dispatch-detekt adds Detekt rules to warn against accidentally using a hard-coded CoroutineDispatcher. dispatch-test-junit4 adds a JUnit4 Rule for automatically providing and cleaning up a TestProvidedCoroutineScope . dispatch-test-junit5 adds JUnit5 Extension support for automatically providing and cleaning up a TestProvidedCoroutineScope .",
      "title": "New artifacts"
    },
    {
      "location": "CHANGELOG/#version-100-beta02",
      "text": "",
      "title": "Version 1.0.0-beta02"
    },
    {
      "location": "CHANGELOG/#test-features",
      "text": "Added TestBasicDispatcherProvider factory which uses CommonPool for default and io , but a shared single-threaded ExecutorCoroutineDispatcher for main and mainImmediate to provide \"natural\" dispatch behavior in tests without Dispatchers.setMain(...) .",
      "title": "Test features"
    },
    {
      "location": "CHANGELOG/#bug-fixes-and-improvements",
      "text": "runBlockingTestProvided now uses the same TestCoroutineDispatcher as its ContinuationInterceptor and in its TestDispatcherProvider (#15). runBlockingProvided now uses TestBasicDispatcherProvider as its DispatcherProvider .",
      "title": "Bug fixes and improvements"
    },
    {
      "location": "CHANGELOG/#version-100-beta01",
      "text": "",
      "title": "Version 1.0.0-beta01"
    },
    {
      "location": "CHANGELOG/#flow",
      "text": "Add non-suspending flowOn___() operators for the Flow api.",
      "title": "Flow"
    },
    {
      "location": "CHANGELOG/#misc",
      "text": "Lots of Kdocs. Maven artifacts. Lower JDK version to 1.6",
      "title": "Misc"
    },
    {
      "location": "kdoc/dispatch-android-espresso/",
      "text": "dispatch-android-espresso Tools to provide Espresso functionality for coroutines. If an IdlingDispatcherProvider is registered with the IdlingRegistry , Espresso will wait for all associated coroutines to leave the active state before performing any assertions. Coroutines which are in a suspended state (such as a Job \"observing\" a Flow for updates) do not prevent Espresso from performing assertions. class IdlingCoroutineScopeRuleWithLifecycleSample { // Retrieve the DispatcherProvider from a dependency graph, // so that the same one is used throughout the codebase. val customDispatcherProvider = testAppComponent.customDispatcherProvider @JvmField @Rule val idlingRule = IdlingDispatcherProviderRule { IdlingDispatcherProvider(customDispatcherProvider) } /** * If you don t provide CoroutineScopes to your lifecycle components via a dependency injection framework, * you need to use the `dispatch-android-lifecycle-extensions` and `dispatch-android-viewmodel` artifacts * to ensure that the same `IdlingDispatcherProvider` is used. */ @Before fun setUp () { LifecycleScopeFactory. set { MainImmediateCoroutineScope(customDispatcherProvider) } ViewModelScopeFactory. set { MainImmediateCoroutineScope(customDispatcherProvider) } } @Test fun testThings () = runBlocking { // Now any CoroutineScope which uses the DispatcherProvider // in TestAppComponent will sync its idle state with Espresso } } Contents Types IdlingCoroutineScopes Minimum Gradle Config Types Name Description IdlingDispatcherProviderRule JUnit 4 Rule which automatically registers an IdlingDispatcherProvider with the IdlingRegistry IdlingDispatcher A CoroutineDispatcher which tracks each dispatched coroutine using a CountingIdlingResource . All actual dispatches are delegated to a provided CoroutineDispatcher . IdlingDispatcherProvider A special DispatcherProvider which guarantees that each of its properties is an IdlingDispatcher IdlingCoroutineScope A special CoroutineScope which guarantees a property of an IdlingDispatcherProvider IdlingCoroutineScopes Marker Interface Factory Function Description DefaultIdlingCoroutineScope DefaultIdlingCoroutineScope A IdlingCoroutineScope with a CoroutineDispatcher of default . IOIdlingCoroutineScope IOIdlingCoroutineScope A IdlingCoroutineScope with a CoroutineDispatcher of io . MainIdlingCoroutineScope MainIdlingCoroutineScope A IdlingCoroutineScope with a CoroutineDispatcher of main . MainImmediateIdlingCoroutineScope MainImmediateIdlingCoroutineScope A IdlingCoroutineScope with a CoroutineDispatcher of mainImmediate . UnconfinedIdlingCoroutineScope UnconfinedIdlingCoroutineScope A IdlingCoroutineScope with a CoroutineDispatcher of unconfined . Minimum Gradle Config Add to your module's build.gradle.kts : repositories { mavenCentral() } dependencies { // core implementation( org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.7 ) implementation( org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.7 ) implementation( com.rickbusarow.dispatch:dispatch-core:1.0.0-beta03 ) androidTestImplementation( com.rickbusarow.dispatch:dispatch-android-espresso:1.0.0-beta03 ) // android androidTestImplementation( androidx.test:runner:1.2.0 ) androidTestImplementation( androidx.test.espresso:espresso-core:3.2.0 ) } Packages Name Summary dispatch.android.espresso Index All Types",
      "title": "android-espresso"
    },
    {
      "location": "kdoc/dispatch-android-espresso/#contents",
      "text": "Types IdlingCoroutineScopes Minimum Gradle Config",
      "title": "Contents"
    },
    {
      "location": "kdoc/dispatch-android-espresso/#types",
      "text": "Name Description IdlingDispatcherProviderRule JUnit 4 Rule which automatically registers an IdlingDispatcherProvider with the IdlingRegistry IdlingDispatcher A CoroutineDispatcher which tracks each dispatched coroutine using a CountingIdlingResource . All actual dispatches are delegated to a provided CoroutineDispatcher . IdlingDispatcherProvider A special DispatcherProvider which guarantees that each of its properties is an IdlingDispatcher IdlingCoroutineScope A special CoroutineScope which guarantees a property of an IdlingDispatcherProvider",
      "title": "Types"
    },
    {
      "location": "kdoc/dispatch-android-espresso/#idlingcoroutinescopes",
      "text": "Marker Interface Factory Function Description DefaultIdlingCoroutineScope DefaultIdlingCoroutineScope A IdlingCoroutineScope with a CoroutineDispatcher of default . IOIdlingCoroutineScope IOIdlingCoroutineScope A IdlingCoroutineScope with a CoroutineDispatcher of io . MainIdlingCoroutineScope MainIdlingCoroutineScope A IdlingCoroutineScope with a CoroutineDispatcher of main . MainImmediateIdlingCoroutineScope MainImmediateIdlingCoroutineScope A IdlingCoroutineScope with a CoroutineDispatcher of mainImmediate . UnconfinedIdlingCoroutineScope UnconfinedIdlingCoroutineScope A IdlingCoroutineScope with a CoroutineDispatcher of unconfined .",
      "title": "IdlingCoroutineScopes"
    },
    {
      "location": "kdoc/dispatch-android-espresso/#minimum-gradle-config",
      "text": "Add to your module's build.gradle.kts : repositories { mavenCentral() } dependencies { // core implementation( org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.7 ) implementation( org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.7 ) implementation( com.rickbusarow.dispatch:dispatch-core:1.0.0-beta03 ) androidTestImplementation( com.rickbusarow.dispatch:dispatch-android-espresso:1.0.0-beta03 ) // android androidTestImplementation( androidx.test:runner:1.2.0 ) androidTestImplementation( androidx.test.espresso:espresso-core:3.2.0 ) }",
      "title": "Minimum Gradle Config"
    },
    {
      "location": "kdoc/dispatch-android-espresso/#packages",
      "text": "Name Summary dispatch.android.espresso",
      "title": "Packages"
    },
    {
      "location": "kdoc/dispatch-android-espresso/#index",
      "text": "All Types",
      "title": "Index"
    },
    {
      "location": "kdoc/dispatch-android-espresso/alltypes/",
      "text": "Tools to provide Espresso functionality for coroutines. All Types Name Summary dispatch.android.espresso.DefaultIdlingCoroutineScope Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.default | dispatch.android.espresso.IdlingCoroutineScope Special CoroutineScope with a DispatcherProvider which is an IdlingDispatcherProvider . | dispatch.android.espresso.IdlingDispatcher IdlingResource helper for coroutines. This class simply wraps a delegate CoroutineDispatcher and keeps a running count of all coroutines it creates, decrementing the count when they complete. | dispatch.android.espresso.IdlingDispatcherProvider IdlingResource helper for coroutines. This DispatcherProvider implementation utilizes an IdlingDispatcher for each CoroutineDispatcher . | dispatch.android.espresso.IdlingDispatcherProviderRule A JUnit 4 TestRule which creates a new IdlingDispatcherProvider for each test, registering all IdlingDispatcher s with IdlingRegistry before @Before and unregistering them after @After . | dispatch.android.espresso.IOIdlingCoroutineScope Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.io | dispatch.android.espresso.MainIdlingCoroutineScope Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.main | dispatch.android.espresso.MainImmediateIdlingCoroutineScope Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.mainImmediate | dispatch.android.espresso.UnconfinedIdlingCoroutineScope Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.unconfined",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-android-espresso/alltypes/#all-types",
      "text": "Name Summary",
      "title": "All Types"
    },
    {
      "location": "kdoc/dispatch-android-espresso/alltypes/#dispatchandroidespressodefaultidlingcoroutinescope",
      "text": "Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.default |",
      "title": "dispatch.android.espresso.DefaultIdlingCoroutineScope"
    },
    {
      "location": "kdoc/dispatch-android-espresso/alltypes/#dispatchandroidespressoidlingcoroutinescope",
      "text": "Special CoroutineScope with a DispatcherProvider which is an IdlingDispatcherProvider . |",
      "title": "dispatch.android.espresso.IdlingCoroutineScope"
    },
    {
      "location": "kdoc/dispatch-android-espresso/alltypes/#dispatchandroidespressoidlingdispatcher",
      "text": "IdlingResource helper for coroutines. This class simply wraps a delegate CoroutineDispatcher and keeps a running count of all coroutines it creates, decrementing the count when they complete. |",
      "title": "dispatch.android.espresso.IdlingDispatcher"
    },
    {
      "location": "kdoc/dispatch-android-espresso/alltypes/#dispatchandroidespressoidlingdispatcherprovider",
      "text": "IdlingResource helper for coroutines. This DispatcherProvider implementation utilizes an IdlingDispatcher for each CoroutineDispatcher . |",
      "title": "dispatch.android.espresso.IdlingDispatcherProvider"
    },
    {
      "location": "kdoc/dispatch-android-espresso/alltypes/#dispatchandroidespressoidlingdispatcherproviderrule",
      "text": "A JUnit 4 TestRule which creates a new IdlingDispatcherProvider for each test, registering all IdlingDispatcher s with IdlingRegistry before @Before and unregistering them after @After . |",
      "title": "dispatch.android.espresso.IdlingDispatcherProviderRule"
    },
    {
      "location": "kdoc/dispatch-android-espresso/alltypes/#dispatchandroidespressoioidlingcoroutinescope",
      "text": "Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.io |",
      "title": "dispatch.android.espresso.IOIdlingCoroutineScope"
    },
    {
      "location": "kdoc/dispatch-android-espresso/alltypes/#dispatchandroidespressomainidlingcoroutinescope",
      "text": "Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.main |",
      "title": "dispatch.android.espresso.MainIdlingCoroutineScope"
    },
    {
      "location": "kdoc/dispatch-android-espresso/alltypes/#dispatchandroidespressomainimmediateidlingcoroutinescope",
      "text": "Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.mainImmediate |",
      "title": "dispatch.android.espresso.MainImmediateIdlingCoroutineScope"
    },
    {
      "location": "kdoc/dispatch-android-espresso/alltypes/#dispatchandroidespressounconfinedidlingcoroutinescope",
      "text": "Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.unconfined",
      "title": "dispatch.android.espresso.UnconfinedIdlingCoroutineScope"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/",
      "text": "dispatch-android-espresso / dispatch.android.espresso Package dispatch.android.espresso Types Name Summary DefaultIdlingCoroutineScope Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.default interface DefaultIdlingCoroutineScope : IdlingCoroutineScope , DefaultCoroutineScope IdlingCoroutineScope Special CoroutineScope with a DispatcherProvider which is an IdlingDispatcherProvider . interface IdlingCoroutineScope : CoroutineScope IdlingDispatcher IdlingResource helper for coroutines. This class simply wraps a delegate CoroutineDispatcher and keeps a running count of all coroutines it creates, decrementing the count when they complete. class IdlingDispatcher : CoroutineDispatcher IdlingDispatcherProvider IdlingResource helper for coroutines. This DispatcherProvider implementation utilizes an IdlingDispatcher for each CoroutineDispatcher . class IdlingDispatcherProvider : DispatcherProvider IdlingDispatcherProviderRule A JUnit 4 TestRule which creates a new IdlingDispatcherProvider for each test, registering all IdlingDispatcher s with IdlingRegistry before @Before and unregistering them after @After . class IdlingDispatcherProviderRule : TestWatcher IOIdlingCoroutineScope Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.io interface IOIdlingCoroutineScope : IdlingCoroutineScope , IOCoroutineScope MainIdlingCoroutineScope Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.main interface MainIdlingCoroutineScope : IdlingCoroutineScope , MainCoroutineScope MainImmediateIdlingCoroutineScope Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.mainImmediate interface MainImmediateIdlingCoroutineScope : IdlingCoroutineScope , MainImmediateCoroutineScope UnconfinedIdlingCoroutineScope Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.unconfined interface UnconfinedIdlingCoroutineScope : IdlingCoroutineScope , UnconfinedCoroutineScope Functions Name Summary DefaultIdlingCoroutineScope Factory function for a DefaultIdlingCoroutineScope . fun DefaultIdlingCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: IdlingDispatcherProvider = IdlingDispatcherProvider()): DefaultIdlingCoroutineScope IdlingCoroutineScope Factory function for an IdlingCoroutineScope . fun IdlingCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: IdlingDispatcherProvider = IdlingDispatcherProvider()): IdlingCoroutineScope IdlingDispatcherProvider IdlingDispatcherProvider factory function, which creates an instance using an existing DispatcherProvider . fun IdlingDispatcherProvider(delegate: DispatcherProvider = DefaultDispatcherProvider()): IdlingDispatcherProvider IOIdlingCoroutineScope Factory function for an IOIdlingCoroutineScope . fun IOIdlingCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: IdlingDispatcherProvider = IdlingDispatcherProvider()): IOIdlingCoroutineScope MainIdlingCoroutineScope Factory function for a MainIdlingCoroutineScope . fun MainIdlingCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: IdlingDispatcherProvider = IdlingDispatcherProvider()): MainIdlingCoroutineScope MainImmediateIdlingCoroutineScope Factory function for a MainImmediateIdlingCoroutineScope . fun MainImmediateIdlingCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: IdlingDispatcherProvider = IdlingDispatcherProvider()): MainImmediateIdlingCoroutineScope registerAllIdlingResources Register all IdlingDispatcher properties of the receiver IdlingDispatcherProvider with Espresso's IdlingRegistry . fun IdlingDispatcherProvider .registerAllIdlingResources(): Unit UnconfinedIdlingCoroutineScope Factory function for an UnconfinedIdlingCoroutineScope . fun UnconfinedIdlingCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: IdlingDispatcherProvider = IdlingDispatcherProvider()): UnconfinedIdlingCoroutineScope unregisterAllIdlingResources Unregister all IdlingDispatcher properties of the receiver IdlingDispatcherProvider with Espresso's IdlingRegistry . fun IdlingDispatcherProvider .unregisterAllIdlingResources(): Unit",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/#package-dispatchandroidespresso",
      "text": "",
      "title": "Package dispatch.android.espresso"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/#types",
      "text": "Name Summary DefaultIdlingCoroutineScope Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.default interface DefaultIdlingCoroutineScope : IdlingCoroutineScope , DefaultCoroutineScope IdlingCoroutineScope Special CoroutineScope with a DispatcherProvider which is an IdlingDispatcherProvider . interface IdlingCoroutineScope : CoroutineScope IdlingDispatcher IdlingResource helper for coroutines. This class simply wraps a delegate CoroutineDispatcher and keeps a running count of all coroutines it creates, decrementing the count when they complete. class IdlingDispatcher : CoroutineDispatcher IdlingDispatcherProvider IdlingResource helper for coroutines. This DispatcherProvider implementation utilizes an IdlingDispatcher for each CoroutineDispatcher . class IdlingDispatcherProvider : DispatcherProvider IdlingDispatcherProviderRule A JUnit 4 TestRule which creates a new IdlingDispatcherProvider for each test, registering all IdlingDispatcher s with IdlingRegistry before @Before and unregistering them after @After . class IdlingDispatcherProviderRule : TestWatcher IOIdlingCoroutineScope Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.io interface IOIdlingCoroutineScope : IdlingCoroutineScope , IOCoroutineScope MainIdlingCoroutineScope Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.main interface MainIdlingCoroutineScope : IdlingCoroutineScope , MainCoroutineScope MainImmediateIdlingCoroutineScope Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.mainImmediate interface MainImmediateIdlingCoroutineScope : IdlingCoroutineScope , MainImmediateCoroutineScope UnconfinedIdlingCoroutineScope Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.unconfined interface UnconfinedIdlingCoroutineScope : IdlingCoroutineScope , UnconfinedCoroutineScope",
      "title": "Types"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/#functions",
      "text": "Name Summary DefaultIdlingCoroutineScope Factory function for a DefaultIdlingCoroutineScope . fun DefaultIdlingCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: IdlingDispatcherProvider = IdlingDispatcherProvider()): DefaultIdlingCoroutineScope IdlingCoroutineScope Factory function for an IdlingCoroutineScope . fun IdlingCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: IdlingDispatcherProvider = IdlingDispatcherProvider()): IdlingCoroutineScope IdlingDispatcherProvider IdlingDispatcherProvider factory function, which creates an instance using an existing DispatcherProvider . fun IdlingDispatcherProvider(delegate: DispatcherProvider = DefaultDispatcherProvider()): IdlingDispatcherProvider IOIdlingCoroutineScope Factory function for an IOIdlingCoroutineScope . fun IOIdlingCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: IdlingDispatcherProvider = IdlingDispatcherProvider()): IOIdlingCoroutineScope MainIdlingCoroutineScope Factory function for a MainIdlingCoroutineScope . fun MainIdlingCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: IdlingDispatcherProvider = IdlingDispatcherProvider()): MainIdlingCoroutineScope MainImmediateIdlingCoroutineScope Factory function for a MainImmediateIdlingCoroutineScope . fun MainImmediateIdlingCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: IdlingDispatcherProvider = IdlingDispatcherProvider()): MainImmediateIdlingCoroutineScope registerAllIdlingResources Register all IdlingDispatcher properties of the receiver IdlingDispatcherProvider with Espresso's IdlingRegistry . fun IdlingDispatcherProvider .registerAllIdlingResources(): Unit UnconfinedIdlingCoroutineScope Factory function for an UnconfinedIdlingCoroutineScope . fun UnconfinedIdlingCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: IdlingDispatcherProvider = IdlingDispatcherProvider()): UnconfinedIdlingCoroutineScope unregisterAllIdlingResources Unregister all IdlingDispatcher properties of the receiver IdlingDispatcherProvider with Espresso's IdlingRegistry . fun IdlingDispatcherProvider .unregisterAllIdlingResources(): Unit",
      "title": "Functions"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-default-idling-coroutine-scope/",
      "text": "dispatch-android-espresso / dispatch.android.espresso / DefaultIdlingCoroutineScope DefaultIdlingCoroutineScope interface DefaultIdlingCoroutineScope : IdlingCoroutineScope , DefaultCoroutineScope (source) Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.default See Also IdlingDispatcherProvider IdlingResource IdlingCoroutineScope fun DefaultIdlingCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: IdlingDispatcherProvider = IdlingDispatcherProvider()): DefaultIdlingCoroutineScope (source) Factory function for a DefaultIdlingCoroutineScope . val scope = DefaultIdlingCoroutineScope() scope.idlingDispatcherProvider.registerAllIdlingResources() val scope = DefaultIdlingCoroutineScope( job = Job(), dispatcherProvider = SomeCustomIdlingDispatcherProvider() ) scope.idlingDispatcherProvider.registerAllIdlingResources() Parameters job - optional The Job used in creation of the CoroutineContext . Uses SupervisorJob by default. dispatcherProvider - The IdlingDispatcherProvider used in creation of the CoroutineContext . Uses the default IdlingDispatcherProvider factory by default. See Also IdlingDispatcherProvider IdlingResource IdlingCoroutineScope",
      "title": " default idling coroutine scope"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-default-idling-coroutine-scope/#defaultidlingcoroutinescope",
      "text": "interface DefaultIdlingCoroutineScope : IdlingCoroutineScope , DefaultCoroutineScope (source) Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.default See Also IdlingDispatcherProvider IdlingResource IdlingCoroutineScope fun DefaultIdlingCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: IdlingDispatcherProvider = IdlingDispatcherProvider()): DefaultIdlingCoroutineScope (source) Factory function for a DefaultIdlingCoroutineScope . val scope = DefaultIdlingCoroutineScope() scope.idlingDispatcherProvider.registerAllIdlingResources() val scope = DefaultIdlingCoroutineScope( job = Job(), dispatcherProvider = SomeCustomIdlingDispatcherProvider() ) scope.idlingDispatcherProvider.registerAllIdlingResources()",
      "title": "DefaultIdlingCoroutineScope"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-default-idling-coroutine-scope/#parameters",
      "text": "job - optional The Job used in creation of the CoroutineContext . Uses SupervisorJob by default. dispatcherProvider - The IdlingDispatcherProvider used in creation of the CoroutineContext . Uses the default IdlingDispatcherProvider factory by default. See Also IdlingDispatcherProvider IdlingResource IdlingCoroutineScope",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-i-o-idling-coroutine-scope/",
      "text": "dispatch-android-espresso / dispatch.android.espresso / IOIdlingCoroutineScope IOIdlingCoroutineScope interface IOIdlingCoroutineScope : IdlingCoroutineScope , IOCoroutineScope (source) Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.io See Also IdlingDispatcherProvider IdlingResource IdlingCoroutineScope fun IOIdlingCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: IdlingDispatcherProvider = IdlingDispatcherProvider()): IOIdlingCoroutineScope (source) Factory function for an IOIdlingCoroutineScope . val scope = IOIdlingCoroutineScope() scope.idlingDispatcherProvider.registerAllIdlingResources() val scope = IOIdlingCoroutineScope( job = Job(), dispatcherProvider = SomeCustomIdlingDispatcherProvider() ) scope.idlingDispatcherProvider.registerAllIdlingResources() Parameters job - optional The Job used in creation of the CoroutineContext . Uses SupervisorJob by default. dispatcherProvider - The IdlingDispatcherProvider used in creation of the CoroutineContext . Uses the default IdlingDispatcherProvider factory by default. See Also IdlingDispatcherProvider IdlingResource IdlingCoroutineScope",
      "title": " i o idling coroutine scope"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-i-o-idling-coroutine-scope/#ioidlingcoroutinescope",
      "text": "interface IOIdlingCoroutineScope : IdlingCoroutineScope , IOCoroutineScope (source) Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.io See Also IdlingDispatcherProvider IdlingResource IdlingCoroutineScope fun IOIdlingCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: IdlingDispatcherProvider = IdlingDispatcherProvider()): IOIdlingCoroutineScope (source) Factory function for an IOIdlingCoroutineScope . val scope = IOIdlingCoroutineScope() scope.idlingDispatcherProvider.registerAllIdlingResources() val scope = IOIdlingCoroutineScope( job = Job(), dispatcherProvider = SomeCustomIdlingDispatcherProvider() ) scope.idlingDispatcherProvider.registerAllIdlingResources()",
      "title": "IOIdlingCoroutineScope"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-i-o-idling-coroutine-scope/#parameters",
      "text": "job - optional The Job used in creation of the CoroutineContext . Uses SupervisorJob by default. dispatcherProvider - The IdlingDispatcherProvider used in creation of the CoroutineContext . Uses the default IdlingDispatcherProvider factory by default. See Also IdlingDispatcherProvider IdlingResource IdlingCoroutineScope",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-coroutine-scope/",
      "text": "dispatch-android-espresso / dispatch.android.espresso / IdlingCoroutineScope IdlingCoroutineScope fun IdlingCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: IdlingDispatcherProvider = IdlingDispatcherProvider()): IdlingCoroutineScope (source) Factory function for an IdlingCoroutineScope . val scope = IdlingCoroutineScope() scope.idlingDispatcherProvider.registerAllIdlingResources() val scope = IdlingCoroutineScope( job = Job(), dispatcherProvider = SomeCustomIdlingDispatcherProvider() ) scope.idlingDispatcherProvider.registerAllIdlingResources() Parameters job - optional The Job used in creation of the CoroutineContext . Uses SupervisorJob by default. dispatcherProvider - The IdlingDispatcherProvider used in creation of the CoroutineContext . Uses the default IdlingDispatcherProvider factory by default. See Also IdlingDispatcherProvider IdlingResource IdlingCoroutineScope",
      "title": " idling coroutine scope"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-coroutine-scope/#idlingcoroutinescope",
      "text": "fun IdlingCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: IdlingDispatcherProvider = IdlingDispatcherProvider()): IdlingCoroutineScope (source) Factory function for an IdlingCoroutineScope . val scope = IdlingCoroutineScope() scope.idlingDispatcherProvider.registerAllIdlingResources() val scope = IdlingCoroutineScope( job = Job(), dispatcherProvider = SomeCustomIdlingDispatcherProvider() ) scope.idlingDispatcherProvider.registerAllIdlingResources()",
      "title": "IdlingCoroutineScope"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-coroutine-scope/#parameters",
      "text": "job - optional The Job used in creation of the CoroutineContext . Uses SupervisorJob by default. dispatcherProvider - The IdlingDispatcherProvider used in creation of the CoroutineContext . Uses the default IdlingDispatcherProvider factory by default. See Also IdlingDispatcherProvider IdlingResource IdlingCoroutineScope",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider/",
      "text": "dispatch-android-espresso / dispatch.android.espresso / IdlingDispatcherProvider IdlingDispatcherProvider fun IdlingDispatcherProvider(delegate: DispatcherProvider = DefaultDispatcherProvider()): IdlingDispatcherProvider (source) IdlingDispatcherProvider factory function, which creates an instance using an existing DispatcherProvider . Parameters delegate - optional Use this DispatcherProvider to create a single IdlingDispatcher which is used as all properties for the IdlingDispatcherProvider . Uses a DefaultDispatcherProvider if no instance provided. See Also IdlingResource DispatcherProvider IdlingDispatcher CoroutineDispatcher",
      "title": " idling dispatcher provider"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider/#idlingdispatcherprovider",
      "text": "fun IdlingDispatcherProvider(delegate: DispatcherProvider = DefaultDispatcherProvider()): IdlingDispatcherProvider (source) IdlingDispatcherProvider factory function, which creates an instance using an existing DispatcherProvider .",
      "title": "IdlingDispatcherProvider"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider/#parameters",
      "text": "delegate - optional Use this DispatcherProvider to create a single IdlingDispatcher which is used as all properties for the IdlingDispatcherProvider . Uses a DefaultDispatcherProvider if no instance provided. See Also IdlingResource DispatcherProvider IdlingDispatcher CoroutineDispatcher",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-main-idling-coroutine-scope/",
      "text": "dispatch-android-espresso / dispatch.android.espresso / MainIdlingCoroutineScope MainIdlingCoroutineScope interface MainIdlingCoroutineScope : IdlingCoroutineScope , MainCoroutineScope (source) Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.main See Also IdlingDispatcherProvider IdlingResource IdlingCoroutineScope fun MainIdlingCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: IdlingDispatcherProvider = IdlingDispatcherProvider()): MainIdlingCoroutineScope (source) Factory function for a MainIdlingCoroutineScope . val scope = MainIdlingCoroutineScope() scope.idlingDispatcherProvider.registerAllIdlingResources() val scope = MainIdlingCoroutineScope( job = Job(), dispatcherProvider = SomeCustomIdlingDispatcherProvider() ) scope.idlingDispatcherProvider.registerAllIdlingResources() Parameters job - optional The Job used in creation of the CoroutineContext . Uses SupervisorJob by default. dispatcherProvider - The IdlingDispatcherProvider used in creation of the CoroutineContext . Uses the default IdlingDispatcherProvider factory by default. See Also IdlingDispatcherProvider IdlingResource IdlingCoroutineScope",
      "title": " main idling coroutine scope"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-main-idling-coroutine-scope/#mainidlingcoroutinescope",
      "text": "interface MainIdlingCoroutineScope : IdlingCoroutineScope , MainCoroutineScope (source) Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.main See Also IdlingDispatcherProvider IdlingResource IdlingCoroutineScope fun MainIdlingCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: IdlingDispatcherProvider = IdlingDispatcherProvider()): MainIdlingCoroutineScope (source) Factory function for a MainIdlingCoroutineScope . val scope = MainIdlingCoroutineScope() scope.idlingDispatcherProvider.registerAllIdlingResources() val scope = MainIdlingCoroutineScope( job = Job(), dispatcherProvider = SomeCustomIdlingDispatcherProvider() ) scope.idlingDispatcherProvider.registerAllIdlingResources()",
      "title": "MainIdlingCoroutineScope"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-main-idling-coroutine-scope/#parameters",
      "text": "job - optional The Job used in creation of the CoroutineContext . Uses SupervisorJob by default. dispatcherProvider - The IdlingDispatcherProvider used in creation of the CoroutineContext . Uses the default IdlingDispatcherProvider factory by default. See Also IdlingDispatcherProvider IdlingResource IdlingCoroutineScope",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-main-immediate-idling-coroutine-scope/",
      "text": "dispatch-android-espresso / dispatch.android.espresso / MainImmediateIdlingCoroutineScope MainImmediateIdlingCoroutineScope interface MainImmediateIdlingCoroutineScope : IdlingCoroutineScope , MainImmediateCoroutineScope (source) Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.mainImmediate See Also IdlingDispatcherProvider IdlingResource IdlingCoroutineScope fun MainImmediateIdlingCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: IdlingDispatcherProvider = IdlingDispatcherProvider()): MainImmediateIdlingCoroutineScope (source) Factory function for a MainImmediateIdlingCoroutineScope . val scope = MainImmediateIdlingCoroutineScope() scope.idlingDispatcherProvider.registerAllIdlingResources() val scope = MainImmediateIdlingCoroutineScope( job = Job(), dispatcherProvider = SomeCustomIdlingDispatcherProvider() ) scope.idlingDispatcherProvider.registerAllIdlingResources() Parameters job - optional The Job used in creation of the CoroutineContext . Uses SupervisorJob by default. dispatcherProvider - The IdlingDispatcherProvider used in creation of the CoroutineContext . Uses the default IdlingDispatcherProvider factory by default. See Also IdlingDispatcherProvider IdlingResource IdlingCoroutineScope",
      "title": " main immediate idling coroutine scope"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-main-immediate-idling-coroutine-scope/#mainimmediateidlingcoroutinescope",
      "text": "interface MainImmediateIdlingCoroutineScope : IdlingCoroutineScope , MainImmediateCoroutineScope (source) Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.mainImmediate See Also IdlingDispatcherProvider IdlingResource IdlingCoroutineScope fun MainImmediateIdlingCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: IdlingDispatcherProvider = IdlingDispatcherProvider()): MainImmediateIdlingCoroutineScope (source) Factory function for a MainImmediateIdlingCoroutineScope . val scope = MainImmediateIdlingCoroutineScope() scope.idlingDispatcherProvider.registerAllIdlingResources() val scope = MainImmediateIdlingCoroutineScope( job = Job(), dispatcherProvider = SomeCustomIdlingDispatcherProvider() ) scope.idlingDispatcherProvider.registerAllIdlingResources()",
      "title": "MainImmediateIdlingCoroutineScope"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-main-immediate-idling-coroutine-scope/#parameters",
      "text": "job - optional The Job used in creation of the CoroutineContext . Uses SupervisorJob by default. dispatcherProvider - The IdlingDispatcherProvider used in creation of the CoroutineContext . Uses the default IdlingDispatcherProvider factory by default. See Also IdlingDispatcherProvider IdlingResource IdlingCoroutineScope",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-unconfined-idling-coroutine-scope/",
      "text": "dispatch-android-espresso / dispatch.android.espresso / UnconfinedIdlingCoroutineScope UnconfinedIdlingCoroutineScope interface UnconfinedIdlingCoroutineScope : IdlingCoroutineScope , UnconfinedCoroutineScope (source) Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.unconfined See Also IdlingDispatcherProvider IdlingResource IdlingCoroutineScope fun UnconfinedIdlingCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: IdlingDispatcherProvider = IdlingDispatcherProvider()): UnconfinedIdlingCoroutineScope (source) Factory function for an UnconfinedIdlingCoroutineScope . val scope = UnconfinedIdlingCoroutineScope() scope.idlingDispatcherProvider.registerAllIdlingResources() val scope = UnconfinedIdlingCoroutineScope( job = Job(), dispatcherProvider = SomeCustomIdlingDispatcherProvider() ) scope.idlingDispatcherProvider.registerAllIdlingResources() Parameters job - optional The Job used in creation of the CoroutineContext . Uses SupervisorJob by default. dispatcherProvider - The IdlingDispatcherProvider used in creation of the CoroutineContext . Uses the default IdlingDispatcherProvider factory by default. See Also IdlingDispatcherProvider IdlingResource IdlingCoroutineScope",
      "title": " unconfined idling coroutine scope"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-unconfined-idling-coroutine-scope/#unconfinedidlingcoroutinescope",
      "text": "interface UnconfinedIdlingCoroutineScope : IdlingCoroutineScope , UnconfinedCoroutineScope (source) Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.unconfined See Also IdlingDispatcherProvider IdlingResource IdlingCoroutineScope fun UnconfinedIdlingCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: IdlingDispatcherProvider = IdlingDispatcherProvider()): UnconfinedIdlingCoroutineScope (source) Factory function for an UnconfinedIdlingCoroutineScope . val scope = UnconfinedIdlingCoroutineScope() scope.idlingDispatcherProvider.registerAllIdlingResources() val scope = UnconfinedIdlingCoroutineScope( job = Job(), dispatcherProvider = SomeCustomIdlingDispatcherProvider() ) scope.idlingDispatcherProvider.registerAllIdlingResources()",
      "title": "UnconfinedIdlingCoroutineScope"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-unconfined-idling-coroutine-scope/#parameters",
      "text": "job - optional The Job used in creation of the CoroutineContext . Uses SupervisorJob by default. dispatcherProvider - The IdlingDispatcherProvider used in creation of the CoroutineContext . Uses the default IdlingDispatcherProvider factory by default. See Also IdlingDispatcherProvider IdlingResource IdlingCoroutineScope",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/register-all-idling-resources/",
      "text": "dispatch-android-espresso / dispatch.android.espresso / registerAllIdlingResources registerAllIdlingResources fun IdlingDispatcherProvider .registerAllIdlingResources(): Unit (source) Register all IdlingDispatcher properties of the receiver IdlingDispatcherProvider with Espresso's IdlingRegistry . This should be done before executing a test. After test execution, be sure to call the companion IdlingDispatcherProvider.unregisterAllIdlingResources . See Also IdlingDispatcherProvider.unregisterAllIdlingResources",
      "title": "Register all idling resources"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/register-all-idling-resources/#registerallidlingresources",
      "text": "fun IdlingDispatcherProvider .registerAllIdlingResources(): Unit (source) Register all IdlingDispatcher properties of the receiver IdlingDispatcherProvider with Espresso's IdlingRegistry . This should be done before executing a test. After test execution, be sure to call the companion IdlingDispatcherProvider.unregisterAllIdlingResources . See Also IdlingDispatcherProvider.unregisterAllIdlingResources",
      "title": "registerAllIdlingResources"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/unregister-all-idling-resources/",
      "text": "dispatch-android-espresso / dispatch.android.espresso / unregisterAllIdlingResources unregisterAllIdlingResources fun IdlingDispatcherProvider .unregisterAllIdlingResources(): Unit (source) Unregister all IdlingDispatcher properties of the receiver IdlingDispatcherProvider with Espresso's IdlingRegistry . This should be done after executing a test. Before test execution, be sure to call the companion IdlingDispatcherProvider.registerAllIdlingResources or this function will have no effect. See Also IdlingDispatcherProvider.registerAllIdlingResources",
      "title": "Unregister all idling resources"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/unregister-all-idling-resources/#unregisterallidlingresources",
      "text": "fun IdlingDispatcherProvider .unregisterAllIdlingResources(): Unit (source) Unregister all IdlingDispatcher properties of the receiver IdlingDispatcherProvider with Espresso's IdlingRegistry . This should be done after executing a test. Before test execution, be sure to call the companion IdlingDispatcherProvider.registerAllIdlingResources or this function will have no effect. See Also IdlingDispatcherProvider.registerAllIdlingResources",
      "title": "unregisterAllIdlingResources"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-coroutine-scope/",
      "text": "dispatch-android-espresso / dispatch.android.espresso / IdlingCoroutineScope IdlingCoroutineScope interface IdlingCoroutineScope : CoroutineScope (source) Special CoroutineScope with a DispatcherProvider which is an IdlingDispatcherProvider . See Also IdlingDispatcherProvider IdlingResource Properties Name Summary idlingDispatcherProvider Any IdlingCoroutineScope has an idlingDispatcherProvider property which can be registered in the IdlingRegistry . abstract val idlingDispatcherProvider: IdlingDispatcherProvider Inheritors Name Summary DefaultIdlingCoroutineScope Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.default interface DefaultIdlingCoroutineScope : IdlingCoroutineScope , DefaultCoroutineScope IOIdlingCoroutineScope Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.io interface IOIdlingCoroutineScope : IdlingCoroutineScope , IOCoroutineScope MainIdlingCoroutineScope Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.main interface MainIdlingCoroutineScope : IdlingCoroutineScope , MainCoroutineScope MainImmediateIdlingCoroutineScope Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.mainImmediate interface MainImmediateIdlingCoroutineScope : IdlingCoroutineScope , MainImmediateCoroutineScope UnconfinedIdlingCoroutineScope Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.unconfined interface UnconfinedIdlingCoroutineScope : IdlingCoroutineScope , UnconfinedCoroutineScope",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-coroutine-scope/#idlingcoroutinescope",
      "text": "interface IdlingCoroutineScope : CoroutineScope (source) Special CoroutineScope with a DispatcherProvider which is an IdlingDispatcherProvider . See Also IdlingDispatcherProvider IdlingResource",
      "title": "IdlingCoroutineScope"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-coroutine-scope/#properties",
      "text": "Name Summary idlingDispatcherProvider Any IdlingCoroutineScope has an idlingDispatcherProvider property which can be registered in the IdlingRegistry . abstract val idlingDispatcherProvider: IdlingDispatcherProvider",
      "title": "Properties"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-coroutine-scope/#inheritors",
      "text": "Name Summary DefaultIdlingCoroutineScope Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.default interface DefaultIdlingCoroutineScope : IdlingCoroutineScope , DefaultCoroutineScope IOIdlingCoroutineScope Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.io interface IOIdlingCoroutineScope : IdlingCoroutineScope , IOCoroutineScope MainIdlingCoroutineScope Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.main interface MainIdlingCoroutineScope : IdlingCoroutineScope , MainCoroutineScope MainImmediateIdlingCoroutineScope Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.mainImmediate interface MainImmediateIdlingCoroutineScope : IdlingCoroutineScope , MainImmediateCoroutineScope UnconfinedIdlingCoroutineScope Marker interface for an IdlingCoroutineScope which indicates that its CoroutineDispatcher is DispatcherProvider.unconfined interface UnconfinedIdlingCoroutineScope : IdlingCoroutineScope , UnconfinedCoroutineScope",
      "title": "Inheritors"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-coroutine-scope/idling-dispatcher-provider/",
      "text": "dispatch-android-espresso / dispatch.android.espresso / IdlingCoroutineScope / idlingDispatcherProvider idlingDispatcherProvider abstract val idlingDispatcherProvider: IdlingDispatcherProvider (source) Any IdlingCoroutineScope has an idlingDispatcherProvider property which can be registered in the IdlingRegistry .",
      "title": "Idling dispatcher provider"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-coroutine-scope/idling-dispatcher-provider/#idlingdispatcherprovider",
      "text": "abstract val idlingDispatcherProvider: IdlingDispatcherProvider (source) Any IdlingCoroutineScope has an idlingDispatcherProvider property which can be registered in the IdlingRegistry .",
      "title": "idlingDispatcherProvider"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher/",
      "text": "dispatch-android-espresso / dispatch.android.espresso / IdlingDispatcher IdlingDispatcher class IdlingDispatcher : CoroutineDispatcher (source) IdlingResource helper for coroutines. This class simply wraps a delegate CoroutineDispatcher and keeps a running count of all coroutines it creates, decrementing the count when they complete. Parameters delegate - The CoroutineDispatcher which will be used for actual dispatch. See Also IdlingResource Espresso CoroutineDispatcher Constructors Name Summary init IdlingResource helper for coroutines. This class simply wraps a delegate CoroutineDispatcher and keeps a running count of all coroutines it creates, decrementing the count when they complete. IdlingDispatcher(delegate: CoroutineDispatcher ) Properties Name Summary counter The CountingIdlingResource which is responsible for Espresso functionality. val counter: CountingIdlingResource Functions Name Summary dispatch Counting implementation of the dispatch function. fun dispatch(context: CoroutineContext , block: Runnable ): Unit isIdle fun isIdle(): Boolean",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher/#idlingdispatcher",
      "text": "class IdlingDispatcher : CoroutineDispatcher (source) IdlingResource helper for coroutines. This class simply wraps a delegate CoroutineDispatcher and keeps a running count of all coroutines it creates, decrementing the count when they complete.",
      "title": "IdlingDispatcher"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher/#parameters",
      "text": "delegate - The CoroutineDispatcher which will be used for actual dispatch. See Also IdlingResource Espresso CoroutineDispatcher",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher/#constructors",
      "text": "Name Summary init IdlingResource helper for coroutines. This class simply wraps a delegate CoroutineDispatcher and keeps a running count of all coroutines it creates, decrementing the count when they complete. IdlingDispatcher(delegate: CoroutineDispatcher )",
      "title": "Constructors"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher/#properties",
      "text": "Name Summary counter The CountingIdlingResource which is responsible for Espresso functionality. val counter: CountingIdlingResource",
      "title": "Properties"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher/#functions",
      "text": "Name Summary dispatch Counting implementation of the dispatch function. fun dispatch(context: CoroutineContext , block: Runnable ): Unit isIdle fun isIdle(): Boolean",
      "title": "Functions"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher/-init-/",
      "text": "dispatch-android-espresso / dispatch.android.espresso / IdlingDispatcher / init init IdlingDispatcher(delegate: CoroutineDispatcher ) IdlingResource helper for coroutines. This class simply wraps a delegate CoroutineDispatcher and keeps a running count of all coroutines it creates, decrementing the count when they complete. Parameters delegate - The CoroutineDispatcher which will be used for actual dispatch. See Also IdlingResource Espresso CoroutineDispatcher",
      "title": " init "
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher/-init-/#init",
      "text": "IdlingDispatcher(delegate: CoroutineDispatcher ) IdlingResource helper for coroutines. This class simply wraps a delegate CoroutineDispatcher and keeps a running count of all coroutines it creates, decrementing the count when they complete.",
      "title": "&lt;init&gt;"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher/-init-/#parameters",
      "text": "delegate - The CoroutineDispatcher which will be used for actual dispatch. See Also IdlingResource Espresso CoroutineDispatcher",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher/counter/",
      "text": "dispatch-android-espresso / dispatch.android.espresso / IdlingDispatcher / counter counter val counter: CountingIdlingResource (source) The CountingIdlingResource which is responsible for Espresso functionality.",
      "title": "Counter"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher/counter/#counter",
      "text": "val counter: CountingIdlingResource (source) The CountingIdlingResource which is responsible for Espresso functionality.",
      "title": "counter"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher/dispatch/",
      "text": "dispatch-android-espresso / dispatch.android.espresso / IdlingDispatcher / dispatch dispatch fun dispatch(context: CoroutineContext , block: Runnable ): Unit (source) Counting implementation of the dispatch function. The count is incremented for every dispatch, and decremented for every completion, including suspension.",
      "title": "Dispatch"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher/dispatch/#dispatch",
      "text": "fun dispatch(context: CoroutineContext , block: Runnable ): Unit (source) Counting implementation of the dispatch function. The count is incremented for every dispatch, and decremented for every completion, including suspension.",
      "title": "dispatch"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher/is-idle/",
      "text": "dispatch-android-espresso / dispatch.android.espresso / IdlingDispatcher / isIdle isIdle fun isIdle(): Boolean (source) Return * true if the counter 's count is zero * false if the counter 's count is non-zero",
      "title": "Is idle"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher/is-idle/#isidle",
      "text": "fun isIdle(): Boolean (source) Return * true if the counter 's count is zero * false if the counter 's count is non-zero",
      "title": "isIdle"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider/",
      "text": "dispatch-android-espresso / dispatch.android.espresso / IdlingDispatcherProvider IdlingDispatcherProvider class IdlingDispatcherProvider : DispatcherProvider (source) IdlingResource helper for coroutines. This DispatcherProvider implementation utilizes an IdlingDispatcher for each CoroutineDispatcher . See Also IdlingResource DispatcherProvider IdlingDispatcher CoroutineDispatcher Constructors Name Summary init IdlingResource helper for coroutines. This DispatcherProvider implementation utilizes an IdlingDispatcher for each CoroutineDispatcher . IdlingDispatcherProvider(default: IdlingDispatcher , io: IdlingDispatcher , main: IdlingDispatcher , mainImmediate: IdlingDispatcher , unconfined: IdlingDispatcher ) Properties Name Summary default IdlingDispatcher implementation of DispatcherProvider.default , which typically corresponds to the Dispatchers.Default . val default: IdlingDispatcher io IdlingDispatcher implementation of DispatcherProvider.io , which typically corresponds to the Dispatchers.IO . val io: IdlingDispatcher main IdlingDispatcher implementation of DispatcherProvider.main , which typically corresponds to the Dispatchers.Main . val main: IdlingDispatcher mainImmediate IdlingDispatcher implementation of DispatcherProvider.mainImmediate , which typically corresponds to the Dispatchers.Main.immediate CoroutineDispatcher . val mainImmediate: IdlingDispatcher unconfined IdlingDispatcher implementation of DispatcherProvider.unconfined , which typically corresponds to the Dispatchers.Unconfined . val unconfined: IdlingDispatcher Extension Functions Name Summary registerAllIdlingResources Register all IdlingDispatcher properties of the receiver IdlingDispatcherProvider with Espresso's IdlingRegistry . fun IdlingDispatcherProvider .registerAllIdlingResources(): Unit unregisterAllIdlingResources Unregister all IdlingDispatcher properties of the receiver IdlingDispatcherProvider with Espresso's IdlingRegistry . fun IdlingDispatcherProvider .unregisterAllIdlingResources(): Unit",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider/#idlingdispatcherprovider",
      "text": "class IdlingDispatcherProvider : DispatcherProvider (source) IdlingResource helper for coroutines. This DispatcherProvider implementation utilizes an IdlingDispatcher for each CoroutineDispatcher . See Also IdlingResource DispatcherProvider IdlingDispatcher CoroutineDispatcher",
      "title": "IdlingDispatcherProvider"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider/#constructors",
      "text": "Name Summary init IdlingResource helper for coroutines. This DispatcherProvider implementation utilizes an IdlingDispatcher for each CoroutineDispatcher . IdlingDispatcherProvider(default: IdlingDispatcher , io: IdlingDispatcher , main: IdlingDispatcher , mainImmediate: IdlingDispatcher , unconfined: IdlingDispatcher )",
      "title": "Constructors"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider/#properties",
      "text": "Name Summary default IdlingDispatcher implementation of DispatcherProvider.default , which typically corresponds to the Dispatchers.Default . val default: IdlingDispatcher io IdlingDispatcher implementation of DispatcherProvider.io , which typically corresponds to the Dispatchers.IO . val io: IdlingDispatcher main IdlingDispatcher implementation of DispatcherProvider.main , which typically corresponds to the Dispatchers.Main . val main: IdlingDispatcher mainImmediate IdlingDispatcher implementation of DispatcherProvider.mainImmediate , which typically corresponds to the Dispatchers.Main.immediate CoroutineDispatcher . val mainImmediate: IdlingDispatcher unconfined IdlingDispatcher implementation of DispatcherProvider.unconfined , which typically corresponds to the Dispatchers.Unconfined . val unconfined: IdlingDispatcher",
      "title": "Properties"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider/#extension-functions",
      "text": "Name Summary registerAllIdlingResources Register all IdlingDispatcher properties of the receiver IdlingDispatcherProvider with Espresso's IdlingRegistry . fun IdlingDispatcherProvider .registerAllIdlingResources(): Unit unregisterAllIdlingResources Unregister all IdlingDispatcher properties of the receiver IdlingDispatcherProvider with Espresso's IdlingRegistry . fun IdlingDispatcherProvider .unregisterAllIdlingResources(): Unit",
      "title": "Extension Functions"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider/-init-/",
      "text": "dispatch-android-espresso / dispatch.android.espresso / IdlingDispatcherProvider / init init IdlingDispatcherProvider(default: IdlingDispatcher , io: IdlingDispatcher , main: IdlingDispatcher , mainImmediate: IdlingDispatcher , unconfined: IdlingDispatcher ) IdlingResource helper for coroutines. This DispatcherProvider implementation utilizes an IdlingDispatcher for each CoroutineDispatcher . See Also IdlingResource DispatcherProvider IdlingDispatcher CoroutineDispatcher",
      "title": " init "
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider/-init-/#init",
      "text": "IdlingDispatcherProvider(default: IdlingDispatcher , io: IdlingDispatcher , main: IdlingDispatcher , mainImmediate: IdlingDispatcher , unconfined: IdlingDispatcher ) IdlingResource helper for coroutines. This DispatcherProvider implementation utilizes an IdlingDispatcher for each CoroutineDispatcher . See Also IdlingResource DispatcherProvider IdlingDispatcher CoroutineDispatcher",
      "title": "&lt;init&gt;"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider/default/",
      "text": "dispatch-android-espresso / dispatch.android.espresso / IdlingDispatcherProvider / default default val default: IdlingDispatcher (source) IdlingDispatcher implementation of DispatcherProvider.default , which typically corresponds to the Dispatchers.Default .",
      "title": "Default"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider/default/#default",
      "text": "val default: IdlingDispatcher (source) IdlingDispatcher implementation of DispatcherProvider.default , which typically corresponds to the Dispatchers.Default .",
      "title": "default"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider/io/",
      "text": "dispatch-android-espresso / dispatch.android.espresso / IdlingDispatcherProvider / io io val io: IdlingDispatcher (source) IdlingDispatcher implementation of DispatcherProvider.io , which typically corresponds to the Dispatchers.IO .",
      "title": "Io"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider/io/#io",
      "text": "val io: IdlingDispatcher (source) IdlingDispatcher implementation of DispatcherProvider.io , which typically corresponds to the Dispatchers.IO .",
      "title": "io"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider/main-immediate/",
      "text": "dispatch-android-espresso / dispatch.android.espresso / IdlingDispatcherProvider / mainImmediate mainImmediate val mainImmediate: IdlingDispatcher (source) IdlingDispatcher implementation of DispatcherProvider.mainImmediate , which typically corresponds to the Dispatchers.Main.immediate CoroutineDispatcher .",
      "title": "Main immediate"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider/main-immediate/#mainimmediate",
      "text": "val mainImmediate: IdlingDispatcher (source) IdlingDispatcher implementation of DispatcherProvider.mainImmediate , which typically corresponds to the Dispatchers.Main.immediate CoroutineDispatcher .",
      "title": "mainImmediate"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider/main/",
      "text": "dispatch-android-espresso / dispatch.android.espresso / IdlingDispatcherProvider / main main val main: IdlingDispatcher (source) IdlingDispatcher implementation of DispatcherProvider.main , which typically corresponds to the Dispatchers.Main .",
      "title": "Main"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider/main/#main",
      "text": "val main: IdlingDispatcher (source) IdlingDispatcher implementation of DispatcherProvider.main , which typically corresponds to the Dispatchers.Main .",
      "title": "main"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider/unconfined/",
      "text": "dispatch-android-espresso / dispatch.android.espresso / IdlingDispatcherProvider / unconfined unconfined val unconfined: IdlingDispatcher (source) IdlingDispatcher implementation of DispatcherProvider.unconfined , which typically corresponds to the Dispatchers.Unconfined .",
      "title": "Unconfined"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider/unconfined/#unconfined",
      "text": "val unconfined: IdlingDispatcher (source) IdlingDispatcher implementation of DispatcherProvider.unconfined , which typically corresponds to the Dispatchers.Unconfined .",
      "title": "unconfined"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider-rule/",
      "text": "dispatch-android-espresso / dispatch.android.espresso / IdlingDispatcherProviderRule IdlingDispatcherProviderRule class IdlingDispatcherProviderRule : TestWatcher (source) A JUnit 4 TestRule which creates a new IdlingDispatcherProvider for each test, registering all IdlingDispatcher s with IdlingRegistry before @Before and unregistering them after @After . The rule takes an optional IdlingDispatcherProvider factory, in which case it only handles registration. When doing Espresso testing, it's important that the same IdlingDispatcher s are used throughout a codebase. For this reason, it's a good idea to use a dependency injection framework just as Dagger or Koin to provide CoroutineScope s. If using the lifecycleScope and viewModelScope properties, be sure to use the versions from the dispatch-android-lifecycle artifacts to make use of their settable factories. Before the test: IdlingDispatcherProvider.registerAllIdlingResources is called to register all dispatchers with IdlingRegistry . After the test: IdlingDispatcherProvider.unregisterAllIdlingResources is called to unregister all dispatchers with IdlingRegistry . Requires JUnit 4. dependencies { testImplementation junit:junit:4.12 -- or -- testImplementation org.junit.vintage:junit-vintage-engine:5.5.1 } @RunWith(RobolectricTestRunner :: class ) class IdlingCoroutineScopeRuleSample { // Retrieve the DispatcherProvider from a dependency graph, // so that the same one is used throughout the codebase. val customDispatcherProvider = testAppComponent.customDispatcherProvider @JvmField @Rule val idlingRule = IdlingDispatcherProviderRule { IdlingDispatcherProvider(customDispatcherProvider) } @Test fun testThings () = runBlocking { // Now any CoroutineScope which uses the DispatcherProvider // in TestAppComponent will sync its idle state with Espresso } } @RunWith(RobolectricTestRunner :: class ) class IdlingCoroutineScopeRuleWithLifecycleSample { // Retrieve the DispatcherProvider from a dependency graph, // so that the same one is used throughout the codebase. val customDispatcherProvider = testAppComponent.customDispatcherProvider @JvmField @Rule val idlingRule = IdlingDispatcherProviderRule { IdlingDispatcherProvider(customDispatcherProvider) } @Before fun setUp () { LifecycleScopeFactory. set { MainImmediateCoroutineScope(customDispatcherProvider) } ViewModelScopeFactory. set { MainImmediateCoroutineScope(customDispatcherProvider) } // now all scopes use the same IdlingDispatcherProvider } @Test fun testThings () = runBlocking { // Now any CoroutineScope which uses the DispatcherProvider // in TestAppComponent will sync its idle state with Espresso } } Parameters factory - factory for a custom IdlingDispatcherProvider . This must be the same DispatcherProvider which is used to create CoroutineScope s in the code being tested. See Also TestRule IdlingRegistry Constructors Name Summary init A JUnit 4 TestRule which creates a new IdlingDispatcherProvider for each test, registering all IdlingDispatcher s with IdlingRegistry before @Before and unregistering them after @After . IdlingDispatcherProviderRule(factory: () - IdlingDispatcherProvider ) Properties Name Summary dispatcherProvider The IdlingDispatcherProvider which is automatically registered with IdlingRegistry . lateinit var dispatcherProvider: IdlingDispatcherProvider",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider-rule/#idlingdispatcherproviderrule",
      "text": "class IdlingDispatcherProviderRule : TestWatcher (source) A JUnit 4 TestRule which creates a new IdlingDispatcherProvider for each test, registering all IdlingDispatcher s with IdlingRegistry before @Before and unregistering them after @After . The rule takes an optional IdlingDispatcherProvider factory, in which case it only handles registration. When doing Espresso testing, it's important that the same IdlingDispatcher s are used throughout a codebase. For this reason, it's a good idea to use a dependency injection framework just as Dagger or Koin to provide CoroutineScope s. If using the lifecycleScope and viewModelScope properties, be sure to use the versions from the dispatch-android-lifecycle artifacts to make use of their settable factories.",
      "title": "IdlingDispatcherProviderRule"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider-rule/#before-the-test",
      "text": "IdlingDispatcherProvider.registerAllIdlingResources is called to register all dispatchers with IdlingRegistry .",
      "title": "Before the test:"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider-rule/#after-the-test",
      "text": "IdlingDispatcherProvider.unregisterAllIdlingResources is called to unregister all dispatchers with IdlingRegistry .",
      "title": "After the test:"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider-rule/#requires-junit-4",
      "text": "dependencies { testImplementation junit:junit:4.12 -- or -- testImplementation org.junit.vintage:junit-vintage-engine:5.5.1 } @RunWith(RobolectricTestRunner :: class ) class IdlingCoroutineScopeRuleSample { // Retrieve the DispatcherProvider from a dependency graph, // so that the same one is used throughout the codebase. val customDispatcherProvider = testAppComponent.customDispatcherProvider @JvmField @Rule val idlingRule = IdlingDispatcherProviderRule { IdlingDispatcherProvider(customDispatcherProvider) } @Test fun testThings () = runBlocking { // Now any CoroutineScope which uses the DispatcherProvider // in TestAppComponent will sync its idle state with Espresso } } @RunWith(RobolectricTestRunner :: class ) class IdlingCoroutineScopeRuleWithLifecycleSample { // Retrieve the DispatcherProvider from a dependency graph, // so that the same one is used throughout the codebase. val customDispatcherProvider = testAppComponent.customDispatcherProvider @JvmField @Rule val idlingRule = IdlingDispatcherProviderRule { IdlingDispatcherProvider(customDispatcherProvider) } @Before fun setUp () { LifecycleScopeFactory. set { MainImmediateCoroutineScope(customDispatcherProvider) } ViewModelScopeFactory. set { MainImmediateCoroutineScope(customDispatcherProvider) } // now all scopes use the same IdlingDispatcherProvider } @Test fun testThings () = runBlocking { // Now any CoroutineScope which uses the DispatcherProvider // in TestAppComponent will sync its idle state with Espresso } }",
      "title": "Requires JUnit 4."
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider-rule/#parameters",
      "text": "factory - factory for a custom IdlingDispatcherProvider . This must be the same DispatcherProvider which is used to create CoroutineScope s in the code being tested. See Also TestRule IdlingRegistry",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider-rule/#constructors",
      "text": "Name Summary init A JUnit 4 TestRule which creates a new IdlingDispatcherProvider for each test, registering all IdlingDispatcher s with IdlingRegistry before @Before and unregistering them after @After . IdlingDispatcherProviderRule(factory: () - IdlingDispatcherProvider )",
      "title": "Constructors"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider-rule/#properties",
      "text": "Name Summary dispatcherProvider The IdlingDispatcherProvider which is automatically registered with IdlingRegistry . lateinit var dispatcherProvider: IdlingDispatcherProvider",
      "title": "Properties"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider-rule/-init-/",
      "text": "dispatch-android-espresso / dispatch.android.espresso / IdlingDispatcherProviderRule / init init IdlingDispatcherProviderRule(factory: () - IdlingDispatcherProvider ) A JUnit 4 TestRule which creates a new IdlingDispatcherProvider for each test, registering all IdlingDispatcher s with IdlingRegistry before @Before and unregistering them after @After . The rule takes an optional IdlingDispatcherProvider factory, in which case it only handles registration. When doing Espresso testing, it's important that the same IdlingDispatcher s are used throughout a codebase. For this reason, it's a good idea to use a dependency injection framework just as Dagger or Koin to provide CoroutineScope s. If using the lifecycleScope and viewModelScope properties, be sure to use the versions from the dispatch-android-lifecycle artifacts to make use of their settable factories. Before the test: IdlingDispatcherProvider.registerAllIdlingResources is called to register all dispatchers with IdlingRegistry . After the test: IdlingDispatcherProvider.unregisterAllIdlingResources is called to unregister all dispatchers with IdlingRegistry . Requires JUnit 4. dependencies { testImplementation junit:junit:4.12 -- or -- testImplementation org.junit.vintage:junit-vintage-engine:5.5.1 } @RunWith(RobolectricTestRunner :: class ) class IdlingCoroutineScopeRuleSample { // Retrieve the DispatcherProvider from a dependency graph, // so that the same one is used throughout the codebase. val customDispatcherProvider = testAppComponent.customDispatcherProvider @JvmField @Rule val idlingRule = IdlingDispatcherProviderRule { IdlingDispatcherProvider(customDispatcherProvider) } @Test fun testThings () = runBlocking { // Now any CoroutineScope which uses the DispatcherProvider // in TestAppComponent will sync its idle state with Espresso } } @RunWith(RobolectricTestRunner :: class ) class IdlingCoroutineScopeRuleWithLifecycleSample { // Retrieve the DispatcherProvider from a dependency graph, // so that the same one is used throughout the codebase. val customDispatcherProvider = testAppComponent.customDispatcherProvider @JvmField @Rule val idlingRule = IdlingDispatcherProviderRule { IdlingDispatcherProvider(customDispatcherProvider) } @Before fun setUp () { LifecycleScopeFactory. set { MainImmediateCoroutineScope(customDispatcherProvider) } ViewModelScopeFactory. set { MainImmediateCoroutineScope(customDispatcherProvider) } // now all scopes use the same IdlingDispatcherProvider } @Test fun testThings () = runBlocking { // Now any CoroutineScope which uses the DispatcherProvider // in TestAppComponent will sync its idle state with Espresso } } Parameters factory - factory for a custom IdlingDispatcherProvider . This must be the same DispatcherProvider which is used to create CoroutineScope s in the code being tested. See Also TestRule IdlingRegistry",
      "title": " init "
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider-rule/-init-/#init",
      "text": "IdlingDispatcherProviderRule(factory: () - IdlingDispatcherProvider ) A JUnit 4 TestRule which creates a new IdlingDispatcherProvider for each test, registering all IdlingDispatcher s with IdlingRegistry before @Before and unregistering them after @After . The rule takes an optional IdlingDispatcherProvider factory, in which case it only handles registration. When doing Espresso testing, it's important that the same IdlingDispatcher s are used throughout a codebase. For this reason, it's a good idea to use a dependency injection framework just as Dagger or Koin to provide CoroutineScope s. If using the lifecycleScope and viewModelScope properties, be sure to use the versions from the dispatch-android-lifecycle artifacts to make use of their settable factories.",
      "title": "&lt;init&gt;"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider-rule/-init-/#before-the-test",
      "text": "IdlingDispatcherProvider.registerAllIdlingResources is called to register all dispatchers with IdlingRegistry .",
      "title": "Before the test:"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider-rule/-init-/#after-the-test",
      "text": "IdlingDispatcherProvider.unregisterAllIdlingResources is called to unregister all dispatchers with IdlingRegistry .",
      "title": "After the test:"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider-rule/-init-/#requires-junit-4",
      "text": "dependencies { testImplementation junit:junit:4.12 -- or -- testImplementation org.junit.vintage:junit-vintage-engine:5.5.1 } @RunWith(RobolectricTestRunner :: class ) class IdlingCoroutineScopeRuleSample { // Retrieve the DispatcherProvider from a dependency graph, // so that the same one is used throughout the codebase. val customDispatcherProvider = testAppComponent.customDispatcherProvider @JvmField @Rule val idlingRule = IdlingDispatcherProviderRule { IdlingDispatcherProvider(customDispatcherProvider) } @Test fun testThings () = runBlocking { // Now any CoroutineScope which uses the DispatcherProvider // in TestAppComponent will sync its idle state with Espresso } } @RunWith(RobolectricTestRunner :: class ) class IdlingCoroutineScopeRuleWithLifecycleSample { // Retrieve the DispatcherProvider from a dependency graph, // so that the same one is used throughout the codebase. val customDispatcherProvider = testAppComponent.customDispatcherProvider @JvmField @Rule val idlingRule = IdlingDispatcherProviderRule { IdlingDispatcherProvider(customDispatcherProvider) } @Before fun setUp () { LifecycleScopeFactory. set { MainImmediateCoroutineScope(customDispatcherProvider) } ViewModelScopeFactory. set { MainImmediateCoroutineScope(customDispatcherProvider) } // now all scopes use the same IdlingDispatcherProvider } @Test fun testThings () = runBlocking { // Now any CoroutineScope which uses the DispatcherProvider // in TestAppComponent will sync its idle state with Espresso } }",
      "title": "Requires JUnit 4."
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider-rule/-init-/#parameters",
      "text": "factory - factory for a custom IdlingDispatcherProvider . This must be the same DispatcherProvider which is used to create CoroutineScope s in the code being tested. See Also TestRule IdlingRegistry",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider-rule/dispatcher-provider/",
      "text": "dispatch-android-espresso / dispatch.android.espresso / IdlingDispatcherProviderRule / dispatcherProvider dispatcherProvider lateinit var dispatcherProvider: IdlingDispatcherProvider (source) The IdlingDispatcherProvider which is automatically registered with IdlingRegistry . This dispatcherProvider should be used in all other CoroutineScope s for the duration of the test.",
      "title": "Dispatcher provider"
    },
    {
      "location": "kdoc/dispatch-android-espresso/dispatch.android.espresso/-idling-dispatcher-provider-rule/dispatcher-provider/#dispatcherprovider",
      "text": "lateinit var dispatcherProvider: IdlingDispatcherProvider (source) The IdlingDispatcherProvider which is automatically registered with IdlingRegistry . This dispatcherProvider should be used in all other CoroutineScope s for the duration of the test.",
      "title": "dispatcherProvider"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/",
      "text": "dispatch-android-lifecycle Packages Name Summary dispatch.android.lifecycle Index All Types",
      "title": "android-lifecycle"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/#packages",
      "text": "Name Summary dispatch.android.lifecycle",
      "title": "Packages"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/#index",
      "text": "All Types",
      "title": "Index"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/alltypes/",
      "text": "All Types Name Summary (extensions in package dispatch.android.lifecycle) androidx.lifecycle.Lifecycle | dispatch.android.lifecycle.LifecycleCoroutineScope MainImmediateCoroutineScope instance which is tied to a Lifecycle . | (extensions in package dispatch.android.lifecycle) androidx.lifecycle.LifecycleOwner",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/alltypes/#all-types",
      "text": "Name Summary (extensions in package dispatch.android.lifecycle)",
      "title": "All Types"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/alltypes/#androidxlifecyclelifecycle",
      "text": "|",
      "title": "androidx.lifecycle.Lifecycle"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/alltypes/#dispatchandroidlifecyclelifecyclecoroutinescope",
      "text": "MainImmediateCoroutineScope instance which is tied to a Lifecycle . | (extensions in package dispatch.android.lifecycle)",
      "title": "dispatch.android.lifecycle.LifecycleCoroutineScope"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/alltypes/#androidxlifecyclelifecycleowner",
      "text": "",
      "title": "androidx.lifecycle.LifecycleOwner"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/",
      "text": "dispatch-android-lifecycle / dispatch.android.lifecycle Package dispatch.android.lifecycle Types Name Summary LifecycleCoroutineScope MainImmediateCoroutineScope instance which is tied to a Lifecycle . class LifecycleCoroutineScope : MainImmediateCoroutineScope Extensions for External Classes Name Summary androidx.lifecycle.Lifecycle androidx.lifecycle.LifecycleOwner",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/#package-dispatchandroidlifecycle",
      "text": "",
      "title": "Package dispatch.android.lifecycle"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/#types",
      "text": "Name Summary LifecycleCoroutineScope MainImmediateCoroutineScope instance which is tied to a Lifecycle . class LifecycleCoroutineScope : MainImmediateCoroutineScope",
      "title": "Types"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/#extensions-for-external-classes",
      "text": "Name Summary androidx.lifecycle.Lifecycle androidx.lifecycle.LifecycleOwner",
      "title": "Extensions for External Classes"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/-lifecycle-coroutine-scope/",
      "text": "dispatch-android-lifecycle / dispatch.android.lifecycle / LifecycleCoroutineScope LifecycleCoroutineScope class LifecycleCoroutineScope : MainImmediateCoroutineScope (source) MainImmediateCoroutineScope instance which is tied to a Lifecycle . The CoroutineScope provides lifecycle-aware launch functions which will automatically start upon reaching their associated Lifecycle.Event , then automatically cancel upon the lifecycle dropping below that state. Reaching that state again will start a new Job . runBlocking { // This could be any LifecycleOwner -- Fragments, Activities, Services... class SomeFragment : Fragment() { init { // auto-created MainImmediateCoroutineScope which is lifecycle-aware lifecycleScope //... // active only when resumed . starts a fresh coroutine each time // this is a rough proxy for LiveData behavior lifecycleScope.launchOnResume { } // active only when started . starts a fresh coroutine each time lifecycleScope.launchOnStart { } // launch when created, automatically stop on destroy lifecycleScope.launchOnCreate { } // it works as a normal CoroutineScope as well (because it is) lifecycleScope.launchMain { } } } } Parameters lifecycle - the lifecycle to which this MainImmediateCoroutineScope is linked. Types Name Summary MinimumStatePolicy Describes the way a particular Job will behave if the lifecycle passes below the minimum state before said Job has completed. enum class MinimumStatePolicy Constructors Name Summary init MainImmediateCoroutineScope instance which is tied to a Lifecycle . LifecycleCoroutineScope(lifecycle: Lifecycle , coroutineScope: MainImmediateCoroutineScope ) Properties Name Summary lifecycle the lifecycle to which this MainImmediateCoroutineScope is linked. val lifecycle: Lifecycle Functions Name Summary launchOnCreate Lifecycle-aware function for launching a coroutine any time the Lifecycle.State is at least Lifecycle.State.CREATED . fun launchOnCreate(minimumStatePolicy: MinimumStatePolicy = MinimumStatePolicy.RESTART_EVERY, block: suspend CoroutineScope .() - Unit ): Job launchOnResume Lifecycle-aware function for launching a coroutine any time the Lifecycle.State is at least Lifecycle.State.RESUMED . fun launchOnResume(minimumStatePolicy: MinimumStatePolicy = MinimumStatePolicy.RESTART_EVERY, block: suspend CoroutineScope .() - Unit ): Job launchOnStart Lifecycle-aware function for launching a coroutine any time the Lifecycle.State is at least Lifecycle.State.STARTED . fun launchOnStart(minimumStatePolicy: MinimumStatePolicy = MinimumStatePolicy.RESTART_EVERY, block: suspend CoroutineScope .() - Unit ): Job",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/-lifecycle-coroutine-scope/#lifecyclecoroutinescope",
      "text": "class LifecycleCoroutineScope : MainImmediateCoroutineScope (source) MainImmediateCoroutineScope instance which is tied to a Lifecycle . The CoroutineScope provides lifecycle-aware launch functions which will automatically start upon reaching their associated Lifecycle.Event , then automatically cancel upon the lifecycle dropping below that state. Reaching that state again will start a new Job . runBlocking { // This could be any LifecycleOwner -- Fragments, Activities, Services... class SomeFragment : Fragment() { init { // auto-created MainImmediateCoroutineScope which is lifecycle-aware lifecycleScope //... // active only when resumed . starts a fresh coroutine each time // this is a rough proxy for LiveData behavior lifecycleScope.launchOnResume { } // active only when started . starts a fresh coroutine each time lifecycleScope.launchOnStart { } // launch when created, automatically stop on destroy lifecycleScope.launchOnCreate { } // it works as a normal CoroutineScope as well (because it is) lifecycleScope.launchMain { } } } }",
      "title": "LifecycleCoroutineScope"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/-lifecycle-coroutine-scope/#parameters",
      "text": "lifecycle - the lifecycle to which this MainImmediateCoroutineScope is linked.",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/-lifecycle-coroutine-scope/#types",
      "text": "Name Summary MinimumStatePolicy Describes the way a particular Job will behave if the lifecycle passes below the minimum state before said Job has completed. enum class MinimumStatePolicy",
      "title": "Types"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/-lifecycle-coroutine-scope/#constructors",
      "text": "Name Summary init MainImmediateCoroutineScope instance which is tied to a Lifecycle . LifecycleCoroutineScope(lifecycle: Lifecycle , coroutineScope: MainImmediateCoroutineScope )",
      "title": "Constructors"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/-lifecycle-coroutine-scope/#properties",
      "text": "Name Summary lifecycle the lifecycle to which this MainImmediateCoroutineScope is linked. val lifecycle: Lifecycle",
      "title": "Properties"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/-lifecycle-coroutine-scope/#functions",
      "text": "Name Summary launchOnCreate Lifecycle-aware function for launching a coroutine any time the Lifecycle.State is at least Lifecycle.State.CREATED . fun launchOnCreate(minimumStatePolicy: MinimumStatePolicy = MinimumStatePolicy.RESTART_EVERY, block: suspend CoroutineScope .() - Unit ): Job launchOnResume Lifecycle-aware function for launching a coroutine any time the Lifecycle.State is at least Lifecycle.State.RESUMED . fun launchOnResume(minimumStatePolicy: MinimumStatePolicy = MinimumStatePolicy.RESTART_EVERY, block: suspend CoroutineScope .() - Unit ): Job launchOnStart Lifecycle-aware function for launching a coroutine any time the Lifecycle.State is at least Lifecycle.State.STARTED . fun launchOnStart(minimumStatePolicy: MinimumStatePolicy = MinimumStatePolicy.RESTART_EVERY, block: suspend CoroutineScope .() - Unit ): Job",
      "title": "Functions"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/-lifecycle-coroutine-scope/-init-/",
      "text": "dispatch-android-lifecycle / dispatch.android.lifecycle / LifecycleCoroutineScope / init init LifecycleCoroutineScope(lifecycle: Lifecycle , coroutineScope: MainImmediateCoroutineScope ) MainImmediateCoroutineScope instance which is tied to a Lifecycle . The CoroutineScope provides lifecycle-aware launch functions which will automatically start upon reaching their associated Lifecycle.Event , then automatically cancel upon the lifecycle dropping below that state. Reaching that state again will start a new Job . runBlocking { // This could be any LifecycleOwner -- Fragments, Activities, Services... class SomeFragment : Fragment() { init { // auto-created MainImmediateCoroutineScope which is lifecycle-aware lifecycleScope //... // active only when resumed . starts a fresh coroutine each time // this is a rough proxy for LiveData behavior lifecycleScope.launchOnResume { } // active only when started . starts a fresh coroutine each time lifecycleScope.launchOnStart { } // launch when created, automatically stop on destroy lifecycleScope.launchOnCreate { } // it works as a normal CoroutineScope as well (because it is) lifecycleScope.launchMain { } } } } Parameters lifecycle - the lifecycle to which this MainImmediateCoroutineScope is linked.",
      "title": " init "
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/-lifecycle-coroutine-scope/-init-/#init",
      "text": "LifecycleCoroutineScope(lifecycle: Lifecycle , coroutineScope: MainImmediateCoroutineScope ) MainImmediateCoroutineScope instance which is tied to a Lifecycle . The CoroutineScope provides lifecycle-aware launch functions which will automatically start upon reaching their associated Lifecycle.Event , then automatically cancel upon the lifecycle dropping below that state. Reaching that state again will start a new Job . runBlocking { // This could be any LifecycleOwner -- Fragments, Activities, Services... class SomeFragment : Fragment() { init { // auto-created MainImmediateCoroutineScope which is lifecycle-aware lifecycleScope //... // active only when resumed . starts a fresh coroutine each time // this is a rough proxy for LiveData behavior lifecycleScope.launchOnResume { } // active only when started . starts a fresh coroutine each time lifecycleScope.launchOnStart { } // launch when created, automatically stop on destroy lifecycleScope.launchOnCreate { } // it works as a normal CoroutineScope as well (because it is) lifecycleScope.launchMain { } } } }",
      "title": "&lt;init&gt;"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/-lifecycle-coroutine-scope/-init-/#parameters",
      "text": "lifecycle - the lifecycle to which this MainImmediateCoroutineScope is linked.",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/-lifecycle-coroutine-scope/launch-on-create/",
      "text": "dispatch-android-lifecycle / dispatch.android.lifecycle / LifecycleCoroutineScope / launchOnCreate launchOnCreate fun launchOnCreate(minimumStatePolicy: MinimumStatePolicy = MinimumStatePolicy.RESTART_EVERY, block: suspend CoroutineScope .() - Unit ): Job (source) Lifecycle-aware function for launching a coroutine any time the Lifecycle.State is at least Lifecycle.State.CREATED . block is executed using the receiver CoroutineScope 's Job as a parent, but always executes using Dispatchers.Main as its CoroutineDispatcher . Execution of block is cancelled when the receiver CoroutineScope is cancelled, or when lifecycle 's Lifecycle.State drops below Lifecycle.State.CREATED . runBlocking { val channel = Channel String () val history = mutableListOf String () class SomeViewModel { val someFlow = flow { repeat( 100 ) { emit(it) } } } class SomeFragment : Fragment() { val viewModel = SomeViewModel() init { lifecycleScope.launchOnCreate(minimumStatePolicy = CANCEL) { viewModel.someFlow.collect { channel.send( $it ) } } } } val fragment = SomeFragment() history.add( creating ) fragment.create() repeat( 3 ) { history.add(channel.receive()) } // destroying the lifecycle cancels the lifecycleScope history.add( destroying ) fragment.destroy() history shouldBe listOf( creating , 0 , 1 , 2 , destroying ) } runBlocking { val channel = Channel String () val history = mutableListOf String () class SomeViewModel { val someFlow = flow { repeat( 100 ) { emit(it) } } } class SomeFragment : Fragment() { val viewModel = SomeViewModel() init { lifecycleScope.launchOnCreate { viewModel.someFlow.collect { channel.send( $it ) } } } } val fragment = SomeFragment() history.add( creating ) fragment.create() repeat( 3 ) { history.add(channel.receive()) } // destroying the lifecycle cancels the lifecycleScope history.add( destroying ) fragment.destroy() history shouldBe listOf( creating , 0 , 1 , 2 , destroying ) } Parameters minimumStatePolicy - optional - the way this Job will behave when passing below the minimum state or re-entering. Uses MinimumStatePolicy.RESTART_EVERY by default. Note that for a normal Lifecycle, there is no returning from below a CREATED state, so the minimumStatePolicy is largely irrelevant.",
      "title": "Launch on create"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/-lifecycle-coroutine-scope/launch-on-create/#launchoncreate",
      "text": "fun launchOnCreate(minimumStatePolicy: MinimumStatePolicy = MinimumStatePolicy.RESTART_EVERY, block: suspend CoroutineScope .() - Unit ): Job (source) Lifecycle-aware function for launching a coroutine any time the Lifecycle.State is at least Lifecycle.State.CREATED . block is executed using the receiver CoroutineScope 's Job as a parent, but always executes using Dispatchers.Main as its CoroutineDispatcher . Execution of block is cancelled when the receiver CoroutineScope is cancelled, or when lifecycle 's Lifecycle.State drops below Lifecycle.State.CREATED . runBlocking { val channel = Channel String () val history = mutableListOf String () class SomeViewModel { val someFlow = flow { repeat( 100 ) { emit(it) } } } class SomeFragment : Fragment() { val viewModel = SomeViewModel() init { lifecycleScope.launchOnCreate(minimumStatePolicy = CANCEL) { viewModel.someFlow.collect { channel.send( $it ) } } } } val fragment = SomeFragment() history.add( creating ) fragment.create() repeat( 3 ) { history.add(channel.receive()) } // destroying the lifecycle cancels the lifecycleScope history.add( destroying ) fragment.destroy() history shouldBe listOf( creating , 0 , 1 , 2 , destroying ) } runBlocking { val channel = Channel String () val history = mutableListOf String () class SomeViewModel { val someFlow = flow { repeat( 100 ) { emit(it) } } } class SomeFragment : Fragment() { val viewModel = SomeViewModel() init { lifecycleScope.launchOnCreate { viewModel.someFlow.collect { channel.send( $it ) } } } } val fragment = SomeFragment() history.add( creating ) fragment.create() repeat( 3 ) { history.add(channel.receive()) } // destroying the lifecycle cancels the lifecycleScope history.add( destroying ) fragment.destroy() history shouldBe listOf( creating , 0 , 1 , 2 , destroying ) }",
      "title": "launchOnCreate"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/-lifecycle-coroutine-scope/launch-on-create/#parameters",
      "text": "minimumStatePolicy - optional - the way this Job will behave when passing below the minimum state or re-entering. Uses MinimumStatePolicy.RESTART_EVERY by default. Note that for a normal Lifecycle, there is no returning from below a CREATED state, so the minimumStatePolicy is largely irrelevant.",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/-lifecycle-coroutine-scope/launch-on-resume/",
      "text": "dispatch-android-lifecycle / dispatch.android.lifecycle / LifecycleCoroutineScope / launchOnResume launchOnResume fun launchOnResume(minimumStatePolicy: MinimumStatePolicy = MinimumStatePolicy.RESTART_EVERY, block: suspend CoroutineScope .() - Unit ): Job (source) Lifecycle-aware function for launching a coroutine any time the Lifecycle.State is at least Lifecycle.State.RESUMED . block is executed using the receiver CoroutineScope 's Job as a parent, but always executes using Dispatchers.Main as its CoroutineDispatcher . Execution of block is cancelled when the receiver CoroutineScope is cancelled, or when lifecycle 's Lifecycle.State drops below Lifecycle.State.RESUMED . runBlocking { val channel = Channel String () val history = mutableListOf String () class SomeViewModel { val someFlow = flow { repeat( 100 ) { emit(it) } } } class SomeFragment : Fragment() { val viewModel = SomeViewModel() init { lifecycleScope.launchOnResume(minimumStatePolicy = CANCEL) { viewModel.someFlow.collect { channel.send( $it ) } } } } val fragment = SomeFragment() history.add( resuming ) fragment.resume() repeat( 3 ) { history.add(channel.receive()) } // pausing the lifecycle cancels the existing Job history.add( pausing ) fragment.pause() // resuming the lifecycle does not create a new Job history shouldBe listOf( resuming , 0 , 1 , 2 , pausing ) } runBlocking { val channel = Channel String () val history = mutableListOf String () class SomeViewModel { val someFlow = flow { repeat( 100 ) { emit(it) } } } class SomeFragment : Fragment() { val viewModel = SomeViewModel() init { lifecycleScope.launchOnResume { viewModel.someFlow.collect { channel.send( $it ) } } } } val fragment = SomeFragment() history.add( resuming ) fragment.resume() repeat( 3 ) { history.add(channel.receive()) } // pausing the lifecycle cancels the existing Job history.add( pausing ) fragment.pause() // resuming the lifecycle creates a new Job history.add( resuming ) fragment.resume() repeat( 3 ) { history.add(channel.receive()) } history.add( pausing ) fragment.pause() history shouldBe listOf( resuming , 0 , 1 , 2 , pausing , resuming , 0 , 1 , 2 , pausing ) } Parameters minimumStatePolicy - optional - the way this Job will behave when passing below the minimum state or re-entering. Uses MinimumStatePolicy.RESTART_EVERY by default.",
      "title": "Launch on resume"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/-lifecycle-coroutine-scope/launch-on-resume/#launchonresume",
      "text": "fun launchOnResume(minimumStatePolicy: MinimumStatePolicy = MinimumStatePolicy.RESTART_EVERY, block: suspend CoroutineScope .() - Unit ): Job (source) Lifecycle-aware function for launching a coroutine any time the Lifecycle.State is at least Lifecycle.State.RESUMED . block is executed using the receiver CoroutineScope 's Job as a parent, but always executes using Dispatchers.Main as its CoroutineDispatcher . Execution of block is cancelled when the receiver CoroutineScope is cancelled, or when lifecycle 's Lifecycle.State drops below Lifecycle.State.RESUMED . runBlocking { val channel = Channel String () val history = mutableListOf String () class SomeViewModel { val someFlow = flow { repeat( 100 ) { emit(it) } } } class SomeFragment : Fragment() { val viewModel = SomeViewModel() init { lifecycleScope.launchOnResume(minimumStatePolicy = CANCEL) { viewModel.someFlow.collect { channel.send( $it ) } } } } val fragment = SomeFragment() history.add( resuming ) fragment.resume() repeat( 3 ) { history.add(channel.receive()) } // pausing the lifecycle cancels the existing Job history.add( pausing ) fragment.pause() // resuming the lifecycle does not create a new Job history shouldBe listOf( resuming , 0 , 1 , 2 , pausing ) } runBlocking { val channel = Channel String () val history = mutableListOf String () class SomeViewModel { val someFlow = flow { repeat( 100 ) { emit(it) } } } class SomeFragment : Fragment() { val viewModel = SomeViewModel() init { lifecycleScope.launchOnResume { viewModel.someFlow.collect { channel.send( $it ) } } } } val fragment = SomeFragment() history.add( resuming ) fragment.resume() repeat( 3 ) { history.add(channel.receive()) } // pausing the lifecycle cancels the existing Job history.add( pausing ) fragment.pause() // resuming the lifecycle creates a new Job history.add( resuming ) fragment.resume() repeat( 3 ) { history.add(channel.receive()) } history.add( pausing ) fragment.pause() history shouldBe listOf( resuming , 0 , 1 , 2 , pausing , resuming , 0 , 1 , 2 , pausing ) }",
      "title": "launchOnResume"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/-lifecycle-coroutine-scope/launch-on-resume/#parameters",
      "text": "minimumStatePolicy - optional - the way this Job will behave when passing below the minimum state or re-entering. Uses MinimumStatePolicy.RESTART_EVERY by default.",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/-lifecycle-coroutine-scope/launch-on-start/",
      "text": "dispatch-android-lifecycle / dispatch.android.lifecycle / LifecycleCoroutineScope / launchOnStart launchOnStart fun launchOnStart(minimumStatePolicy: MinimumStatePolicy = MinimumStatePolicy.RESTART_EVERY, block: suspend CoroutineScope .() - Unit ): Job (source) Lifecycle-aware function for launching a coroutine any time the Lifecycle.State is at least Lifecycle.State.STARTED . block is executed using the receiver CoroutineScope 's Job as a parent, but always executes using Dispatchers.Main as its CoroutineDispatcher . Execution of block is cancelled when the receiver CoroutineScope is cancelled, or when lifecycle 's Lifecycle.State drops below Lifecycle.State.STARTED . runBlocking { val channel = Channel String () val history = mutableListOf String () class SomeViewModel { val someFlow = flow { repeat( 100 ) { emit(it) } } } class SomeFragment : Fragment() { val viewModel = SomeViewModel() init { lifecycleScope.launchOnStart(minimumStatePolicy = CANCEL) { viewModel.someFlow.collect { channel.send( $it ) } } } } val fragment = SomeFragment() history.add( starting ) fragment.start() repeat( 3 ) { history.add(channel.receive()) } // stopping the lifecycle cancels the existing Job history.add( stopping ) fragment.stop() // starting the lifecycle does not create a new Job history shouldBe listOf( starting , 0 , 1 , 2 , stopping ) } runBlocking { val channel = Channel String () val history = mutableListOf String () class SomeViewModel { val someFlow = flow { repeat( 100 ) { emit(it) } } } class SomeFragment : Fragment() { val viewModel = SomeViewModel() init { lifecycleScope.launchOnStart { viewModel.someFlow.collect { channel.send( $it ) } } } } val fragment = SomeFragment() history.add( starting ) fragment.start() repeat( 3 ) { history.add(channel.receive()) } // stopping the lifecycle cancels the existing Job history.add( stopping ) fragment.stop() // starting the lifecycle creates a new Job history.add( starting ) fragment.start() repeat( 3 ) { history.add(channel.receive()) } history.add( stopping ) fragment.stop() history shouldBe listOf( starting , 0 , 1 , 2 , stopping , starting , 0 , 1 , 2 , stopping ) } Parameters minimumStatePolicy - optional - the way this Job will behave when passing below the minimum state or re-entering. Uses MinimumStatePolicy.RESTART_EVERY by default.",
      "title": "Launch on start"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/-lifecycle-coroutine-scope/launch-on-start/#launchonstart",
      "text": "fun launchOnStart(minimumStatePolicy: MinimumStatePolicy = MinimumStatePolicy.RESTART_EVERY, block: suspend CoroutineScope .() - Unit ): Job (source) Lifecycle-aware function for launching a coroutine any time the Lifecycle.State is at least Lifecycle.State.STARTED . block is executed using the receiver CoroutineScope 's Job as a parent, but always executes using Dispatchers.Main as its CoroutineDispatcher . Execution of block is cancelled when the receiver CoroutineScope is cancelled, or when lifecycle 's Lifecycle.State drops below Lifecycle.State.STARTED . runBlocking { val channel = Channel String () val history = mutableListOf String () class SomeViewModel { val someFlow = flow { repeat( 100 ) { emit(it) } } } class SomeFragment : Fragment() { val viewModel = SomeViewModel() init { lifecycleScope.launchOnStart(minimumStatePolicy = CANCEL) { viewModel.someFlow.collect { channel.send( $it ) } } } } val fragment = SomeFragment() history.add( starting ) fragment.start() repeat( 3 ) { history.add(channel.receive()) } // stopping the lifecycle cancels the existing Job history.add( stopping ) fragment.stop() // starting the lifecycle does not create a new Job history shouldBe listOf( starting , 0 , 1 , 2 , stopping ) } runBlocking { val channel = Channel String () val history = mutableListOf String () class SomeViewModel { val someFlow = flow { repeat( 100 ) { emit(it) } } } class SomeFragment : Fragment() { val viewModel = SomeViewModel() init { lifecycleScope.launchOnStart { viewModel.someFlow.collect { channel.send( $it ) } } } } val fragment = SomeFragment() history.add( starting ) fragment.start() repeat( 3 ) { history.add(channel.receive()) } // stopping the lifecycle cancels the existing Job history.add( stopping ) fragment.stop() // starting the lifecycle creates a new Job history.add( starting ) fragment.start() repeat( 3 ) { history.add(channel.receive()) } history.add( stopping ) fragment.stop() history shouldBe listOf( starting , 0 , 1 , 2 , stopping , starting , 0 , 1 , 2 , stopping ) }",
      "title": "launchOnStart"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/-lifecycle-coroutine-scope/launch-on-start/#parameters",
      "text": "minimumStatePolicy - optional - the way this Job will behave when passing below the minimum state or re-entering. Uses MinimumStatePolicy.RESTART_EVERY by default.",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/-lifecycle-coroutine-scope/lifecycle/",
      "text": "dispatch-android-lifecycle / dispatch.android.lifecycle / LifecycleCoroutineScope / lifecycle lifecycle val lifecycle: Lifecycle (source) the lifecycle to which this MainImmediateCoroutineScope is linked.",
      "title": "Lifecycle"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/-lifecycle-coroutine-scope/lifecycle/#lifecycle",
      "text": "val lifecycle: Lifecycle (source) the lifecycle to which this MainImmediateCoroutineScope is linked.",
      "title": "lifecycle"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/-lifecycle-coroutine-scope/-minimum-state-policy/",
      "text": "dispatch-android-lifecycle / dispatch.android.lifecycle / LifecycleCoroutineScope / MinimumStatePolicy MinimumStatePolicy enum class MinimumStatePolicy (source) Describes the way a particular Job will behave if the lifecycle passes below the minimum state before said Job has completed. Enum Values Name Summary CANCEL When using CANCEL , a coroutine will be created the first time the lifecycle meets the minimum state, and cancelled upon dropping below it. Subsequently meeting the minimum state again will not resume the coroutine or create a new one. RESTART_EVERY When using RESTART_EVERY , a coroutine will be created every time the lifecycle meets the minimum state, and will be cancelled upon dropping below it. Subsequently meeting the minimum state again will create a new coroutine.",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/-lifecycle-coroutine-scope/-minimum-state-policy/#minimumstatepolicy",
      "text": "enum class MinimumStatePolicy (source) Describes the way a particular Job will behave if the lifecycle passes below the minimum state before said Job has completed.",
      "title": "MinimumStatePolicy"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/-lifecycle-coroutine-scope/-minimum-state-policy/#enum-values",
      "text": "Name Summary CANCEL When using CANCEL , a coroutine will be created the first time the lifecycle meets the minimum state, and cancelled upon dropping below it. Subsequently meeting the minimum state again will not resume the coroutine or create a new one. RESTART_EVERY When using RESTART_EVERY , a coroutine will be created every time the lifecycle meets the minimum state, and will be cancelled upon dropping below it. Subsequently meeting the minimum state again will create a new coroutine.",
      "title": "Enum Values"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/-lifecycle-coroutine-scope/-minimum-state-policy/-c-a-n-c-e-l/",
      "text": "dispatch-android-lifecycle / dispatch.android.lifecycle / LifecycleCoroutineScope / MinimumStatePolicy / CANCEL CANCEL CANCEL (source) When using CANCEL , a coroutine will be created the first time the lifecycle meets the minimum state, and cancelled upon dropping below it. Subsequently meeting the minimum state again will not resume the coroutine or create a new one. See Also launchOnCreate launchOnStart launchOnResume",
      "title": " c a n c e l"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/-lifecycle-coroutine-scope/-minimum-state-policy/-c-a-n-c-e-l/#cancel",
      "text": "CANCEL (source) When using CANCEL , a coroutine will be created the first time the lifecycle meets the minimum state, and cancelled upon dropping below it. Subsequently meeting the minimum state again will not resume the coroutine or create a new one. See Also launchOnCreate launchOnStart launchOnResume",
      "title": "CANCEL"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/-lifecycle-coroutine-scope/-minimum-state-policy/-r-e-s-t-a-r-t_-e-v-e-r-y/",
      "text": "dispatch-android-lifecycle / dispatch.android.lifecycle / LifecycleCoroutineScope / MinimumStatePolicy / RESTART_EVERY RESTART_EVERY RESTART_EVERY (source) When using RESTART_EVERY , a coroutine will be created every time the lifecycle meets the minimum state, and will be cancelled upon dropping below it. Subsequently meeting the minimum state again will create a new coroutine. Note that state is not retained when dropping below a minimum state. See Also launchOnCreate launchOnStart launchOnResume",
      "title": " r e s t a r t  e v e r y"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/-lifecycle-coroutine-scope/-minimum-state-policy/-r-e-s-t-a-r-t_-e-v-e-r-y/#restart_every",
      "text": "RESTART_EVERY (source) When using RESTART_EVERY , a coroutine will be created every time the lifecycle meets the minimum state, and will be cancelled upon dropping below it. Subsequently meeting the minimum state again will create a new coroutine. Note that state is not retained when dropping below a minimum state. See Also launchOnCreate launchOnStart launchOnResume",
      "title": "RESTART_EVERY"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/androidx.lifecycle.-lifecycle/",
      "text": "dispatch-android-lifecycle / dispatch.android.lifecycle / androidx.lifecycle.Lifecycle Extensions for androidx.lifecycle.Lifecycle Name Summary onNextCreate Executes block one time, the next time the Lifecycle 's state is at least Lifecycle.State.CREATED . suspend fun T Lifecycle .onNextCreate(block: suspend CoroutineScope .() - T): T? onNextResume Executes block one time, the next time the Lifecycle 's state is at least Lifecycle.State.RESUMED . suspend fun T Lifecycle .onNextResume(block: suspend CoroutineScope .() - T): T? onNextStart Executes block one time, the next time the Lifecycle 's state is at least Lifecycle.State.STARTED . suspend fun T Lifecycle .onNextStart(block: suspend CoroutineScope .() - T): T?",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/androidx.lifecycle.-lifecycle/#extensions-for-androidxlifecyclelifecycle",
      "text": "Name Summary onNextCreate Executes block one time, the next time the Lifecycle 's state is at least Lifecycle.State.CREATED . suspend fun T Lifecycle .onNextCreate(block: suspend CoroutineScope .() - T): T? onNextResume Executes block one time, the next time the Lifecycle 's state is at least Lifecycle.State.RESUMED . suspend fun T Lifecycle .onNextResume(block: suspend CoroutineScope .() - T): T? onNextStart Executes block one time, the next time the Lifecycle 's state is at least Lifecycle.State.STARTED . suspend fun T Lifecycle .onNextStart(block: suspend CoroutineScope .() - T): T?",
      "title": "Extensions for androidx.lifecycle.Lifecycle"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/androidx.lifecycle.-lifecycle/on-next-create/",
      "text": "dispatch-android-lifecycle / dispatch.android.lifecycle / androidx.lifecycle.Lifecycle / onNextCreate onNextCreate suspend fun T Lifecycle .onNextCreate(block: suspend CoroutineScope .() - T): T? (source) Executes block one time, the next time the Lifecycle 's state is at least Lifecycle.State.CREATED . If the lifecycle is already in this state, block will be executed immediately. runBlocking { class SomeFragment : Fragment() { var invocations = 0 init { lifecycleScope.launchMainImmediate { lifecycle.onNextCreate { invocations++ } } } } // current lifecycle state is INITIALIZED val fragment = SomeFragment() // nothing is invoked yet fragment.invocations shouldBe 0 fragment.create() fragment.invocations shouldBe 1 } See Also LifecycleCoroutineScope.launchOnCreate",
      "title": "On next create"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/androidx.lifecycle.-lifecycle/on-next-create/#onnextcreate",
      "text": "suspend fun T Lifecycle .onNextCreate(block: suspend CoroutineScope .() - T): T? (source) Executes block one time, the next time the Lifecycle 's state is at least Lifecycle.State.CREATED . If the lifecycle is already in this state, block will be executed immediately. runBlocking { class SomeFragment : Fragment() { var invocations = 0 init { lifecycleScope.launchMainImmediate { lifecycle.onNextCreate { invocations++ } } } } // current lifecycle state is INITIALIZED val fragment = SomeFragment() // nothing is invoked yet fragment.invocations shouldBe 0 fragment.create() fragment.invocations shouldBe 1 } See Also LifecycleCoroutineScope.launchOnCreate",
      "title": "onNextCreate"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/androidx.lifecycle.-lifecycle/on-next-resume/",
      "text": "dispatch-android-lifecycle / dispatch.android.lifecycle / androidx.lifecycle.Lifecycle / onNextResume onNextResume suspend fun T Lifecycle .onNextResume(block: suspend CoroutineScope .() - T): T? (source) Executes block one time, the next time the Lifecycle 's state is at least Lifecycle.State.RESUMED . If the lifecycle is already in this state, block will be executed immediately. runBlocking { class SomeFragment : Fragment() { var invocations = 0 init { lifecycleScope.launchMainImmediate { lifecycle.onNextResume { invocations++ } } } } // current lifecycle state is INITIALIZED val fragment = SomeFragment() // nothing is invoked yet fragment.invocations shouldBe 0 fragment.resume() fragment.invocations shouldBe 1 // crossing the threshold doesn t invoke the lambda again fragment.pause() fragment.resume() fragment.invocations shouldBe 1 } See Also LifecycleCoroutineScope.launchOnResume",
      "title": "On next resume"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/androidx.lifecycle.-lifecycle/on-next-resume/#onnextresume",
      "text": "suspend fun T Lifecycle .onNextResume(block: suspend CoroutineScope .() - T): T? (source) Executes block one time, the next time the Lifecycle 's state is at least Lifecycle.State.RESUMED . If the lifecycle is already in this state, block will be executed immediately. runBlocking { class SomeFragment : Fragment() { var invocations = 0 init { lifecycleScope.launchMainImmediate { lifecycle.onNextResume { invocations++ } } } } // current lifecycle state is INITIALIZED val fragment = SomeFragment() // nothing is invoked yet fragment.invocations shouldBe 0 fragment.resume() fragment.invocations shouldBe 1 // crossing the threshold doesn t invoke the lambda again fragment.pause() fragment.resume() fragment.invocations shouldBe 1 } See Also LifecycleCoroutineScope.launchOnResume",
      "title": "onNextResume"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/androidx.lifecycle.-lifecycle/on-next-start/",
      "text": "dispatch-android-lifecycle / dispatch.android.lifecycle / androidx.lifecycle.Lifecycle / onNextStart onNextStart suspend fun T Lifecycle .onNextStart(block: suspend CoroutineScope .() - T): T? (source) Executes block one time, the next time the Lifecycle 's state is at least Lifecycle.State.STARTED . If the lifecycle is already in this state, block will be executed immediately. runBlocking { class SomeFragment : Fragment() { var invocations = 0 init { lifecycleScope.launchMainImmediate { lifecycle.onNextStart { invocations++ } } } } // current lifecycle state is INITIALIZED val fragment = SomeFragment() // nothing is invoked yet fragment.invocations shouldBe 0 fragment.start() fragment.invocations shouldBe 1 // crossing the threshold doesn t invoke the lambda again fragment.stop() fragment.start() fragment.invocations shouldBe 1 } See Also LifecycleCoroutineScope.launchOnStart",
      "title": "On next start"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/androidx.lifecycle.-lifecycle/on-next-start/#onnextstart",
      "text": "suspend fun T Lifecycle .onNextStart(block: suspend CoroutineScope .() - T): T? (source) Executes block one time, the next time the Lifecycle 's state is at least Lifecycle.State.STARTED . If the lifecycle is already in this state, block will be executed immediately. runBlocking { class SomeFragment : Fragment() { var invocations = 0 init { lifecycleScope.launchMainImmediate { lifecycle.onNextStart { invocations++ } } } } // current lifecycle state is INITIALIZED val fragment = SomeFragment() // nothing is invoked yet fragment.invocations shouldBe 0 fragment.start() fragment.invocations shouldBe 1 // crossing the threshold doesn t invoke the lambda again fragment.stop() fragment.start() fragment.invocations shouldBe 1 } See Also LifecycleCoroutineScope.launchOnStart",
      "title": "onNextStart"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/androidx.lifecycle.-lifecycle-owner/",
      "text": "dispatch-android-lifecycle / dispatch.android.lifecycle / androidx.lifecycle.LifecycleOwner Extensions for androidx.lifecycle.LifecycleOwner Name Summary onNextCreate Executes block one time, the next time the Lifecycle 's state is at least Lifecycle.State.CREATED . suspend fun T LifecycleOwner .onNextCreate(block: suspend CoroutineScope .() - T): T? onNextResume Executes block one time, the next time the Lifecycle 's state is at least Lifecycle.State.RESUMED . suspend fun T LifecycleOwner .onNextResume(block: suspend CoroutineScope .() - T): T? onNextStart Executes block one time, the next time the Lifecycle 's state is at least Lifecycle.State.STARTED . suspend fun T LifecycleOwner .onNextStart(block: suspend CoroutineScope .() - T): T?",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/androidx.lifecycle.-lifecycle-owner/#extensions-for-androidxlifecyclelifecycleowner",
      "text": "Name Summary onNextCreate Executes block one time, the next time the Lifecycle 's state is at least Lifecycle.State.CREATED . suspend fun T LifecycleOwner .onNextCreate(block: suspend CoroutineScope .() - T): T? onNextResume Executes block one time, the next time the Lifecycle 's state is at least Lifecycle.State.RESUMED . suspend fun T LifecycleOwner .onNextResume(block: suspend CoroutineScope .() - T): T? onNextStart Executes block one time, the next time the Lifecycle 's state is at least Lifecycle.State.STARTED . suspend fun T LifecycleOwner .onNextStart(block: suspend CoroutineScope .() - T): T?",
      "title": "Extensions for androidx.lifecycle.LifecycleOwner"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/androidx.lifecycle.-lifecycle-owner/on-next-create/",
      "text": "dispatch-android-lifecycle / dispatch.android.lifecycle / androidx.lifecycle.LifecycleOwner / onNextCreate onNextCreate suspend fun T LifecycleOwner .onNextCreate(block: suspend CoroutineScope .() - T): T? (source) Executes block one time, the next time the Lifecycle 's state is at least Lifecycle.State.CREATED . If the lifecycle is already in this state, block will be executed immediately. runBlocking { class SomeFragment : Fragment() { var invocations = 0 init { lifecycleScope.launchMainImmediate { onNextCreate { invocations++ } } } } // current view lifecycle state is INITIALIZED val fragment = SomeFragment() // nothing is invoked yet fragment.invocations shouldBe 0 fragment.create() fragment.invocations shouldBe 1 } See Also LifecycleCoroutineScope.launchOnCreate",
      "title": "On next create"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/androidx.lifecycle.-lifecycle-owner/on-next-create/#onnextcreate",
      "text": "suspend fun T LifecycleOwner .onNextCreate(block: suspend CoroutineScope .() - T): T? (source) Executes block one time, the next time the Lifecycle 's state is at least Lifecycle.State.CREATED . If the lifecycle is already in this state, block will be executed immediately. runBlocking { class SomeFragment : Fragment() { var invocations = 0 init { lifecycleScope.launchMainImmediate { onNextCreate { invocations++ } } } } // current view lifecycle state is INITIALIZED val fragment = SomeFragment() // nothing is invoked yet fragment.invocations shouldBe 0 fragment.create() fragment.invocations shouldBe 1 } See Also LifecycleCoroutineScope.launchOnCreate",
      "title": "onNextCreate"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/androidx.lifecycle.-lifecycle-owner/on-next-resume/",
      "text": "dispatch-android-lifecycle / dispatch.android.lifecycle / androidx.lifecycle.LifecycleOwner / onNextResume onNextResume suspend fun T LifecycleOwner .onNextResume(block: suspend CoroutineScope .() - T): T? (source) Executes block one time, the next time the Lifecycle 's state is at least Lifecycle.State.RESUMED . If the lifecycle is already in this state, block will be executed immediately. runBlocking { class SomeFragment : Fragment() { var invocations = 0 init { lifecycleScope.launchMainImmediate { onNextResume { invocations++ } } } } // current view lifecycle state is INITIALIZED val fragment = SomeFragment() // nothing is invoked yet fragment.invocations shouldBe 0 fragment.resume() fragment.invocations shouldBe 1 // crossing the threshold doesn t invoke the lambda again fragment.pause() fragment.resume() fragment.invocations shouldBe 1 } See Also LifecycleCoroutineScope.launchOnResume",
      "title": "On next resume"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/androidx.lifecycle.-lifecycle-owner/on-next-resume/#onnextresume",
      "text": "suspend fun T LifecycleOwner .onNextResume(block: suspend CoroutineScope .() - T): T? (source) Executes block one time, the next time the Lifecycle 's state is at least Lifecycle.State.RESUMED . If the lifecycle is already in this state, block will be executed immediately. runBlocking { class SomeFragment : Fragment() { var invocations = 0 init { lifecycleScope.launchMainImmediate { onNextResume { invocations++ } } } } // current view lifecycle state is INITIALIZED val fragment = SomeFragment() // nothing is invoked yet fragment.invocations shouldBe 0 fragment.resume() fragment.invocations shouldBe 1 // crossing the threshold doesn t invoke the lambda again fragment.pause() fragment.resume() fragment.invocations shouldBe 1 } See Also LifecycleCoroutineScope.launchOnResume",
      "title": "onNextResume"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/androidx.lifecycle.-lifecycle-owner/on-next-start/",
      "text": "dispatch-android-lifecycle / dispatch.android.lifecycle / androidx.lifecycle.LifecycleOwner / onNextStart onNextStart suspend fun T LifecycleOwner .onNextStart(block: suspend CoroutineScope .() - T): T? (source) Executes block one time, the next time the Lifecycle 's state is at least Lifecycle.State.STARTED . If the lifecycle is already in this state, block will be executed immediately. runBlocking { class SomeFragment : Fragment() { var invocations = 0 init { lifecycleScope.launchMainImmediate { onNextStart { invocations++ } } } } // current view lifecycle state is INITIALIZED val fragment = SomeFragment() // nothing is invoked yet fragment.invocations shouldBe 0 fragment.start() fragment.invocations shouldBe 1 // crossing the threshold doesn t invoke the lambda again fragment.stop() fragment.start() fragment.invocations shouldBe 1 } See Also LifecycleCoroutineScope.launchOnStart",
      "title": "On next start"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle/dispatch.android.lifecycle/androidx.lifecycle.-lifecycle-owner/on-next-start/#onnextstart",
      "text": "suspend fun T LifecycleOwner .onNextStart(block: suspend CoroutineScope .() - T): T? (source) Executes block one time, the next time the Lifecycle 's state is at least Lifecycle.State.STARTED . If the lifecycle is already in this state, block will be executed immediately. runBlocking { class SomeFragment : Fragment() { var invocations = 0 init { lifecycleScope.launchMainImmediate { onNextStart { invocations++ } } } } // current view lifecycle state is INITIALIZED val fragment = SomeFragment() // nothing is invoked yet fragment.invocations shouldBe 0 fragment.start() fragment.invocations shouldBe 1 // crossing the threshold doesn t invoke the lambda again fragment.stop() fragment.start() fragment.invocations shouldBe 1 } See Also LifecycleCoroutineScope.launchOnStart",
      "title": "onNextStart"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle-extensions/",
      "text": "dispatch-android-lifecycle-extensions Contents Api One-time suspend functions Difference from AndroidX Custom CoroutineScope factories Automatic lifecycle jobs Minimum Gradle Config Api One-time suspend functions Examples import dispatch.android.* // This could be any LifecycleOwner -- Fragments, Activities, Services... class SomeScreen : Fragment() { init { // auto-created MainImmediateCoroutineScope which is lifecycle-aware lifecycleScope //... // active only when resumed . starts a fresh coroutine each time // this is a rough proxy for LiveData behavior lifecycleScope.launchEveryResume { } // active only when started . starts a fresh coroutine each time lifecycleScope.launchEveryStart { } // launch when created, automatically stop on destroy lifecycleScope.launchEveryCreate { } // it works as a normal CoroutineScope as well (because it is) lifecycleScope.launchMain { } } } class SomeApplication : Application() { override fun onCreate () { super .onCreate() // A custom factory can be set to add elements to the CoroutineContext LifecycleScopeFactory. set { MainImmediateCoroutineScope() + SomeCustomElement() } } } class SomeEspressoTest { @Before fun setUp () { // This custom factory can be used to use custom scopes for testing, // such as an idling dispatcher LifecycleScopeFactory. set { MainImmediateIdlingCoroutineScope() } } @After fun tearDown () { // The factory can also be reset to default LifecycleScopeFactory.reset() } } Difference from AndroidX This module is really just a slightly different version of androidx-lifecycle-runtime-ktx \u2014 the library which gives us the lifecycleScope property. Why not just use AndroidX? Because we need two things it doesn't offer. Custom CoroutineScope factories The way androidx-lifecycle-runtime constructs its CoroutineScope is hard-coded , which eliminates the possibility of using a custom CoroutineContext such as a DispatcherProvider or IdlingDispatcher . With dispatch.android.lifecycle , we can set a custom factory. class SomeFragmentEspressoTest { // Not part of this artifact. see dispatch-android-espresso @JvmField @Rule val idlingRule = IdlingDispatcherProviderRule() @Before fun setUp () { // set a custom factory which is applied to all newly created lifecycleScopes LifecycleScopeFactory. set { MainImmediateCoroutineScope() + idlingRule.dispatcherProvider } // now SomeFragment will use an IdlingDispatcher in its CoroutineScope } } Automatic lifecycle jobs Structured concurrency relies upon cancellation, but androidx-lifecycle-runtime.ktx doesn't cancel. It uses a special PausingDispatcher . This pausing behavior then leaks upstream, creating backpressure and potentially deadlocks. There's a bug filed in their issue tracker , but 2.2.0 got released anyway. This library's API surface is the same as that within the AndroidX version, but has a different strategy for handling lifecycle events. When a lifecycle state enters the desired range, such as at ON_RESUME , a new coroutine is created. When the state exists the range, that coroutine is cancelled . If the lifecycle state enters the desired range again, a new coroutine is created. import dispatch.android.* class SomeFragment : Fragment() { val viewModel: SomeViewModel by viewModels() init { // automatically created CoroutineScope using the factory described above lifecycleScope.launchWhenResumed { viewModel.someFlow.consume { } } } } This has the desired effect of not leaking backpressure upstream (which in this example is the viewModel ). Minimum Gradle Config Add to your module's build.gradle.kts : repositories { mavenCentral() } dependencies { implementation( org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.7 ) implementation( org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.7 ) implementation( com.rickbusarow.dispatch:dispatch-android-lifecycle-extensions:1.0.0-beta03 ) implementation( androidx.lifecycle:lifecycle-common:2.2.0 ) } Packages Name Summary dispatch.android.lifecycle Index All Types",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle-extensions/#contents",
      "text": "Api One-time suspend functions Difference from AndroidX Custom CoroutineScope factories Automatic lifecycle jobs Minimum Gradle Config",
      "title": "Contents"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle-extensions/#api",
      "text": "",
      "title": "Api"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle-extensions/#one-time-suspend-functions",
      "text": "Examples import dispatch.android.* // This could be any LifecycleOwner -- Fragments, Activities, Services... class SomeScreen : Fragment() { init { // auto-created MainImmediateCoroutineScope which is lifecycle-aware lifecycleScope //... // active only when resumed . starts a fresh coroutine each time // this is a rough proxy for LiveData behavior lifecycleScope.launchEveryResume { } // active only when started . starts a fresh coroutine each time lifecycleScope.launchEveryStart { } // launch when created, automatically stop on destroy lifecycleScope.launchEveryCreate { } // it works as a normal CoroutineScope as well (because it is) lifecycleScope.launchMain { } } } class SomeApplication : Application() { override fun onCreate () { super .onCreate() // A custom factory can be set to add elements to the CoroutineContext LifecycleScopeFactory. set { MainImmediateCoroutineScope() + SomeCustomElement() } } } class SomeEspressoTest { @Before fun setUp () { // This custom factory can be used to use custom scopes for testing, // such as an idling dispatcher LifecycleScopeFactory. set { MainImmediateIdlingCoroutineScope() } } @After fun tearDown () { // The factory can also be reset to default LifecycleScopeFactory.reset() } }",
      "title": "One-time suspend functions"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle-extensions/#difference-from-androidx",
      "text": "This module is really just a slightly different version of androidx-lifecycle-runtime-ktx \u2014 the library which gives us the lifecycleScope property. Why not just use AndroidX? Because we need two things it doesn't offer.",
      "title": "Difference from AndroidX"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle-extensions/#custom-coroutinescope-factories",
      "text": "The way androidx-lifecycle-runtime constructs its CoroutineScope is hard-coded , which eliminates the possibility of using a custom CoroutineContext such as a DispatcherProvider or IdlingDispatcher . With dispatch.android.lifecycle , we can set a custom factory. class SomeFragmentEspressoTest { // Not part of this artifact. see dispatch-android-espresso @JvmField @Rule val idlingRule = IdlingDispatcherProviderRule() @Before fun setUp () { // set a custom factory which is applied to all newly created lifecycleScopes LifecycleScopeFactory. set { MainImmediateCoroutineScope() + idlingRule.dispatcherProvider } // now SomeFragment will use an IdlingDispatcher in its CoroutineScope } }",
      "title": "Custom CoroutineScope factories"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle-extensions/#automatic-lifecycle-jobs",
      "text": "Structured concurrency relies upon cancellation, but androidx-lifecycle-runtime.ktx doesn't cancel. It uses a special PausingDispatcher . This pausing behavior then leaks upstream, creating backpressure and potentially deadlocks. There's a bug filed in their issue tracker , but 2.2.0 got released anyway. This library's API surface is the same as that within the AndroidX version, but has a different strategy for handling lifecycle events. When a lifecycle state enters the desired range, such as at ON_RESUME , a new coroutine is created. When the state exists the range, that coroutine is cancelled . If the lifecycle state enters the desired range again, a new coroutine is created. import dispatch.android.* class SomeFragment : Fragment() { val viewModel: SomeViewModel by viewModels() init { // automatically created CoroutineScope using the factory described above lifecycleScope.launchWhenResumed { viewModel.someFlow.consume { } } } } This has the desired effect of not leaking backpressure upstream (which in this example is the viewModel ).",
      "title": "Automatic lifecycle jobs"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle-extensions/#minimum-gradle-config",
      "text": "Add to your module's build.gradle.kts : repositories { mavenCentral() } dependencies { implementation( org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.7 ) implementation( org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.7 ) implementation( com.rickbusarow.dispatch:dispatch-android-lifecycle-extensions:1.0.0-beta03 ) implementation( androidx.lifecycle:lifecycle-common:2.2.0 ) }",
      "title": "Minimum Gradle Config"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle-extensions/#packages",
      "text": "Name Summary dispatch.android.lifecycle",
      "title": "Packages"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle-extensions/#index",
      "text": "All Types",
      "title": "Index"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle-extensions/alltypes/",
      "text": "Contents All Types Name Summary (extensions in package dispatch.android.lifecycle) androidx.lifecycle.LifecycleOwner | dispatch.android.lifecycle.LifecycleScopeFactory Factory holder for LifecycleCoroutineScope 's.",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle-extensions/alltypes/#contents",
      "text": "",
      "title": "Contents"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle-extensions/alltypes/#all-types",
      "text": "Name Summary (extensions in package dispatch.android.lifecycle)",
      "title": "All Types"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle-extensions/alltypes/#androidxlifecyclelifecycleowner",
      "text": "|",
      "title": "androidx.lifecycle.LifecycleOwner"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle-extensions/alltypes/#dispatchandroidlifecyclelifecyclescopefactory",
      "text": "Factory holder for LifecycleCoroutineScope 's.",
      "title": "dispatch.android.lifecycle.LifecycleScopeFactory"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle-extensions/dispatch.android.lifecycle/",
      "text": "dispatch-android-lifecycle-extensions / dispatch.android.lifecycle Package dispatch.android.lifecycle Types Name Summary LifecycleScopeFactory Factory holder for LifecycleCoroutineScope 's. object LifecycleScopeFactory Extensions for External Classes Name Summary androidx.lifecycle.LifecycleOwner",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle-extensions/dispatch.android.lifecycle/#package-dispatchandroidlifecycle",
      "text": "",
      "title": "Package dispatch.android.lifecycle"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle-extensions/dispatch.android.lifecycle/#types",
      "text": "Name Summary LifecycleScopeFactory Factory holder for LifecycleCoroutineScope 's. object LifecycleScopeFactory",
      "title": "Types"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle-extensions/dispatch.android.lifecycle/#extensions-for-external-classes",
      "text": "Name Summary androidx.lifecycle.LifecycleOwner",
      "title": "Extensions for External Classes"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle-extensions/dispatch.android.lifecycle/-lifecycle-scope-factory/",
      "text": "dispatch-android-lifecycle-extensions / dispatch.android.lifecycle / LifecycleScopeFactory LifecycleScopeFactory object LifecycleScopeFactory (source) Factory holder for LifecycleCoroutineScope 's. By default, create returns a MainImmediateCoroutineScope . This factory can be overridden for testing or to include a custom CoroutineContext in production code. This may be done in Application.onCreate reset may be used to reset the factory to default at any time. class MyApplication : Application { override fun onCreate () { LifecycleScopeFactory. set { MainImmediateCoroutineScope() } } } class MyEspressoTest { @Before fun setUp () { LifecycleScopeFactory. set { MainImmediateIdlingCoroutineScope() } } } Functions Name Summary reset Immediately resets the factory function to its default. fun reset(): Unit set Override the default MainImmediateCoroutineScope factory, for testing or to include a custom CoroutineContext in production code. This may be done in Application.onCreate fun set(factory: () - MainImmediateCoroutineScope ): Unit",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle-extensions/dispatch.android.lifecycle/-lifecycle-scope-factory/#lifecyclescopefactory",
      "text": "object LifecycleScopeFactory (source) Factory holder for LifecycleCoroutineScope 's. By default, create returns a MainImmediateCoroutineScope . This factory can be overridden for testing or to include a custom CoroutineContext in production code. This may be done in Application.onCreate reset may be used to reset the factory to default at any time. class MyApplication : Application { override fun onCreate () { LifecycleScopeFactory. set { MainImmediateCoroutineScope() } } } class MyEspressoTest { @Before fun setUp () { LifecycleScopeFactory. set { MainImmediateIdlingCoroutineScope() } } }",
      "title": "LifecycleScopeFactory"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle-extensions/dispatch.android.lifecycle/-lifecycle-scope-factory/#functions",
      "text": "Name Summary reset Immediately resets the factory function to its default. fun reset(): Unit set Override the default MainImmediateCoroutineScope factory, for testing or to include a custom CoroutineContext in production code. This may be done in Application.onCreate fun set(factory: () - MainImmediateCoroutineScope ): Unit",
      "title": "Functions"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle-extensions/dispatch.android.lifecycle/-lifecycle-scope-factory/reset/",
      "text": "dispatch-android-lifecycle-extensions / dispatch.android.lifecycle / LifecycleScopeFactory / reset reset fun reset(): Unit (source) Immediately resets the factory function to its default. class MyEspressoTest { @Before fun setUp () { LifecycleScopeFactory. set { MainImmediateIdlingCoroutineScope() } } @After fun tearDown () { LifecycleScopeFactory.reset() } }",
      "title": "Reset"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle-extensions/dispatch.android.lifecycle/-lifecycle-scope-factory/reset/#reset",
      "text": "fun reset(): Unit (source) Immediately resets the factory function to its default. class MyEspressoTest { @Before fun setUp () { LifecycleScopeFactory. set { MainImmediateIdlingCoroutineScope() } } @After fun tearDown () { LifecycleScopeFactory.reset() } }",
      "title": "reset"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle-extensions/dispatch.android.lifecycle/-lifecycle-scope-factory/set/",
      "text": "dispatch-android-lifecycle-extensions / dispatch.android.lifecycle / LifecycleScopeFactory / set set fun set(factory: () - MainImmediateCoroutineScope ): Unit (source) Override the default MainImmediateCoroutineScope factory, for testing or to include a custom CoroutineContext in production code. This may be done in Application.onCreate class MyApplication : Application { override fun onCreate () { LifecycleScopeFactory. set { MainImmediateCoroutineScope() } } } class MyEspressoTest { @Before fun setUp () { LifecycleScopeFactory. set { MainImmediateIdlingCoroutineScope() } } } Parameters factory - sets a custom MainImmediateCoroutineScope factory to be used for all new instance creations until reset.",
      "title": "Set"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle-extensions/dispatch.android.lifecycle/-lifecycle-scope-factory/set/#set",
      "text": "fun set(factory: () - MainImmediateCoroutineScope ): Unit (source) Override the default MainImmediateCoroutineScope factory, for testing or to include a custom CoroutineContext in production code. This may be done in Application.onCreate class MyApplication : Application { override fun onCreate () { LifecycleScopeFactory. set { MainImmediateCoroutineScope() } } } class MyEspressoTest { @Before fun setUp () { LifecycleScopeFactory. set { MainImmediateIdlingCoroutineScope() } } }",
      "title": "set"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle-extensions/dispatch.android.lifecycle/-lifecycle-scope-factory/set/#parameters",
      "text": "factory - sets a custom MainImmediateCoroutineScope factory to be used for all new instance creations until reset.",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle-extensions/dispatch.android.lifecycle/androidx.lifecycle.-lifecycle-owner/",
      "text": "dispatch-android-lifecycle-extensions / dispatch.android.lifecycle / androidx.lifecycle.LifecycleOwner Extensions for androidx.lifecycle.LifecycleOwner Name Summary lifecycleScope CoroutineScope instance for the LifecycleOwner . By default, it uses the Dispatchers.Main.immediate dispatcher. val LifecycleOwner .lifecycleScope: LifecycleCoroutineScope",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle-extensions/dispatch.android.lifecycle/androidx.lifecycle.-lifecycle-owner/#extensions-for-androidxlifecyclelifecycleowner",
      "text": "Name Summary lifecycleScope CoroutineScope instance for the LifecycleOwner . By default, it uses the Dispatchers.Main.immediate dispatcher. val LifecycleOwner .lifecycleScope: LifecycleCoroutineScope",
      "title": "Extensions for androidx.lifecycle.LifecycleOwner"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle-extensions/dispatch.android.lifecycle/androidx.lifecycle.-lifecycle-owner/lifecycle-scope/",
      "text": "dispatch-android-lifecycle-extensions / dispatch.android.lifecycle / androidx.lifecycle.LifecycleOwner / lifecycleScope lifecycleScope val LifecycleOwner .lifecycleScope: LifecycleCoroutineScope (source) CoroutineScope instance for the LifecycleOwner . By default, it uses the Dispatchers.Main.immediate dispatcher. The lifecycleScope instance is created automatically upon first access, from the factory set in LifecycleScopeFactory . The type of CoroutineScope created is configurable via LifecycleScopeFactory.set . The viewModelScope is automatically cancelled when the LifecycleOwner 's lifecycle 's Lifecycle.State drops to Lifecycle.State.DESTROYED . // This could be any LifecycleOwner -- Fragments, Activities, Services... class SomeFragment : Fragment() { init { // auto-created MainImmediateCoroutineScope which is lifecycle-aware lifecycleScope //... // active only when resumed . starts a fresh coroutine each time // this is a rough proxy for LiveData behavior lifecycleScope.launchOnResume { } // active only when started . starts a fresh coroutine each time lifecycleScope.launchOnStart { } // launch when created, automatically stop on destroy lifecycleScope.launchOnCreate { } // it works as a normal CoroutineScope as well (because it is) lifecycleScope.launchMain { } } }",
      "title": "Lifecycle scope"
    },
    {
      "location": "kdoc/dispatch-android-lifecycle-extensions/dispatch.android.lifecycle/androidx.lifecycle.-lifecycle-owner/lifecycle-scope/#lifecyclescope",
      "text": "val LifecycleOwner .lifecycleScope: LifecycleCoroutineScope (source) CoroutineScope instance for the LifecycleOwner . By default, it uses the Dispatchers.Main.immediate dispatcher. The lifecycleScope instance is created automatically upon first access, from the factory set in LifecycleScopeFactory . The type of CoroutineScope created is configurable via LifecycleScopeFactory.set . The viewModelScope is automatically cancelled when the LifecycleOwner 's lifecycle 's Lifecycle.State drops to Lifecycle.State.DESTROYED . // This could be any LifecycleOwner -- Fragments, Activities, Services... class SomeFragment : Fragment() { init { // auto-created MainImmediateCoroutineScope which is lifecycle-aware lifecycleScope //... // active only when resumed . starts a fresh coroutine each time // this is a rough proxy for LiveData behavior lifecycleScope.launchOnResume { } // active only when started . starts a fresh coroutine each time lifecycleScope.launchOnStart { } // launch when created, automatically stop on destroy lifecycleScope.launchOnCreate { } // it works as a normal CoroutineScope as well (because it is) lifecycleScope.launchMain { } } }",
      "title": "lifecycleScope"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/",
      "text": "dispatch-android-viewmodel The artifact I hope you don't need, but if you're not doing dependency injection, you probably do. Contents Examples Difference from AndroidX Custom CoroutineScope factories Automatic cancellation in onCleared() viewModelScope is not lifecycleScope Extending ViewModel Minimum Gradle Config Examples import dispatch.android.* // CoroutineViewModel is just a ViewModel with a lazy viewModelScope class SomeViewModel : CoroutineViewModel() { // ... init { // auto-creates a MainImmediateCoroutineScope which is closed in onCleared() viewModelScope. //... // multiple invocations use the same instance viewModelScope.launch { } // it works as a normal CoroutineScope (because it is) viewModelScope.launchMain { } } } class SomeApplication : Application() { override fun onCreate () { super .onCreate() // A custom factory can be set to add elements to the CoroutineContext ViewModelScopeFactory. set { MainImmediateCoroutineScope() + SomeCustomElement() } } } class SomeViewModelTest { val viewModel = SomeViewModel() @Before fun setUp () { // This custom factory can be used to use custom scopes for testing ViewModelScopeFactory. set { TestProvidedCoroutineScope() } } @After fun tearDown () { // The factory can also be reset to default ViewModelScopeFactory.reset() } @Test fun someTest () = runBlocking { // the AndroidX version is public, so it s public here as well. viewModel.viewModelScope.launch { } } } Difference from AndroidX This module is essentially a fork of androidx-lifecycle-viewmodel-ktx \u2014 the library which gives us the viewModelScope property. It exists entirely so that we can have a settable factory. This gives us a lot more options for JVM or instrumented tests, with custom dispatchers or other custom CoroutineContext elements. Custom CoroutineScope factories The way androidx-lifecycle-viewModel constructs its CoroutineScope is hard-coded , which eliminates the possibility of using a custom CoroutineContext such as a DispatcherProvider or IdlingDispatcher . With dispatch-android-lifecycle , we can set a custom factory. class SomeViewModelTest { @Before fun setUp () { // This custom factory can be used to use custom scopes for testing ViewModelScopeFactory. set { TestProvidedCoroutineScope() } // it could also return a specific instance val someTestScope = TestProvidedCoroutineScope() ViewModelScopeFactory. set { someTestScope } } @After fun tearDown () { // The factory can also be reset to default ViewModelScopeFactory.reset() } } Automatic cancellation in onCleared() Just like AndroidX, this version of viewModelScope is automatically cancelled in ViewModel.onCleared() . viewModelScope is not lifecycleScope It's important to remember that onCleared() is only called when a ViewModel is about to be destroyed -- when its associated LifecycleOwner (s) are all destroyed. This means that a viewModelScope is active while the LifecycleOwner is in the backstack. Consider this example: // Don t do this class SomeViewModel : CoroutineViewModel() { init { viewModelScope.launch { // this job will continue forever even if the ViewModel is on the backstack. someRepository.dataFlow.collect { parseData(it) } } } } A CoroutineScope in a ViewModel is better utilized for single-shot requests which shouldn't be restarted in the event of a configuration change. \"Observer\" behavior should be scoped to the associated view. // Maybe do this class SomeFragment : Fragment() { val viewModel: SomeViewModel by viewModels() init { lifecycleScope.launchWhenResumed { viewModel.dataFlow.collect { } } } } class SomeViewModel : CoroutineViewModel() { // a single shot request is made using the viewModelScope val lazyData by lazy { CompletableDeferred Data ().apply { viewModelScope.launch { complete(someRepository.getData()) } } } // collection of the Flow is done using the view s lifecycleScope, // meaning that it will stop as soon as the screen is in the backstack val dataFlow = someRepository.dataFlow.onEach { parseData(it) } } Extending ViewModel Since nothing about the clear event is actually exposed outside of ViewModel , it's necessary to extend ViewModel in order to consume it for cancelling the viewModelScope . This is especially galling since ViewModel could absolutely have just been an interface to begin with. Minimum Gradle Config Add to your module's build.gradle.kts : repositories { mavenCentral() } dependencies { implementation( org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.7 ) implementation( org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.7 ) implementation( com.rickbusarow.dispatch:dispatch-android-viewmodel:1.0.0-beta03 ) } Packages Name Summary dispatch.android.viewmodel Index All Types",
      "title": "android-viewmodel"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/#contents",
      "text": "Examples Difference from AndroidX Custom CoroutineScope factories Automatic cancellation in onCleared() viewModelScope is not lifecycleScope Extending ViewModel Minimum Gradle Config",
      "title": "Contents"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/#examples",
      "text": "import dispatch.android.* // CoroutineViewModel is just a ViewModel with a lazy viewModelScope class SomeViewModel : CoroutineViewModel() { // ... init { // auto-creates a MainImmediateCoroutineScope which is closed in onCleared() viewModelScope. //... // multiple invocations use the same instance viewModelScope.launch { } // it works as a normal CoroutineScope (because it is) viewModelScope.launchMain { } } } class SomeApplication : Application() { override fun onCreate () { super .onCreate() // A custom factory can be set to add elements to the CoroutineContext ViewModelScopeFactory. set { MainImmediateCoroutineScope() + SomeCustomElement() } } } class SomeViewModelTest { val viewModel = SomeViewModel() @Before fun setUp () { // This custom factory can be used to use custom scopes for testing ViewModelScopeFactory. set { TestProvidedCoroutineScope() } } @After fun tearDown () { // The factory can also be reset to default ViewModelScopeFactory.reset() } @Test fun someTest () = runBlocking { // the AndroidX version is public, so it s public here as well. viewModel.viewModelScope.launch { } } }",
      "title": "Examples"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/#difference-from-androidx",
      "text": "This module is essentially a fork of androidx-lifecycle-viewmodel-ktx \u2014 the library which gives us the viewModelScope property. It exists entirely so that we can have a settable factory. This gives us a lot more options for JVM or instrumented tests, with custom dispatchers or other custom CoroutineContext elements.",
      "title": "Difference from AndroidX"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/#custom-coroutinescope-factories",
      "text": "The way androidx-lifecycle-viewModel constructs its CoroutineScope is hard-coded , which eliminates the possibility of using a custom CoroutineContext such as a DispatcherProvider or IdlingDispatcher . With dispatch-android-lifecycle , we can set a custom factory. class SomeViewModelTest { @Before fun setUp () { // This custom factory can be used to use custom scopes for testing ViewModelScopeFactory. set { TestProvidedCoroutineScope() } // it could also return a specific instance val someTestScope = TestProvidedCoroutineScope() ViewModelScopeFactory. set { someTestScope } } @After fun tearDown () { // The factory can also be reset to default ViewModelScopeFactory.reset() } }",
      "title": "Custom CoroutineScope factories"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/#automatic-cancellation-in-oncleared",
      "text": "Just like AndroidX, this version of viewModelScope is automatically cancelled in ViewModel.onCleared() .",
      "title": "Automatic cancellation in onCleared()"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/#viewmodelscope-is-not-lifecyclescope",
      "text": "It's important to remember that onCleared() is only called when a ViewModel is about to be destroyed -- when its associated LifecycleOwner (s) are all destroyed. This means that a viewModelScope is active while the LifecycleOwner is in the backstack. Consider this example: // Don t do this class SomeViewModel : CoroutineViewModel() { init { viewModelScope.launch { // this job will continue forever even if the ViewModel is on the backstack. someRepository.dataFlow.collect { parseData(it) } } } } A CoroutineScope in a ViewModel is better utilized for single-shot requests which shouldn't be restarted in the event of a configuration change. \"Observer\" behavior should be scoped to the associated view. // Maybe do this class SomeFragment : Fragment() { val viewModel: SomeViewModel by viewModels() init { lifecycleScope.launchWhenResumed { viewModel.dataFlow.collect { } } } } class SomeViewModel : CoroutineViewModel() { // a single shot request is made using the viewModelScope val lazyData by lazy { CompletableDeferred Data ().apply { viewModelScope.launch { complete(someRepository.getData()) } } } // collection of the Flow is done using the view s lifecycleScope, // meaning that it will stop as soon as the screen is in the backstack val dataFlow = someRepository.dataFlow.onEach { parseData(it) } }",
      "title": "viewModelScope is not lifecycleScope"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/#extending-viewmodel",
      "text": "Since nothing about the clear event is actually exposed outside of ViewModel , it's necessary to extend ViewModel in order to consume it for cancelling the viewModelScope . This is especially galling since ViewModel could absolutely have just been an interface to begin with.",
      "title": "Extending ViewModel"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/#minimum-gradle-config",
      "text": "Add to your module's build.gradle.kts : repositories { mavenCentral() } dependencies { implementation( org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.7 ) implementation( org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.7 ) implementation( com.rickbusarow.dispatch:dispatch-android-viewmodel:1.0.0-beta03 ) }",
      "title": "Minimum Gradle Config"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/#packages",
      "text": "Name Summary dispatch.android.viewmodel",
      "title": "Packages"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/#index",
      "text": "All Types",
      "title": "Index"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/alltypes/",
      "text": "The artifact I hope you don't need, but if you're not doing dependency injection, you probably do. All Types Name Summary dispatch.android.viewmodel.CoroutineViewModel Base class for ViewModel s which will be using a viewModelScope . | dispatch.android.viewmodel.ViewModelScopeFactory Factory holder for viewModelScope 's.",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/alltypes/#all-types",
      "text": "Name Summary",
      "title": "All Types"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/alltypes/#dispatchandroidviewmodelcoroutineviewmodel",
      "text": "Base class for ViewModel s which will be using a viewModelScope . |",
      "title": "dispatch.android.viewmodel.CoroutineViewModel"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/alltypes/#dispatchandroidviewmodelviewmodelscopefactory",
      "text": "Factory holder for viewModelScope 's.",
      "title": "dispatch.android.viewmodel.ViewModelScopeFactory"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/dispatch.android.viewmodel/",
      "text": "dispatch-android-viewmodel / dispatch.android.viewmodel Package dispatch.android.viewmodel Types Name Summary CoroutineViewModel Base class for ViewModel s which will be using a viewModelScope . abstract class CoroutineViewModel : ViewModel ViewModelScopeFactory Factory holder for viewModelScope 's. object ViewModelScopeFactory",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/dispatch.android.viewmodel/#package-dispatchandroidviewmodel",
      "text": "",
      "title": "Package dispatch.android.viewmodel"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/dispatch.android.viewmodel/#types",
      "text": "Name Summary CoroutineViewModel Base class for ViewModel s which will be using a viewModelScope . abstract class CoroutineViewModel : ViewModel ViewModelScopeFactory Factory holder for viewModelScope 's. object ViewModelScopeFactory",
      "title": "Types"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/dispatch.android.viewmodel/-coroutine-view-model/",
      "text": "dispatch-android-viewmodel / dispatch.android.viewmodel / CoroutineViewModel CoroutineViewModel abstract class CoroutineViewModel : ViewModel (source) Base class for ViewModel s which will be using a viewModelScope . The viewModelScope instance is created automatically upon first access from the factory set in ViewModelScopeFactory . The type of CoroutineScope created is configurable via ViewModelScopeFactory.set . This must be an abstract class since nothing about the ViewModel.onCleared event is exposed. viewModelScope is automatically cancelled when onCleared() is invoked. class SomeViewModel : CoroutineViewModel() { init { // auto-created MainImmediateCoroutineScope which is auto-cancelled in onClear() viewModelScope //... // it works as a normal CoroutineScope (because it is) viewModelScope.launchMain { } // this is the same CoroutineScope instance each time viewModelScope.launchMain { } } override fun onClear () { viewModelScope.isActive shouldBe false } } Constructors Name Summary init Base class for ViewModel s which will be using a viewModelScope . CoroutineViewModel() Properties Name Summary viewModelScope CoroutineScope instance for the CoroutineViewModel . By default, it uses the Dispatchers.Main.immediate dispatcher val viewModelScope: CoroutineScope Functions Name Summary onClear This method will be called when this ViewModel is no longer used and will be destroyed. open fun onClear(): Unit onCleared It is necessary to do a final override of ViewModel.onCleared to ensure that viewModelScope is cancelled. fun onCleared(): Unit",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/dispatch.android.viewmodel/-coroutine-view-model/#coroutineviewmodel",
      "text": "abstract class CoroutineViewModel : ViewModel (source) Base class for ViewModel s which will be using a viewModelScope . The viewModelScope instance is created automatically upon first access from the factory set in ViewModelScopeFactory . The type of CoroutineScope created is configurable via ViewModelScopeFactory.set . This must be an abstract class since nothing about the ViewModel.onCleared event is exposed. viewModelScope is automatically cancelled when onCleared() is invoked. class SomeViewModel : CoroutineViewModel() { init { // auto-created MainImmediateCoroutineScope which is auto-cancelled in onClear() viewModelScope //... // it works as a normal CoroutineScope (because it is) viewModelScope.launchMain { } // this is the same CoroutineScope instance each time viewModelScope.launchMain { } } override fun onClear () { viewModelScope.isActive shouldBe false } }",
      "title": "CoroutineViewModel"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/dispatch.android.viewmodel/-coroutine-view-model/#constructors",
      "text": "Name Summary init Base class for ViewModel s which will be using a viewModelScope . CoroutineViewModel()",
      "title": "Constructors"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/dispatch.android.viewmodel/-coroutine-view-model/#properties",
      "text": "Name Summary viewModelScope CoroutineScope instance for the CoroutineViewModel . By default, it uses the Dispatchers.Main.immediate dispatcher val viewModelScope: CoroutineScope",
      "title": "Properties"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/dispatch.android.viewmodel/-coroutine-view-model/#functions",
      "text": "Name Summary onClear This method will be called when this ViewModel is no longer used and will be destroyed. open fun onClear(): Unit onCleared It is necessary to do a final override of ViewModel.onCleared to ensure that viewModelScope is cancelled. fun onCleared(): Unit",
      "title": "Functions"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/dispatch.android.viewmodel/-coroutine-view-model/-init-/",
      "text": "dispatch-android-viewmodel / dispatch.android.viewmodel / CoroutineViewModel / init init CoroutineViewModel() Base class for ViewModel s which will be using a viewModelScope . The viewModelScope instance is created automatically upon first access from the factory set in ViewModelScopeFactory . The type of CoroutineScope created is configurable via ViewModelScopeFactory.set . This must be an abstract class since nothing about the ViewModel.onCleared event is exposed. viewModelScope is automatically cancelled when onCleared() is invoked. class SomeViewModel : CoroutineViewModel() { init { // auto-created MainImmediateCoroutineScope which is auto-cancelled in onClear() viewModelScope //... // it works as a normal CoroutineScope (because it is) viewModelScope.launchMain { } // this is the same CoroutineScope instance each time viewModelScope.launchMain { } } override fun onClear () { viewModelScope.isActive shouldBe false } }",
      "title": " init "
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/dispatch.android.viewmodel/-coroutine-view-model/-init-/#init",
      "text": "CoroutineViewModel() Base class for ViewModel s which will be using a viewModelScope . The viewModelScope instance is created automatically upon first access from the factory set in ViewModelScopeFactory . The type of CoroutineScope created is configurable via ViewModelScopeFactory.set . This must be an abstract class since nothing about the ViewModel.onCleared event is exposed. viewModelScope is automatically cancelled when onCleared() is invoked. class SomeViewModel : CoroutineViewModel() { init { // auto-created MainImmediateCoroutineScope which is auto-cancelled in onClear() viewModelScope //... // it works as a normal CoroutineScope (because it is) viewModelScope.launchMain { } // this is the same CoroutineScope instance each time viewModelScope.launchMain { } } override fun onClear () { viewModelScope.isActive shouldBe false } }",
      "title": "&lt;init&gt;"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/dispatch.android.viewmodel/-coroutine-view-model/on-clear/",
      "text": "dispatch-android-viewmodel / dispatch.android.viewmodel / CoroutineViewModel / onClear onClear protected open fun onClear(): Unit (source) This method will be called when this ViewModel is no longer used and will be destroyed.",
      "title": "On clear"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/dispatch.android.viewmodel/-coroutine-view-model/on-clear/#onclear",
      "text": "protected open fun onClear(): Unit (source) This method will be called when this ViewModel is no longer used and will be destroyed.",
      "title": "onClear"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/dispatch.android.viewmodel/-coroutine-view-model/on-cleared/",
      "text": "dispatch-android-viewmodel / dispatch.android.viewmodel / CoroutineViewModel / onCleared onCleared protected fun onCleared(): Unit (source) It is necessary to do a final override of ViewModel.onCleared to ensure that viewModelScope is cancelled. Use onClear to perform logic after this event.",
      "title": "On cleared"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/dispatch.android.viewmodel/-coroutine-view-model/on-cleared/#oncleared",
      "text": "protected fun onCleared(): Unit (source) It is necessary to do a final override of ViewModel.onCleared to ensure that viewModelScope is cancelled. Use onClear to perform logic after this event.",
      "title": "onCleared"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/dispatch.android.viewmodel/-coroutine-view-model/view-model-scope/",
      "text": "dispatch-android-viewmodel / dispatch.android.viewmodel / CoroutineViewModel / viewModelScope viewModelScope val viewModelScope: CoroutineScope (source) CoroutineScope instance for the CoroutineViewModel . By default, it uses the Dispatchers.Main.immediate dispatcher The viewModelScope instance is created automatically upon first access from the factory set in ViewModelScopeFactory . The type of CoroutineScope created is configurable via ViewModelScopeFactory.set . viewModelScope is automatically cancelled when onCleared() is invoked. class SomeViewModel : CoroutineViewModel() { init { // auto-created MainImmediateCoroutineScope which is auto-cancelled in onClear() viewModelScope //... // it works as a normal CoroutineScope (because it is) viewModelScope.launchMain { } // this is the same CoroutineScope instance each time viewModelScope.launchMain { } } override fun onClear () { viewModelScope.isActive shouldBe false } }",
      "title": "View model scope"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/dispatch.android.viewmodel/-coroutine-view-model/view-model-scope/#viewmodelscope",
      "text": "val viewModelScope: CoroutineScope (source) CoroutineScope instance for the CoroutineViewModel . By default, it uses the Dispatchers.Main.immediate dispatcher The viewModelScope instance is created automatically upon first access from the factory set in ViewModelScopeFactory . The type of CoroutineScope created is configurable via ViewModelScopeFactory.set . viewModelScope is automatically cancelled when onCleared() is invoked. class SomeViewModel : CoroutineViewModel() { init { // auto-created MainImmediateCoroutineScope which is auto-cancelled in onClear() viewModelScope //... // it works as a normal CoroutineScope (because it is) viewModelScope.launchMain { } // this is the same CoroutineScope instance each time viewModelScope.launchMain { } } override fun onClear () { viewModelScope.isActive shouldBe false } }",
      "title": "viewModelScope"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/dispatch.android.viewmodel/-view-model-scope-factory/",
      "text": "dispatch-android-viewmodel / dispatch.android.viewmodel / ViewModelScopeFactory ViewModelScopeFactory object ViewModelScopeFactory (source) Factory holder for viewModelScope 's. By default, create returns a MainImmediateCoroutineScope , but may return any CoroutineScope . This factory can be overridden for testing or to include a custom CoroutineContext in production code. This may be done in Application.onCreate . reset may be used to reset the factory to default at any time. class MyApplication : Application { override fun onCreate () { ViewModelScopeFactory. set { MainImmediateCoroutineScope() } } } class MyEspressoTest { @Before fun setUp () { ViewModelScopeFactory. set { MainImmediateIdlingCoroutineScope() } } } class MyJvmTest { @Before fun setUp () { ViewModelScopeFactory. set { TestProvidedCoroutineScope() } } } Functions Name Summary reset Immediately resets the factory function to its default. fun reset(): Unit set Override the default MainImmediateCoroutineScope factory, for testing or to include a custom CoroutineContext in production code. This may be done in Application.onCreate fun set(factory: () - CoroutineScope ): Unit",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/dispatch.android.viewmodel/-view-model-scope-factory/#viewmodelscopefactory",
      "text": "object ViewModelScopeFactory (source) Factory holder for viewModelScope 's. By default, create returns a MainImmediateCoroutineScope , but may return any CoroutineScope . This factory can be overridden for testing or to include a custom CoroutineContext in production code. This may be done in Application.onCreate . reset may be used to reset the factory to default at any time. class MyApplication : Application { override fun onCreate () { ViewModelScopeFactory. set { MainImmediateCoroutineScope() } } } class MyEspressoTest { @Before fun setUp () { ViewModelScopeFactory. set { MainImmediateIdlingCoroutineScope() } } } class MyJvmTest { @Before fun setUp () { ViewModelScopeFactory. set { TestProvidedCoroutineScope() } } }",
      "title": "ViewModelScopeFactory"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/dispatch.android.viewmodel/-view-model-scope-factory/#functions",
      "text": "Name Summary reset Immediately resets the factory function to its default. fun reset(): Unit set Override the default MainImmediateCoroutineScope factory, for testing or to include a custom CoroutineContext in production code. This may be done in Application.onCreate fun set(factory: () - CoroutineScope ): Unit",
      "title": "Functions"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/dispatch.android.viewmodel/-view-model-scope-factory/reset/",
      "text": "dispatch-android-viewmodel / dispatch.android.viewmodel / ViewModelScopeFactory / reset reset fun reset(): Unit (source) Immediately resets the factory function to its default. class MyEspressoTest { @Before fun setUp () { ViewModelScopeFactory. set { MainImmediateIdlingCoroutineScope() } } @After fun tearDown () { ViewModelScopeFactory.reset() } }",
      "title": "Reset"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/dispatch.android.viewmodel/-view-model-scope-factory/reset/#reset",
      "text": "fun reset(): Unit (source) Immediately resets the factory function to its default. class MyEspressoTest { @Before fun setUp () { ViewModelScopeFactory. set { MainImmediateIdlingCoroutineScope() } } @After fun tearDown () { ViewModelScopeFactory.reset() } }",
      "title": "reset"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/dispatch.android.viewmodel/-view-model-scope-factory/set/",
      "text": "dispatch-android-viewmodel / dispatch.android.viewmodel / ViewModelScopeFactory / set set fun set(factory: () - CoroutineScope ): Unit (source) Override the default MainImmediateCoroutineScope factory, for testing or to include a custom CoroutineContext in production code. This may be done in Application.onCreate class MyApplication : Application { override fun onCreate () { ViewModelScopeFactory. set { MainImmediateCoroutineScope() } } } class MyEspressoTest { @Before fun setUp () { ViewModelScopeFactory. set { MainImmediateIdlingCoroutineScope() } } } class MyJvmTest { @Before fun setUp () { ViewModelScopeFactory. set { TestProvidedCoroutineScope() } } } Parameters factory - sets a custom CoroutineScope factory to be used for all new instance creations until reset.",
      "title": "Set"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/dispatch.android.viewmodel/-view-model-scope-factory/set/#set",
      "text": "fun set(factory: () - CoroutineScope ): Unit (source) Override the default MainImmediateCoroutineScope factory, for testing or to include a custom CoroutineContext in production code. This may be done in Application.onCreate class MyApplication : Application { override fun onCreate () { ViewModelScopeFactory. set { MainImmediateCoroutineScope() } } } class MyEspressoTest { @Before fun setUp () { ViewModelScopeFactory. set { MainImmediateIdlingCoroutineScope() } } } class MyJvmTest { @Before fun setUp () { ViewModelScopeFactory. set { TestProvidedCoroutineScope() } } }",
      "title": "set"
    },
    {
      "location": "kdoc/dispatch-android-viewmodel/dispatch.android.viewmodel/-view-model-scope-factory/set/#parameters",
      "text": "factory - sets a custom CoroutineScope factory to be used for all new instance creations until reset.",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-core/",
      "text": "dispatch-core Packages Name Summary dispatch.core Index All Types",
      "title": "core"
    },
    {
      "location": "kdoc/dispatch-core/#packages",
      "text": "Name Summary dispatch.core",
      "title": "Packages"
    },
    {
      "location": "kdoc/dispatch-core/#index",
      "text": "All Types",
      "title": "Index"
    },
    {
      "location": "kdoc/dispatch-core/alltypes/",
      "text": "All Types Name Summary (extensions in package dispatch.core) kotlin.coroutines.CoroutineContext | (extensions in package dispatch.core) kotlinx.coroutines.CoroutineScope | dispatch.core.DefaultCoroutineScope Marker interface which designates a CoroutineScope with a CoroutineDispatcher of default . | dispatch.core.DefaultDispatcherProvider Default implementation of DispatcherProvider which simply delegates to the corresponding properties in the Dispatchers singleton. | dispatch.core.DispatcherProvider Interface corresponding to the different CoroutineDispatcher 's offered by Dispatchers . | (extensions in package dispatch.core) kotlinx.coroutines.flow.Flow | dispatch.core.IOCoroutineScope Marker interface which designates a CoroutineScope with a CoroutineDispatcher of io . | dispatch.core.MainCoroutineScope Marker interface which designates a CoroutineScope with a CoroutineDispatcher of main . | dispatch.core.MainImmediateCoroutineScope Marker interface which designates a CoroutineScope with a CoroutineDispatcher of mainImmediate . | dispatch.core.UnconfinedCoroutineScope Marker interface which designates a CoroutineScope with a CoroutineDispatcher of unconfined .",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-core/alltypes/#all-types",
      "text": "Name Summary (extensions in package dispatch.core)",
      "title": "All Types"
    },
    {
      "location": "kdoc/dispatch-core/alltypes/#kotlincoroutinescoroutinecontext",
      "text": "| (extensions in package dispatch.core)",
      "title": "kotlin.coroutines.CoroutineContext"
    },
    {
      "location": "kdoc/dispatch-core/alltypes/#kotlinxcoroutinescoroutinescope",
      "text": "|",
      "title": "kotlinx.coroutines.CoroutineScope"
    },
    {
      "location": "kdoc/dispatch-core/alltypes/#dispatchcoredefaultcoroutinescope",
      "text": "Marker interface which designates a CoroutineScope with a CoroutineDispatcher of default . |",
      "title": "dispatch.core.DefaultCoroutineScope"
    },
    {
      "location": "kdoc/dispatch-core/alltypes/#dispatchcoredefaultdispatcherprovider",
      "text": "Default implementation of DispatcherProvider which simply delegates to the corresponding properties in the Dispatchers singleton. |",
      "title": "dispatch.core.DefaultDispatcherProvider"
    },
    {
      "location": "kdoc/dispatch-core/alltypes/#dispatchcoredispatcherprovider",
      "text": "Interface corresponding to the different CoroutineDispatcher 's offered by Dispatchers . | (extensions in package dispatch.core)",
      "title": "dispatch.core.DispatcherProvider"
    },
    {
      "location": "kdoc/dispatch-core/alltypes/#kotlinxcoroutinesflowflow",
      "text": "|",
      "title": "kotlinx.coroutines.flow.Flow"
    },
    {
      "location": "kdoc/dispatch-core/alltypes/#dispatchcoreiocoroutinescope",
      "text": "Marker interface which designates a CoroutineScope with a CoroutineDispatcher of io . |",
      "title": "dispatch.core.IOCoroutineScope"
    },
    {
      "location": "kdoc/dispatch-core/alltypes/#dispatchcoremaincoroutinescope",
      "text": "Marker interface which designates a CoroutineScope with a CoroutineDispatcher of main . |",
      "title": "dispatch.core.MainCoroutineScope"
    },
    {
      "location": "kdoc/dispatch-core/alltypes/#dispatchcoremainimmediatecoroutinescope",
      "text": "Marker interface which designates a CoroutineScope with a CoroutineDispatcher of mainImmediate . |",
      "title": "dispatch.core.MainImmediateCoroutineScope"
    },
    {
      "location": "kdoc/dispatch-core/alltypes/#dispatchcoreunconfinedcoroutinescope",
      "text": "Marker interface which designates a CoroutineScope with a CoroutineDispatcher of unconfined .",
      "title": "dispatch.core.UnconfinedCoroutineScope"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/",
      "text": "dispatch-core / dispatch.core Package dispatch.core Types Name Summary DefaultCoroutineScope Marker interface which designates a CoroutineScope with a CoroutineDispatcher of default . interface DefaultCoroutineScope : CoroutineScope DefaultDispatcherProvider Default implementation of DispatcherProvider which simply delegates to the corresponding properties in the Dispatchers singleton. class DefaultDispatcherProvider : DispatcherProvider DispatcherProvider Interface corresponding to the different CoroutineDispatcher 's offered by Dispatchers . interface DispatcherProvider : Element IOCoroutineScope Marker interface which designates a CoroutineScope with a CoroutineDispatcher of io . interface IOCoroutineScope : CoroutineScope MainCoroutineScope Marker interface which designates a CoroutineScope with a CoroutineDispatcher of main . interface MainCoroutineScope : CoroutineScope MainImmediateCoroutineScope Marker interface which designates a CoroutineScope with a CoroutineDispatcher of mainImmediate . interface MainImmediateCoroutineScope : CoroutineScope UnconfinedCoroutineScope Marker interface which designates a CoroutineScope with a CoroutineDispatcher of unconfined . interface UnconfinedCoroutineScope : CoroutineScope Extensions for External Classes Name Summary kotlin.coroutines.CoroutineContext kotlinx.coroutines.CoroutineScope kotlinx.coroutines.flow.Flow Functions Name Summary DefaultCoroutineScope Factory function for a DefaultCoroutineScope with a DispatcherProvider . Dispatch defaults to the default property of the DispatcherProvider . fun DefaultCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: DispatcherProvider = DefaultDispatcherProvider()): DefaultCoroutineScope fun DefaultCoroutineScope(coroutineContext: CoroutineContext ): DefaultCoroutineScope DispatcherProvider Creates a default implementation of DispatcherProvider . fun DispatcherProvider(): DispatcherProvider IOCoroutineScope Factory function for an IOCoroutineScope with a DispatcherProvider . Dispatch defaults to the io property of the DispatcherProvider . fun IOCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: DispatcherProvider = DefaultDispatcherProvider()): IOCoroutineScope Factory function for a IOCoroutineScope with a DispatcherProvider . Dispatch defaults to the io property of the DispatcherProvider . fun IOCoroutineScope(coroutineContext: CoroutineContext ): IOCoroutineScope MainCoroutineScope Factory function for a MainCoroutineScope with a DispatcherProvider . Dispatch defaults to the main property of the DispatcherProvider . fun MainCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: DispatcherProvider = DefaultDispatcherProvider()): MainCoroutineScope fun MainCoroutineScope(coroutineContext: CoroutineContext ): MainCoroutineScope MainImmediateCoroutineScope Factory function for a MainImmediateCoroutineScope with a DispatcherProvider . Dispatch defaults to the mainImmediate property of the DispatcherProvider . fun MainImmediateCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: DispatcherProvider = DefaultDispatcherProvider()): MainImmediateCoroutineScope fun MainImmediateCoroutineScope(coroutineContext: CoroutineContext ): MainImmediateCoroutineScope UnconfinedCoroutineScope Factory function for a UnconfinedCoroutineScope with a DispatcherProvider . Dispatch defaults to the unconfined property of the DispatcherProvider . fun UnconfinedCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: DispatcherProvider = DefaultDispatcherProvider()): UnconfinedCoroutineScope fun UnconfinedCoroutineScope(coroutineContext: CoroutineContext ): UnconfinedCoroutineScope withDefault Calls the specified suspending block with a given coroutine context, suspends until it completes, and returns the result. suspend fun T withDefault(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope .() - T): T withIO Calls the specified suspending block with a given coroutine context, suspends until it completes, and returns the result. suspend fun T withIO(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope .() - T): T withMain Calls the specified suspending block with a given coroutine context, suspends until it completes, and returns the result. suspend fun T withMain(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope .() - T): T withMainImmediate Calls the specified suspending block with a given coroutine context, suspends until it completes, and returns the result. suspend fun T withMainImmediate(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope .() - T): T withUnconfined Calls the specified suspending block with a given coroutine context, suspends until it completes, and returns the result. suspend fun T withUnconfined(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope .() - T): T",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/#package-dispatchcore",
      "text": "",
      "title": "Package dispatch.core"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/#types",
      "text": "Name Summary DefaultCoroutineScope Marker interface which designates a CoroutineScope with a CoroutineDispatcher of default . interface DefaultCoroutineScope : CoroutineScope DefaultDispatcherProvider Default implementation of DispatcherProvider which simply delegates to the corresponding properties in the Dispatchers singleton. class DefaultDispatcherProvider : DispatcherProvider DispatcherProvider Interface corresponding to the different CoroutineDispatcher 's offered by Dispatchers . interface DispatcherProvider : Element IOCoroutineScope Marker interface which designates a CoroutineScope with a CoroutineDispatcher of io . interface IOCoroutineScope : CoroutineScope MainCoroutineScope Marker interface which designates a CoroutineScope with a CoroutineDispatcher of main . interface MainCoroutineScope : CoroutineScope MainImmediateCoroutineScope Marker interface which designates a CoroutineScope with a CoroutineDispatcher of mainImmediate . interface MainImmediateCoroutineScope : CoroutineScope UnconfinedCoroutineScope Marker interface which designates a CoroutineScope with a CoroutineDispatcher of unconfined . interface UnconfinedCoroutineScope : CoroutineScope",
      "title": "Types"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/#extensions-for-external-classes",
      "text": "Name Summary kotlin.coroutines.CoroutineContext kotlinx.coroutines.CoroutineScope kotlinx.coroutines.flow.Flow",
      "title": "Extensions for External Classes"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/#functions",
      "text": "Name Summary DefaultCoroutineScope Factory function for a DefaultCoroutineScope with a DispatcherProvider . Dispatch defaults to the default property of the DispatcherProvider . fun DefaultCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: DispatcherProvider = DefaultDispatcherProvider()): DefaultCoroutineScope fun DefaultCoroutineScope(coroutineContext: CoroutineContext ): DefaultCoroutineScope DispatcherProvider Creates a default implementation of DispatcherProvider . fun DispatcherProvider(): DispatcherProvider IOCoroutineScope Factory function for an IOCoroutineScope with a DispatcherProvider . Dispatch defaults to the io property of the DispatcherProvider . fun IOCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: DispatcherProvider = DefaultDispatcherProvider()): IOCoroutineScope Factory function for a IOCoroutineScope with a DispatcherProvider . Dispatch defaults to the io property of the DispatcherProvider . fun IOCoroutineScope(coroutineContext: CoroutineContext ): IOCoroutineScope MainCoroutineScope Factory function for a MainCoroutineScope with a DispatcherProvider . Dispatch defaults to the main property of the DispatcherProvider . fun MainCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: DispatcherProvider = DefaultDispatcherProvider()): MainCoroutineScope fun MainCoroutineScope(coroutineContext: CoroutineContext ): MainCoroutineScope MainImmediateCoroutineScope Factory function for a MainImmediateCoroutineScope with a DispatcherProvider . Dispatch defaults to the mainImmediate property of the DispatcherProvider . fun MainImmediateCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: DispatcherProvider = DefaultDispatcherProvider()): MainImmediateCoroutineScope fun MainImmediateCoroutineScope(coroutineContext: CoroutineContext ): MainImmediateCoroutineScope UnconfinedCoroutineScope Factory function for a UnconfinedCoroutineScope with a DispatcherProvider . Dispatch defaults to the unconfined property of the DispatcherProvider . fun UnconfinedCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: DispatcherProvider = DefaultDispatcherProvider()): UnconfinedCoroutineScope fun UnconfinedCoroutineScope(coroutineContext: CoroutineContext ): UnconfinedCoroutineScope withDefault Calls the specified suspending block with a given coroutine context, suspends until it completes, and returns the result. suspend fun T withDefault(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope .() - T): T withIO Calls the specified suspending block with a given coroutine context, suspends until it completes, and returns the result. suspend fun T withIO(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope .() - T): T withMain Calls the specified suspending block with a given coroutine context, suspends until it completes, and returns the result. suspend fun T withMain(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope .() - T): T withMainImmediate Calls the specified suspending block with a given coroutine context, suspends until it completes, and returns the result. suspend fun T withMainImmediate(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope .() - T): T withUnconfined Calls the specified suspending block with a given coroutine context, suspends until it completes, and returns the result. suspend fun T withUnconfined(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope .() - T): T",
      "title": "Functions"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-default-coroutine-scope/",
      "text": "dispatch-core / dispatch.core / DefaultCoroutineScope DefaultCoroutineScope interface DefaultCoroutineScope : CoroutineScope (source) Marker interface which designates a CoroutineScope with a CoroutineDispatcher of default . fun DefaultCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: DispatcherProvider = DefaultDispatcherProvider()): DefaultCoroutineScope (source) Factory function for a DefaultCoroutineScope with a DispatcherProvider . Dispatch defaults to the default property of the DispatcherProvider . Parameters job - Job to be used for the resulting CoroutineScope . Uses a SupervisorJob if one is not provided. dispatcherProvider - DispatcherProvider to be used for the resulting CoroutineScope . Uses a DefaultDispatcherProvider if one is not provided. See Also CoroutineScope fun DefaultCoroutineScope(coroutineContext: CoroutineContext ): DefaultCoroutineScope (source) Factory function for a DefaultCoroutineScope with a DispatcherProvider . Dispatch defaults to the default property of the DispatcherProvider . Parameters coroutineContext - CoroutineContext to be used for the resulting CoroutineScope . Any existing ContinuationInterceptor will be overwritten. If the CoroutineContext does not already contain a DispatcherProvider , a DefaultDispatcherProvider will be added. See Also CoroutineScope",
      "title": " default coroutine scope"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-default-coroutine-scope/#defaultcoroutinescope",
      "text": "interface DefaultCoroutineScope : CoroutineScope (source) Marker interface which designates a CoroutineScope with a CoroutineDispatcher of default . fun DefaultCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: DispatcherProvider = DefaultDispatcherProvider()): DefaultCoroutineScope (source) Factory function for a DefaultCoroutineScope with a DispatcherProvider . Dispatch defaults to the default property of the DispatcherProvider .",
      "title": "DefaultCoroutineScope"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-default-coroutine-scope/#parameters",
      "text": "job - Job to be used for the resulting CoroutineScope . Uses a SupervisorJob if one is not provided. dispatcherProvider - DispatcherProvider to be used for the resulting CoroutineScope . Uses a DefaultDispatcherProvider if one is not provided. See Also CoroutineScope fun DefaultCoroutineScope(coroutineContext: CoroutineContext ): DefaultCoroutineScope (source) Factory function for a DefaultCoroutineScope with a DispatcherProvider . Dispatch defaults to the default property of the DispatcherProvider .",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-default-coroutine-scope/#parameters_1",
      "text": "coroutineContext - CoroutineContext to be used for the resulting CoroutineScope . Any existing ContinuationInterceptor will be overwritten. If the CoroutineContext does not already contain a DispatcherProvider , a DefaultDispatcherProvider will be added. See Also CoroutineScope",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-dispatcher-provider/",
      "text": "dispatch-core / dispatch.core / DispatcherProvider DispatcherProvider fun DispatcherProvider(): DispatcherProvider (source) Creates a default implementation of DispatcherProvider . See Also DefaultDispatcherProvider",
      "title": " dispatcher provider"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-dispatcher-provider/#dispatcherprovider",
      "text": "fun DispatcherProvider(): DispatcherProvider (source) Creates a default implementation of DispatcherProvider . See Also DefaultDispatcherProvider",
      "title": "DispatcherProvider"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-i-o-coroutine-scope/",
      "text": "dispatch-core / dispatch.core / IOCoroutineScope IOCoroutineScope interface IOCoroutineScope : CoroutineScope (source) Marker interface which designates a CoroutineScope with a CoroutineDispatcher of io . fun IOCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: DispatcherProvider = DefaultDispatcherProvider()): IOCoroutineScope (source) Factory function for an IOCoroutineScope with a DispatcherProvider . Dispatch defaults to the io property of the DispatcherProvider . Parameters job - Job to be used for the resulting CoroutineScope . Uses a SupervisorJob if one is not provided. dispatcherProvider - DispatcherProvider to be used for the resulting CoroutineScope . Uses a DefaultDispatcherProvider if one is not provided. See Also CoroutineScope fun IOCoroutineScope(coroutineContext: CoroutineContext ): IOCoroutineScope (source) Factory function for a IOCoroutineScope with a DispatcherProvider . Dispatch defaults to the io property of the DispatcherProvider . Parameters coroutineContext - CoroutineContext to be used for the resulting CoroutineScope . Any existing ContinuationInterceptor will be overwritten. If the CoroutineContext does not already contain a DispatcherProvider , a DefaultDispatcherProvider will be added. See Also CoroutineScope",
      "title": " i o coroutine scope"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-i-o-coroutine-scope/#iocoroutinescope",
      "text": "interface IOCoroutineScope : CoroutineScope (source) Marker interface which designates a CoroutineScope with a CoroutineDispatcher of io . fun IOCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: DispatcherProvider = DefaultDispatcherProvider()): IOCoroutineScope (source) Factory function for an IOCoroutineScope with a DispatcherProvider . Dispatch defaults to the io property of the DispatcherProvider .",
      "title": "IOCoroutineScope"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-i-o-coroutine-scope/#parameters",
      "text": "job - Job to be used for the resulting CoroutineScope . Uses a SupervisorJob if one is not provided. dispatcherProvider - DispatcherProvider to be used for the resulting CoroutineScope . Uses a DefaultDispatcherProvider if one is not provided. See Also CoroutineScope fun IOCoroutineScope(coroutineContext: CoroutineContext ): IOCoroutineScope (source) Factory function for a IOCoroutineScope with a DispatcherProvider . Dispatch defaults to the io property of the DispatcherProvider .",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-i-o-coroutine-scope/#parameters_1",
      "text": "coroutineContext - CoroutineContext to be used for the resulting CoroutineScope . Any existing ContinuationInterceptor will be overwritten. If the CoroutineContext does not already contain a DispatcherProvider , a DefaultDispatcherProvider will be added. See Also CoroutineScope",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-main-coroutine-scope/",
      "text": "dispatch-core / dispatch.core / MainCoroutineScope MainCoroutineScope interface MainCoroutineScope : CoroutineScope (source) Marker interface which designates a CoroutineScope with a CoroutineDispatcher of main . fun MainCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: DispatcherProvider = DefaultDispatcherProvider()): MainCoroutineScope (source) Factory function for a MainCoroutineScope with a DispatcherProvider . Dispatch defaults to the main property of the DispatcherProvider . Parameters job - Job to be used for the resulting CoroutineScope . Uses a SupervisorJob if one is not provided. dispatcherProvider - DispatcherProvider to be used for the resulting CoroutineScope . Uses a DefaultDispatcherProvider if one is not provided. See Also CoroutineScope fun MainCoroutineScope(coroutineContext: CoroutineContext ): MainCoroutineScope (source) Factory function for a MainCoroutineScope with a DispatcherProvider . Dispatch defaults to the main property of the DispatcherProvider . Parameters coroutineContext - CoroutineContext to be used for the resulting CoroutineScope . Any existing ContinuationInterceptor will be overwritten. If the CoroutineContext does not already contain a DispatcherProvider , a DefaultDispatcherProvider will be added. See Also CoroutineScope",
      "title": " main coroutine scope"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-main-coroutine-scope/#maincoroutinescope",
      "text": "interface MainCoroutineScope : CoroutineScope (source) Marker interface which designates a CoroutineScope with a CoroutineDispatcher of main . fun MainCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: DispatcherProvider = DefaultDispatcherProvider()): MainCoroutineScope (source) Factory function for a MainCoroutineScope with a DispatcherProvider . Dispatch defaults to the main property of the DispatcherProvider .",
      "title": "MainCoroutineScope"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-main-coroutine-scope/#parameters",
      "text": "job - Job to be used for the resulting CoroutineScope . Uses a SupervisorJob if one is not provided. dispatcherProvider - DispatcherProvider to be used for the resulting CoroutineScope . Uses a DefaultDispatcherProvider if one is not provided. See Also CoroutineScope fun MainCoroutineScope(coroutineContext: CoroutineContext ): MainCoroutineScope (source) Factory function for a MainCoroutineScope with a DispatcherProvider . Dispatch defaults to the main property of the DispatcherProvider .",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-main-coroutine-scope/#parameters_1",
      "text": "coroutineContext - CoroutineContext to be used for the resulting CoroutineScope . Any existing ContinuationInterceptor will be overwritten. If the CoroutineContext does not already contain a DispatcherProvider , a DefaultDispatcherProvider will be added. See Also CoroutineScope",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-main-immediate-coroutine-scope/",
      "text": "dispatch-core / dispatch.core / MainImmediateCoroutineScope MainImmediateCoroutineScope interface MainImmediateCoroutineScope : CoroutineScope (source) Marker interface which designates a CoroutineScope with a CoroutineDispatcher of mainImmediate . fun MainImmediateCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: DispatcherProvider = DefaultDispatcherProvider()): MainImmediateCoroutineScope (source) Factory function for a MainImmediateCoroutineScope with a DispatcherProvider . Dispatch defaults to the mainImmediate property of the DispatcherProvider . Parameters job - Job to be used for the resulting CoroutineScope . Uses a SupervisorJob if one is not provided. dispatcherProvider - DispatcherProvider to be used for the resulting CoroutineScope . Uses a DefaultDispatcherProvider if one is not provided. See Also CoroutineScope fun MainImmediateCoroutineScope(coroutineContext: CoroutineContext ): MainImmediateCoroutineScope (source) Factory function for a MainImmediateCoroutineScope with a DispatcherProvider . Dispatch defaults to the mainImmediate property of the DispatcherProvider . Parameters coroutineContext - CoroutineContext to be used for the resulting CoroutineScope . Any existing ContinuationInterceptor will be overwritten. If the CoroutineContext does not already contain a DispatcherProvider , a DefaultDispatcherProvider will be added. See Also CoroutineScope",
      "title": " main immediate coroutine scope"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-main-immediate-coroutine-scope/#mainimmediatecoroutinescope",
      "text": "interface MainImmediateCoroutineScope : CoroutineScope (source) Marker interface which designates a CoroutineScope with a CoroutineDispatcher of mainImmediate . fun MainImmediateCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: DispatcherProvider = DefaultDispatcherProvider()): MainImmediateCoroutineScope (source) Factory function for a MainImmediateCoroutineScope with a DispatcherProvider . Dispatch defaults to the mainImmediate property of the DispatcherProvider .",
      "title": "MainImmediateCoroutineScope"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-main-immediate-coroutine-scope/#parameters",
      "text": "job - Job to be used for the resulting CoroutineScope . Uses a SupervisorJob if one is not provided. dispatcherProvider - DispatcherProvider to be used for the resulting CoroutineScope . Uses a DefaultDispatcherProvider if one is not provided. See Also CoroutineScope fun MainImmediateCoroutineScope(coroutineContext: CoroutineContext ): MainImmediateCoroutineScope (source) Factory function for a MainImmediateCoroutineScope with a DispatcherProvider . Dispatch defaults to the mainImmediate property of the DispatcherProvider .",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-main-immediate-coroutine-scope/#parameters_1",
      "text": "coroutineContext - CoroutineContext to be used for the resulting CoroutineScope . Any existing ContinuationInterceptor will be overwritten. If the CoroutineContext does not already contain a DispatcherProvider , a DefaultDispatcherProvider will be added. See Also CoroutineScope",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-unconfined-coroutine-scope/",
      "text": "dispatch-core / dispatch.core / UnconfinedCoroutineScope UnconfinedCoroutineScope interface UnconfinedCoroutineScope : CoroutineScope (source) Marker interface which designates a CoroutineScope with a CoroutineDispatcher of unconfined . fun UnconfinedCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: DispatcherProvider = DefaultDispatcherProvider()): UnconfinedCoroutineScope (source) Factory function for a UnconfinedCoroutineScope with a DispatcherProvider . Dispatch defaults to the unconfined property of the DispatcherProvider . Parameters job - Job to be used for the resulting CoroutineScope . Uses a SupervisorJob if one is not provided. dispatcherProvider - DispatcherProvider to be used for the resulting CoroutineScope . Uses a DefaultDispatcherProvider if one is not provided. See Also CoroutineScope fun UnconfinedCoroutineScope(coroutineContext: CoroutineContext ): UnconfinedCoroutineScope (source) Factory function for a UnconfinedCoroutineScope with a DispatcherProvider . Dispatch defaults to the unconfined property of the DispatcherProvider . Parameters coroutineContext - CoroutineContext to be used for the resulting CoroutineScope . Any existing ContinuationInterceptor will be overwritten. If the CoroutineContext does not already contain a DispatcherProvider , a DefaultDispatcherProvider will be added. See Also CoroutineScope",
      "title": " unconfined coroutine scope"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-unconfined-coroutine-scope/#unconfinedcoroutinescope",
      "text": "interface UnconfinedCoroutineScope : CoroutineScope (source) Marker interface which designates a CoroutineScope with a CoroutineDispatcher of unconfined . fun UnconfinedCoroutineScope(job: Job = SupervisorJob(), dispatcherProvider: DispatcherProvider = DefaultDispatcherProvider()): UnconfinedCoroutineScope (source) Factory function for a UnconfinedCoroutineScope with a DispatcherProvider . Dispatch defaults to the unconfined property of the DispatcherProvider .",
      "title": "UnconfinedCoroutineScope"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-unconfined-coroutine-scope/#parameters",
      "text": "job - Job to be used for the resulting CoroutineScope . Uses a SupervisorJob if one is not provided. dispatcherProvider - DispatcherProvider to be used for the resulting CoroutineScope . Uses a DefaultDispatcherProvider if one is not provided. See Also CoroutineScope fun UnconfinedCoroutineScope(coroutineContext: CoroutineContext ): UnconfinedCoroutineScope (source) Factory function for a UnconfinedCoroutineScope with a DispatcherProvider . Dispatch defaults to the unconfined property of the DispatcherProvider .",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-unconfined-coroutine-scope/#parameters_1",
      "text": "coroutineContext - CoroutineContext to be used for the resulting CoroutineScope . Any existing ContinuationInterceptor will be overwritten. If the CoroutineContext does not already contain a DispatcherProvider , a DefaultDispatcherProvider will be added. See Also CoroutineScope",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/with-default/",
      "text": "dispatch-core / dispatch.core / withDefault withDefault suspend fun T withDefault(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope .() - T): T (source) Calls the specified suspending block with a given coroutine context, suspends until it completes, and returns the result. Extracts the DispatcherProvider from the coroutineContext of the current coroutine, then uses its default CoroutineDispatcher property to call withContext(theDispatcher) , and returns the result. The default property always corresponds to the DispatcherProvider of the current coroutine. runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread withDefault { dispatcherName() shouldBe default } } See Also withContext",
      "title": "With default"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/with-default/#withdefault",
      "text": "suspend fun T withDefault(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope .() - T): T (source) Calls the specified suspending block with a given coroutine context, suspends until it completes, and returns the result. Extracts the DispatcherProvider from the coroutineContext of the current coroutine, then uses its default CoroutineDispatcher property to call withContext(theDispatcher) , and returns the result. The default property always corresponds to the DispatcherProvider of the current coroutine. runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread withDefault { dispatcherName() shouldBe default } } See Also withContext",
      "title": "withDefault"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/with-i-o/",
      "text": "dispatch-core / dispatch.core / withIO withIO suspend fun T withIO(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope .() - T): T (source) Calls the specified suspending block with a given coroutine context, suspends until it completes, and returns the result. Extracts the DispatcherProvider from the coroutineContext of the current coroutine, then uses its io CoroutineDispatcher property to call withContext(theDispatcher) , and returns the result. The io property always corresponds to the DispatcherProvider of the current coroutine. runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread withIO { dispatcherName() shouldBe io } } See Also withContext",
      "title": "With i o"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/with-i-o/#withio",
      "text": "suspend fun T withIO(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope .() - T): T (source) Calls the specified suspending block with a given coroutine context, suspends until it completes, and returns the result. Extracts the DispatcherProvider from the coroutineContext of the current coroutine, then uses its io CoroutineDispatcher property to call withContext(theDispatcher) , and returns the result. The io property always corresponds to the DispatcherProvider of the current coroutine. runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread withIO { dispatcherName() shouldBe io } } See Also withContext",
      "title": "withIO"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/with-main-immediate/",
      "text": "dispatch-core / dispatch.core / withMainImmediate withMainImmediate suspend fun T withMainImmediate(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope .() - T): T (source) Calls the specified suspending block with a given coroutine context, suspends until it completes, and returns the result. Extracts the DispatcherProvider from the coroutineContext of the current coroutine, then uses its mainImmediate CoroutineDispatcher property to call withContext(theDispatcher) , and returns the result. The mainImmediate property always corresponds to the DispatcherProvider of the current coroutine. runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread withMainImmediate { dispatcherName() shouldBe main immediate } } See Also withContext",
      "title": "With main immediate"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/with-main-immediate/#withmainimmediate",
      "text": "suspend fun T withMainImmediate(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope .() - T): T (source) Calls the specified suspending block with a given coroutine context, suspends until it completes, and returns the result. Extracts the DispatcherProvider from the coroutineContext of the current coroutine, then uses its mainImmediate CoroutineDispatcher property to call withContext(theDispatcher) , and returns the result. The mainImmediate property always corresponds to the DispatcherProvider of the current coroutine. runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread withMainImmediate { dispatcherName() shouldBe main immediate } } See Also withContext",
      "title": "withMainImmediate"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/with-main/",
      "text": "dispatch-core / dispatch.core / withMain withMain suspend fun T withMain(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope .() - T): T (source) Calls the specified suspending block with a given coroutine context, suspends until it completes, and returns the result. Extracts the DispatcherProvider from the coroutineContext of the current coroutine, then uses its main CoroutineDispatcher property to call withContext(theDispatcher) , and returns the result. The main property always corresponds to the DispatcherProvider of the current coroutine. runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread withMain { dispatcherName() shouldBe main } } See Also withContext",
      "title": "With main"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/with-main/#withmain",
      "text": "suspend fun T withMain(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope .() - T): T (source) Calls the specified suspending block with a given coroutine context, suspends until it completes, and returns the result. Extracts the DispatcherProvider from the coroutineContext of the current coroutine, then uses its main CoroutineDispatcher property to call withContext(theDispatcher) , and returns the result. The main property always corresponds to the DispatcherProvider of the current coroutine. runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread withMain { dispatcherName() shouldBe main } } See Also withContext",
      "title": "withMain"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/with-unconfined/",
      "text": "dispatch-core / dispatch.core / withUnconfined withUnconfined suspend fun T withUnconfined(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope .() - T): T (source) Calls the specified suspending block with a given coroutine context, suspends until it completes, and returns the result. Extracts the DispatcherProvider from the coroutineContext of the current coroutine, then uses its unconfined CoroutineDispatcher property to call withContext(theDispatcher) , and returns the result. The unconfined property always corresponds to the DispatcherProvider of the current coroutine. runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread withUnconfined { dispatcherName() shouldBe unconfined } } See Also withContext",
      "title": "With unconfined"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/with-unconfined/#withunconfined",
      "text": "suspend fun T withUnconfined(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope .() - T): T (source) Calls the specified suspending block with a given coroutine context, suspends until it completes, and returns the result. Extracts the DispatcherProvider from the coroutineContext of the current coroutine, then uses its unconfined CoroutineDispatcher property to call withContext(theDispatcher) , and returns the result. The unconfined property always corresponds to the DispatcherProvider of the current coroutine. runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread withUnconfined { dispatcherName() shouldBe unconfined } } See Also withContext",
      "title": "withUnconfined"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-default-dispatcher-provider/",
      "text": "dispatch-core / dispatch.core / DefaultDispatcherProvider DefaultDispatcherProvider class DefaultDispatcherProvider : DispatcherProvider (source) Default implementation of DispatcherProvider which simply delegates to the corresponding properties in the Dispatchers singleton. This should be suitable for most production code. Constructors Name Summary init Default implementation of DispatcherProvider which simply delegates to the corresponding properties in the Dispatchers singleton. DefaultDispatcherProvider() Properties Name Summary default CoroutineDispatcher generally intended for cpu-bound tasks. val default: CoroutineDispatcher io CoroutineDispatcher generally intended for blocking I/O tasks. val io: CoroutineDispatcher main CoroutineDispatcher which is confined to the \"main\" thread. val main: CoroutineDispatcher mainImmediate CoroutineDispatcher which is confined to the \"main\" thread with immediate dispatch. val mainImmediate: CoroutineDispatcher unconfined CoroutineDispatcher which is unconfined. val unconfined: CoroutineDispatcher",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-default-dispatcher-provider/#defaultdispatcherprovider",
      "text": "class DefaultDispatcherProvider : DispatcherProvider (source) Default implementation of DispatcherProvider which simply delegates to the corresponding properties in the Dispatchers singleton. This should be suitable for most production code.",
      "title": "DefaultDispatcherProvider"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-default-dispatcher-provider/#constructors",
      "text": "Name Summary init Default implementation of DispatcherProvider which simply delegates to the corresponding properties in the Dispatchers singleton. DefaultDispatcherProvider()",
      "title": "Constructors"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-default-dispatcher-provider/#properties",
      "text": "Name Summary default CoroutineDispatcher generally intended for cpu-bound tasks. val default: CoroutineDispatcher io CoroutineDispatcher generally intended for blocking I/O tasks. val io: CoroutineDispatcher main CoroutineDispatcher which is confined to the \"main\" thread. val main: CoroutineDispatcher mainImmediate CoroutineDispatcher which is confined to the \"main\" thread with immediate dispatch. val mainImmediate: CoroutineDispatcher unconfined CoroutineDispatcher which is unconfined. val unconfined: CoroutineDispatcher",
      "title": "Properties"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-default-dispatcher-provider/-init-/",
      "text": "dispatch-core / dispatch.core / DefaultDispatcherProvider / init init DefaultDispatcherProvider() Default implementation of DispatcherProvider which simply delegates to the corresponding properties in the Dispatchers singleton. This should be suitable for most production code.",
      "title": " init "
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-default-dispatcher-provider/-init-/#init",
      "text": "DefaultDispatcherProvider() Default implementation of DispatcherProvider which simply delegates to the corresponding properties in the Dispatchers singleton. This should be suitable for most production code.",
      "title": "&lt;init&gt;"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-default-dispatcher-provider/default/",
      "text": "dispatch-core / dispatch.core / DefaultDispatcherProvider / default default val default: CoroutineDispatcher (source) CoroutineDispatcher generally intended for cpu-bound tasks. Corresponds to the Dispatchers.Default property in a default implementation. See Also Dispatchers.Default",
      "title": "Default"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-default-dispatcher-provider/default/#default",
      "text": "val default: CoroutineDispatcher (source) CoroutineDispatcher generally intended for cpu-bound tasks. Corresponds to the Dispatchers.Default property in a default implementation. See Also Dispatchers.Default",
      "title": "default"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-default-dispatcher-provider/io/",
      "text": "dispatch-core / dispatch.core / DefaultDispatcherProvider / io io val io: CoroutineDispatcher (source) CoroutineDispatcher generally intended for blocking I/O tasks. Corresponds to the Dispatchers.IO property in a default implementation. See Also Dispatchers.IO",
      "title": "Io"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-default-dispatcher-provider/io/#io",
      "text": "val io: CoroutineDispatcher (source) CoroutineDispatcher generally intended for blocking I/O tasks. Corresponds to the Dispatchers.IO property in a default implementation. See Also Dispatchers.IO",
      "title": "io"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-default-dispatcher-provider/main-immediate/",
      "text": "dispatch-core / dispatch.core / DefaultDispatcherProvider / mainImmediate mainImmediate val mainImmediate: CoroutineDispatcher (source) CoroutineDispatcher which is confined to the \"main\" thread with immediate dispatch. Corresponds to the Dispatchers.Main.immediate property in a default implementation. See Also MainCoroutineDispatcher.immediate",
      "title": "Main immediate"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-default-dispatcher-provider/main-immediate/#mainimmediate",
      "text": "val mainImmediate: CoroutineDispatcher (source) CoroutineDispatcher which is confined to the \"main\" thread with immediate dispatch. Corresponds to the Dispatchers.Main.immediate property in a default implementation. See Also MainCoroutineDispatcher.immediate",
      "title": "mainImmediate"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-default-dispatcher-provider/main/",
      "text": "dispatch-core / dispatch.core / DefaultDispatcherProvider / main main val main: CoroutineDispatcher (source) CoroutineDispatcher which is confined to the \"main\" thread. Corresponds to the Dispatchers.Main property in a default implementation. See Also Dispatchers.Main",
      "title": "Main"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-default-dispatcher-provider/main/#main",
      "text": "val main: CoroutineDispatcher (source) CoroutineDispatcher which is confined to the \"main\" thread. Corresponds to the Dispatchers.Main property in a default implementation. See Also Dispatchers.Main",
      "title": "main"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-default-dispatcher-provider/unconfined/",
      "text": "dispatch-core / dispatch.core / DefaultDispatcherProvider / unconfined unconfined val unconfined: CoroutineDispatcher (source) CoroutineDispatcher which is unconfined. Corresponds to the Dispatchers.Unconfined property in a default implementation. See Also Dispatchers.Unconfined",
      "title": "Unconfined"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-default-dispatcher-provider/unconfined/#unconfined",
      "text": "val unconfined: CoroutineDispatcher (source) CoroutineDispatcher which is unconfined. Corresponds to the Dispatchers.Unconfined property in a default implementation. See Also Dispatchers.Unconfined",
      "title": "unconfined"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-dispatcher-provider/",
      "text": "dispatch-core / dispatch.core / DispatcherProvider DispatcherProvider interface DispatcherProvider : Element (source) Interface corresponding to the different CoroutineDispatcher 's offered by Dispatchers . Implements the CoroutineContext.Element interface so that it can be embedded into the CoroutineContext map, meaning that a CoroutineContext can be composed with a set of pre-set dispatchers, thereby eliminating the need for singleton references or dependency injecting this interface. Types Name Summary Key Unique Key definition which allows the DispatcherProvider to be stored in the CoroutineContext . companion object Key : Key DispatcherProvider Properties Name Summary default CoroutineDispatcher generally intended for cpu-bound tasks. abstract val default: CoroutineDispatcher io CoroutineDispatcher generally intended for blocking I/O tasks. abstract val io: CoroutineDispatcher key This unique Key property is what allows the DispatcherProvider to be stored in the CoroutineContext . open val key: Key * main CoroutineDispatcher which is confined to the \"main\" thread. abstract val main: CoroutineDispatcher mainImmediate CoroutineDispatcher which is confined to the \"main\" thread with immediate dispatch. abstract val mainImmediate: CoroutineDispatcher unconfined CoroutineDispatcher which is unconfined. abstract val unconfined: CoroutineDispatcher Inheritors Name Summary DefaultDispatcherProvider Default implementation of DispatcherProvider which simply delegates to the corresponding properties in the Dispatchers singleton. class DefaultDispatcherProvider : DispatcherProvider",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-dispatcher-provider/#dispatcherprovider",
      "text": "interface DispatcherProvider : Element (source) Interface corresponding to the different CoroutineDispatcher 's offered by Dispatchers . Implements the CoroutineContext.Element interface so that it can be embedded into the CoroutineContext map, meaning that a CoroutineContext can be composed with a set of pre-set dispatchers, thereby eliminating the need for singleton references or dependency injecting this interface.",
      "title": "DispatcherProvider"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-dispatcher-provider/#types",
      "text": "Name Summary Key Unique Key definition which allows the DispatcherProvider to be stored in the CoroutineContext . companion object Key : Key DispatcherProvider",
      "title": "Types"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-dispatcher-provider/#properties",
      "text": "Name Summary default CoroutineDispatcher generally intended for cpu-bound tasks. abstract val default: CoroutineDispatcher io CoroutineDispatcher generally intended for blocking I/O tasks. abstract val io: CoroutineDispatcher key This unique Key property is what allows the DispatcherProvider to be stored in the CoroutineContext . open val key: Key * main CoroutineDispatcher which is confined to the \"main\" thread. abstract val main: CoroutineDispatcher mainImmediate CoroutineDispatcher which is confined to the \"main\" thread with immediate dispatch. abstract val mainImmediate: CoroutineDispatcher unconfined CoroutineDispatcher which is unconfined. abstract val unconfined: CoroutineDispatcher",
      "title": "Properties"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-dispatcher-provider/#inheritors",
      "text": "Name Summary DefaultDispatcherProvider Default implementation of DispatcherProvider which simply delegates to the corresponding properties in the Dispatchers singleton. class DefaultDispatcherProvider : DispatcherProvider",
      "title": "Inheritors"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-dispatcher-provider/-key/",
      "text": "dispatch-core / dispatch.core / DispatcherProvider / Key Key companion object Key : Key DispatcherProvider (source) Unique Key definition which allows the DispatcherProvider to be stored in the CoroutineContext .",
      "title": " key"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-dispatcher-provider/-key/#key",
      "text": "companion object Key : Key DispatcherProvider (source) Unique Key definition which allows the DispatcherProvider to be stored in the CoroutineContext .",
      "title": "Key"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-dispatcher-provider/default/",
      "text": "dispatch-core / dispatch.core / DispatcherProvider / default default abstract val default: CoroutineDispatcher (source) CoroutineDispatcher generally intended for cpu-bound tasks. Corresponds to the Dispatchers.Default property in a default implementation. See Also Dispatchers.Default",
      "title": "Default"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-dispatcher-provider/default/#default",
      "text": "abstract val default: CoroutineDispatcher (source) CoroutineDispatcher generally intended for cpu-bound tasks. Corresponds to the Dispatchers.Default property in a default implementation. See Also Dispatchers.Default",
      "title": "default"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-dispatcher-provider/io/",
      "text": "dispatch-core / dispatch.core / DispatcherProvider / io io abstract val io: CoroutineDispatcher (source) CoroutineDispatcher generally intended for blocking I/O tasks. Corresponds to the Dispatchers.IO property in a default implementation. See Also Dispatchers.IO",
      "title": "Io"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-dispatcher-provider/io/#io",
      "text": "abstract val io: CoroutineDispatcher (source) CoroutineDispatcher generally intended for blocking I/O tasks. Corresponds to the Dispatchers.IO property in a default implementation. See Also Dispatchers.IO",
      "title": "io"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-dispatcher-provider/key/",
      "text": "dispatch-core / dispatch.core / DispatcherProvider / key key open val key: Key * (source) This unique Key property is what allows the DispatcherProvider to be stored in the CoroutineContext .",
      "title": "Key"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-dispatcher-provider/key/#key",
      "text": "open val key: Key * (source) This unique Key property is what allows the DispatcherProvider to be stored in the CoroutineContext .",
      "title": "key"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-dispatcher-provider/main-immediate/",
      "text": "dispatch-core / dispatch.core / DispatcherProvider / mainImmediate mainImmediate abstract val mainImmediate: CoroutineDispatcher (source) CoroutineDispatcher which is confined to the \"main\" thread with immediate dispatch. Corresponds to the Dispatchers.Main.immediate property in a default implementation. See Also MainCoroutineDispatcher.immediate",
      "title": "Main immediate"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-dispatcher-provider/main-immediate/#mainimmediate",
      "text": "abstract val mainImmediate: CoroutineDispatcher (source) CoroutineDispatcher which is confined to the \"main\" thread with immediate dispatch. Corresponds to the Dispatchers.Main.immediate property in a default implementation. See Also MainCoroutineDispatcher.immediate",
      "title": "mainImmediate"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-dispatcher-provider/main/",
      "text": "dispatch-core / dispatch.core / DispatcherProvider / main main abstract val main: CoroutineDispatcher (source) CoroutineDispatcher which is confined to the \"main\" thread. Corresponds to the Dispatchers.Main property in a default implementation. See Also Dispatchers.Main",
      "title": "Main"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-dispatcher-provider/main/#main",
      "text": "abstract val main: CoroutineDispatcher (source) CoroutineDispatcher which is confined to the \"main\" thread. Corresponds to the Dispatchers.Main property in a default implementation. See Also Dispatchers.Main",
      "title": "main"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-dispatcher-provider/unconfined/",
      "text": "dispatch-core / dispatch.core / DispatcherProvider / unconfined unconfined abstract val unconfined: CoroutineDispatcher (source) CoroutineDispatcher which is unconfined. Corresponds to the Dispatchers.Unconfined property in a default implementation. See Also Dispatchers.Unconfined",
      "title": "Unconfined"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/-dispatcher-provider/unconfined/#unconfined",
      "text": "abstract val unconfined: CoroutineDispatcher (source) CoroutineDispatcher which is unconfined. Corresponds to the Dispatchers.Unconfined property in a default implementation. See Also Dispatchers.Unconfined",
      "title": "unconfined"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlin.coroutines.-coroutine-context/",
      "text": "dispatch-core / dispatch.core / kotlin.coroutines.CoroutineContext Extensions for kotlin.coroutines.CoroutineContext Name Summary dispatcherProvider Extracts the DispatcherProvider out of the CoroutineContext , or returns a new instance of a DefaultDispatcherProvider if the CoroutineContext does not have one specified. val CoroutineContext .dispatcherProvider: DispatcherProvider",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlin.coroutines.-coroutine-context/#extensions-for-kotlincoroutinescoroutinecontext",
      "text": "Name Summary dispatcherProvider Extracts the DispatcherProvider out of the CoroutineContext , or returns a new instance of a DefaultDispatcherProvider if the CoroutineContext does not have one specified. val CoroutineContext .dispatcherProvider: DispatcherProvider",
      "title": "Extensions for kotlin.coroutines.CoroutineContext"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlin.coroutines.-coroutine-context/dispatcher-provider/",
      "text": "dispatch-core / dispatch.core / kotlin.coroutines.CoroutineContext / dispatcherProvider dispatcherProvider val CoroutineContext .dispatcherProvider: DispatcherProvider (source) Extracts the DispatcherProvider out of the CoroutineContext , or returns a new instance of a DefaultDispatcherProvider if the CoroutineContext does not have one specified. Note that CoroutineContext is immutable, so if a new DefaultDispatcherProvider is needed, a new instance will be created each time.",
      "title": "Dispatcher provider"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlin.coroutines.-coroutine-context/dispatcher-provider/#dispatcherprovider",
      "text": "val CoroutineContext .dispatcherProvider: DispatcherProvider (source) Extracts the DispatcherProvider out of the CoroutineContext , or returns a new instance of a DefaultDispatcherProvider if the CoroutineContext does not have one specified. Note that CoroutineContext is immutable, so if a new DefaultDispatcherProvider is needed, a new instance will be created each time.",
      "title": "dispatcherProvider"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/",
      "text": "dispatch-core / dispatch.core / kotlinx.coroutines.CoroutineScope Extensions for kotlinx.coroutines.CoroutineScope Name Summary asyncDefault Creates a coroutine and returns its future result as an implementation of Deferred . fun T CoroutineScope .asyncDefault(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - T): Deferred T asyncIO Creates a coroutine and returns its future result as an implementation of Deferred . fun T CoroutineScope .asyncIO(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - T): Deferred T asyncMain Creates a coroutine and returns its future result as an implementation of Deferred . fun T CoroutineScope .asyncMain(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - T): Deferred T asyncMainImmediate Creates a coroutine and returns its future result as an implementation of Deferred . fun T CoroutineScope .asyncMainImmediate(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - T): Deferred T asyncUnconfined Creates a coroutine and returns its future result as an implementation of Deferred . fun T CoroutineScope .asyncUnconfined(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - T): Deferred T defaultDispatcher Extracts the default CoroutineDispatcher out of the CoroutineScope , creating a new instance of a DefaultDispatcherProvider to provide one if necessary. val CoroutineScope .defaultDispatcher: CoroutineDispatcher dispatcherProvider Extracts the DispatcherProvider out of the CoroutineScope , or returns a new instance of a DefaultDispatcherProvider if the coroutineContext does not have one specified. val CoroutineScope .dispatcherProvider: DispatcherProvider ioDispatcher Extracts the io CoroutineDispatcher out of the CoroutineScope , creating a new instance of a DefaultDispatcherProvider to provide one if necessary. val CoroutineScope .ioDispatcher: CoroutineDispatcher launchDefault Launches a new coroutine without blocking the current thread and returns a reference to the coroutine as a Job . The coroutine is cancelled when the resulting job is cancelled . fun CoroutineScope .launchDefault(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - Unit ): Job launchIO Launches a new coroutine without blocking the current thread and returns a reference to the coroutine as a Job . The coroutine is cancelled when the resulting job is cancelled . fun CoroutineScope .launchIO(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - Unit ): Job launchMain Launches a new coroutine without blocking the current thread and returns a reference to the coroutine as a Job . The coroutine is cancelled when the resulting job is cancelled . fun CoroutineScope .launchMain(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - Unit ): Job launchMainImmediate Launches a new coroutine without blocking the current thread and returns a reference to the coroutine as a Job . The coroutine is cancelled when the resulting job is cancelled . fun CoroutineScope .launchMainImmediate(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - Unit ): Job launchUnconfined Launches a new coroutine without blocking the current thread and returns a reference to the coroutine as a Job . The coroutine is cancelled when the resulting job is cancelled . fun CoroutineScope .launchUnconfined(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - Unit ): Job mainDispatcher Extracts the main CoroutineDispatcher out of the CoroutineScope , creating a new instance of a DefaultDispatcherProvider to provide one if necessary. val CoroutineScope .mainDispatcher: CoroutineDispatcher mainImmediateDispatcher Extracts the mainImmediate CoroutineDispatcher out of the CoroutineScope , creating a new instance of a DefaultDispatcherProvider to provide one if necessary. val CoroutineScope .mainImmediateDispatcher: CoroutineDispatcher unconfinedDispatcher Extracts the unconfined CoroutineDispatcher out of the CoroutineScope , creating a new instance of a DefaultDispatcherProvider to provide one if necessary. val CoroutineScope .unconfinedDispatcher: CoroutineDispatcher",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/#extensions-for-kotlinxcoroutinescoroutinescope",
      "text": "Name Summary asyncDefault Creates a coroutine and returns its future result as an implementation of Deferred . fun T CoroutineScope .asyncDefault(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - T): Deferred T asyncIO Creates a coroutine and returns its future result as an implementation of Deferred . fun T CoroutineScope .asyncIO(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - T): Deferred T asyncMain Creates a coroutine and returns its future result as an implementation of Deferred . fun T CoroutineScope .asyncMain(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - T): Deferred T asyncMainImmediate Creates a coroutine and returns its future result as an implementation of Deferred . fun T CoroutineScope .asyncMainImmediate(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - T): Deferred T asyncUnconfined Creates a coroutine and returns its future result as an implementation of Deferred . fun T CoroutineScope .asyncUnconfined(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - T): Deferred T defaultDispatcher Extracts the default CoroutineDispatcher out of the CoroutineScope , creating a new instance of a DefaultDispatcherProvider to provide one if necessary. val CoroutineScope .defaultDispatcher: CoroutineDispatcher dispatcherProvider Extracts the DispatcherProvider out of the CoroutineScope , or returns a new instance of a DefaultDispatcherProvider if the coroutineContext does not have one specified. val CoroutineScope .dispatcherProvider: DispatcherProvider ioDispatcher Extracts the io CoroutineDispatcher out of the CoroutineScope , creating a new instance of a DefaultDispatcherProvider to provide one if necessary. val CoroutineScope .ioDispatcher: CoroutineDispatcher launchDefault Launches a new coroutine without blocking the current thread and returns a reference to the coroutine as a Job . The coroutine is cancelled when the resulting job is cancelled . fun CoroutineScope .launchDefault(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - Unit ): Job launchIO Launches a new coroutine without blocking the current thread and returns a reference to the coroutine as a Job . The coroutine is cancelled when the resulting job is cancelled . fun CoroutineScope .launchIO(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - Unit ): Job launchMain Launches a new coroutine without blocking the current thread and returns a reference to the coroutine as a Job . The coroutine is cancelled when the resulting job is cancelled . fun CoroutineScope .launchMain(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - Unit ): Job launchMainImmediate Launches a new coroutine without blocking the current thread and returns a reference to the coroutine as a Job . The coroutine is cancelled when the resulting job is cancelled . fun CoroutineScope .launchMainImmediate(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - Unit ): Job launchUnconfined Launches a new coroutine without blocking the current thread and returns a reference to the coroutine as a Job . The coroutine is cancelled when the resulting job is cancelled . fun CoroutineScope .launchUnconfined(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - Unit ): Job mainDispatcher Extracts the main CoroutineDispatcher out of the CoroutineScope , creating a new instance of a DefaultDispatcherProvider to provide one if necessary. val CoroutineScope .mainDispatcher: CoroutineDispatcher mainImmediateDispatcher Extracts the mainImmediate CoroutineDispatcher out of the CoroutineScope , creating a new instance of a DefaultDispatcherProvider to provide one if necessary. val CoroutineScope .mainImmediateDispatcher: CoroutineDispatcher unconfinedDispatcher Extracts the unconfined CoroutineDispatcher out of the CoroutineScope , creating a new instance of a DefaultDispatcherProvider to provide one if necessary. val CoroutineScope .unconfinedDispatcher: CoroutineDispatcher",
      "title": "Extensions for kotlinx.coroutines.CoroutineScope"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/async-default/",
      "text": "dispatch-core / dispatch.core / kotlinx.coroutines.CoroutineScope / asyncDefault asyncDefault fun T CoroutineScope .asyncDefault(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - T): Deferred T (source) Creates a coroutine and returns its future result as an implementation of Deferred . Extracts the DispatcherProvider from the CoroutineScope receiver, then uses its default CoroutineDispatcher property ( coroutineContext.dispatcherProvider.default ) to call async(...) . The default property always corresponds to the DispatcherProvider of the current CoroutineScope . runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread asyncDefault { dispatcherName() shouldBe default }.join() } See Also async",
      "title": "Async default"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/async-default/#asyncdefault",
      "text": "fun T CoroutineScope .asyncDefault(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - T): Deferred T (source) Creates a coroutine and returns its future result as an implementation of Deferred . Extracts the DispatcherProvider from the CoroutineScope receiver, then uses its default CoroutineDispatcher property ( coroutineContext.dispatcherProvider.default ) to call async(...) . The default property always corresponds to the DispatcherProvider of the current CoroutineScope . runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread asyncDefault { dispatcherName() shouldBe default }.join() } See Also async",
      "title": "asyncDefault"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/async-i-o/",
      "text": "dispatch-core / dispatch.core / kotlinx.coroutines.CoroutineScope / asyncIO asyncIO fun T CoroutineScope .asyncIO(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - T): Deferred T (source) Creates a coroutine and returns its future result as an implementation of Deferred . Extracts the DispatcherProvider from the CoroutineScope receiver, then uses its io CoroutineDispatcher property ( coroutineContext.dispatcherProvider.io ) to call async(...) . The io property always corresponds to the DispatcherProvider of the current CoroutineScope . runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread asyncIO { dispatcherName() shouldBe io }.join() } See Also async",
      "title": "Async i o"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/async-i-o/#asyncio",
      "text": "fun T CoroutineScope .asyncIO(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - T): Deferred T (source) Creates a coroutine and returns its future result as an implementation of Deferred . Extracts the DispatcherProvider from the CoroutineScope receiver, then uses its io CoroutineDispatcher property ( coroutineContext.dispatcherProvider.io ) to call async(...) . The io property always corresponds to the DispatcherProvider of the current CoroutineScope . runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread asyncIO { dispatcherName() shouldBe io }.join() } See Also async",
      "title": "asyncIO"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/async-main-immediate/",
      "text": "dispatch-core / dispatch.core / kotlinx.coroutines.CoroutineScope / asyncMainImmediate asyncMainImmediate fun T CoroutineScope .asyncMainImmediate(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - T): Deferred T (source) Creates a coroutine and returns its future result as an implementation of Deferred . Extracts the DispatcherProvider from the CoroutineScope receiver, then uses its mainImmediate CoroutineDispatcher property ( coroutineContext.dispatcherProvider.mainImmediate ) to call async(...) . The mainImmediate property always corresponds to the DispatcherProvider of the current CoroutineScope . runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread asyncMainImmediate { dispatcherName() shouldBe main immediate }.join() } See Also async",
      "title": "Async main immediate"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/async-main-immediate/#asyncmainimmediate",
      "text": "fun T CoroutineScope .asyncMainImmediate(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - T): Deferred T (source) Creates a coroutine and returns its future result as an implementation of Deferred . Extracts the DispatcherProvider from the CoroutineScope receiver, then uses its mainImmediate CoroutineDispatcher property ( coroutineContext.dispatcherProvider.mainImmediate ) to call async(...) . The mainImmediate property always corresponds to the DispatcherProvider of the current CoroutineScope . runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread asyncMainImmediate { dispatcherName() shouldBe main immediate }.join() } See Also async",
      "title": "asyncMainImmediate"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/async-main/",
      "text": "dispatch-core / dispatch.core / kotlinx.coroutines.CoroutineScope / asyncMain asyncMain fun T CoroutineScope .asyncMain(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - T): Deferred T (source) Creates a coroutine and returns its future result as an implementation of Deferred . Extracts the DispatcherProvider from the CoroutineScope receiver, then uses its main CoroutineDispatcher property ( coroutineContext.dispatcherProvider.main ) to call async(...) . The main property always corresponds to the DispatcherProvider of the current CoroutineScope . runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread asyncMain { dispatcherName() shouldBe main }.join() } See Also async",
      "title": "Async main"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/async-main/#asyncmain",
      "text": "fun T CoroutineScope .asyncMain(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - T): Deferred T (source) Creates a coroutine and returns its future result as an implementation of Deferred . Extracts the DispatcherProvider from the CoroutineScope receiver, then uses its main CoroutineDispatcher property ( coroutineContext.dispatcherProvider.main ) to call async(...) . The main property always corresponds to the DispatcherProvider of the current CoroutineScope . runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread asyncMain { dispatcherName() shouldBe main }.join() } See Also async",
      "title": "asyncMain"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/async-unconfined/",
      "text": "dispatch-core / dispatch.core / kotlinx.coroutines.CoroutineScope / asyncUnconfined asyncUnconfined fun T CoroutineScope .asyncUnconfined(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - T): Deferred T (source) Creates a coroutine and returns its future result as an implementation of Deferred . Extracts the DispatcherProvider from the CoroutineScope receiver, then uses its unconfined CoroutineDispatcher property ( coroutineContext.dispatcherProvider.unconfined ) to call async(...) . The unconfined property always corresponds to the DispatcherProvider of the current CoroutineScope . runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread asyncUnconfined { dispatcherName() shouldBe unconfined }.join() } See Also async",
      "title": "Async unconfined"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/async-unconfined/#asyncunconfined",
      "text": "fun T CoroutineScope .asyncUnconfined(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - T): Deferred T (source) Creates a coroutine and returns its future result as an implementation of Deferred . Extracts the DispatcherProvider from the CoroutineScope receiver, then uses its unconfined CoroutineDispatcher property ( coroutineContext.dispatcherProvider.unconfined ) to call async(...) . The unconfined property always corresponds to the DispatcherProvider of the current CoroutineScope . runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread asyncUnconfined { dispatcherName() shouldBe unconfined }.join() } See Also async",
      "title": "asyncUnconfined"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/default-dispatcher/",
      "text": "dispatch-core / dispatch.core / kotlinx.coroutines.CoroutineScope / defaultDispatcher defaultDispatcher val CoroutineScope .defaultDispatcher: CoroutineDispatcher (source) Extracts the default CoroutineDispatcher out of the CoroutineScope , creating a new instance of a DefaultDispatcherProvider to provide one if necessary. Note that CoroutineContext is immutable, so if a new DefaultDispatcherProvider is needed, a new instance will be created each time.",
      "title": "Default dispatcher"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/default-dispatcher/#defaultdispatcher",
      "text": "val CoroutineScope .defaultDispatcher: CoroutineDispatcher (source) Extracts the default CoroutineDispatcher out of the CoroutineScope , creating a new instance of a DefaultDispatcherProvider to provide one if necessary. Note that CoroutineContext is immutable, so if a new DefaultDispatcherProvider is needed, a new instance will be created each time.",
      "title": "defaultDispatcher"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/dispatcher-provider/",
      "text": "dispatch-core / dispatch.core / kotlinx.coroutines.CoroutineScope / dispatcherProvider dispatcherProvider val CoroutineScope .dispatcherProvider: DispatcherProvider (source) Extracts the DispatcherProvider out of the CoroutineScope , or returns a new instance of a DefaultDispatcherProvider if the coroutineContext does not have one specified. Note that CoroutineContext is immutable, so if a new DefaultDispatcherProvider is needed, a new instance will be created each time.",
      "title": "Dispatcher provider"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/dispatcher-provider/#dispatcherprovider",
      "text": "val CoroutineScope .dispatcherProvider: DispatcherProvider (source) Extracts the DispatcherProvider out of the CoroutineScope , or returns a new instance of a DefaultDispatcherProvider if the coroutineContext does not have one specified. Note that CoroutineContext is immutable, so if a new DefaultDispatcherProvider is needed, a new instance will be created each time.",
      "title": "dispatcherProvider"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/io-dispatcher/",
      "text": "dispatch-core / dispatch.core / kotlinx.coroutines.CoroutineScope / ioDispatcher ioDispatcher val CoroutineScope .ioDispatcher: CoroutineDispatcher (source) Extracts the io CoroutineDispatcher out of the CoroutineScope , creating a new instance of a DefaultDispatcherProvider to provide one if necessary. Note that CoroutineContext is immutable, so if a new DefaultDispatcherProvider is needed, a new instance will be created each time.",
      "title": "Io dispatcher"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/io-dispatcher/#iodispatcher",
      "text": "val CoroutineScope .ioDispatcher: CoroutineDispatcher (source) Extracts the io CoroutineDispatcher out of the CoroutineScope , creating a new instance of a DefaultDispatcherProvider to provide one if necessary. Note that CoroutineContext is immutable, so if a new DefaultDispatcherProvider is needed, a new instance will be created each time.",
      "title": "ioDispatcher"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/launch-default/",
      "text": "dispatch-core / dispatch.core / kotlinx.coroutines.CoroutineScope / launchDefault launchDefault fun CoroutineScope .launchDefault(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - Unit ): Job (source) Launches a new coroutine without blocking the current thread and returns a reference to the coroutine as a Job . The coroutine is cancelled when the resulting job is cancelled . Extracts the DispatcherProvider from the CoroutineScope receiver, then uses its default CoroutineDispatcher property ( coroutineContext.dispatcherProvider.default ) to call launch(...) . The default property always corresponds to the DispatcherProvider of the current CoroutineScope . runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread launchDefault { dispatcherName() shouldBe default }.join() } See Also launch",
      "title": "Launch default"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/launch-default/#launchdefault",
      "text": "fun CoroutineScope .launchDefault(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - Unit ): Job (source) Launches a new coroutine without blocking the current thread and returns a reference to the coroutine as a Job . The coroutine is cancelled when the resulting job is cancelled . Extracts the DispatcherProvider from the CoroutineScope receiver, then uses its default CoroutineDispatcher property ( coroutineContext.dispatcherProvider.default ) to call launch(...) . The default property always corresponds to the DispatcherProvider of the current CoroutineScope . runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread launchDefault { dispatcherName() shouldBe default }.join() } See Also launch",
      "title": "launchDefault"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/launch-i-o/",
      "text": "dispatch-core / dispatch.core / kotlinx.coroutines.CoroutineScope / launchIO launchIO fun CoroutineScope .launchIO(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - Unit ): Job (source) Launches a new coroutine without blocking the current thread and returns a reference to the coroutine as a Job . The coroutine is cancelled when the resulting job is cancelled . Extracts the DispatcherProvider from the CoroutineScope receiver, then uses its io CoroutineDispatcher property ( coroutineContext.dispatcherProvider.io ) to call launch(...) . The io property always corresponds to the DispatcherProvider of the current CoroutineScope . runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread launchIO { dispatcherName() shouldBe io }.join() } See Also launch",
      "title": "Launch i o"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/launch-i-o/#launchio",
      "text": "fun CoroutineScope .launchIO(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - Unit ): Job (source) Launches a new coroutine without blocking the current thread and returns a reference to the coroutine as a Job . The coroutine is cancelled when the resulting job is cancelled . Extracts the DispatcherProvider from the CoroutineScope receiver, then uses its io CoroutineDispatcher property ( coroutineContext.dispatcherProvider.io ) to call launch(...) . The io property always corresponds to the DispatcherProvider of the current CoroutineScope . runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread launchIO { dispatcherName() shouldBe io }.join() } See Also launch",
      "title": "launchIO"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/launch-main-immediate/",
      "text": "dispatch-core / dispatch.core / kotlinx.coroutines.CoroutineScope / launchMainImmediate launchMainImmediate fun CoroutineScope .launchMainImmediate(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - Unit ): Job (source) Launches a new coroutine without blocking the current thread and returns a reference to the coroutine as a Job . The coroutine is cancelled when the resulting job is cancelled . Extracts the DispatcherProvider from the CoroutineScope receiver, then uses its mainImmediate CoroutineDispatcher property ( coroutineContext.dispatcherProvider.mainImmediate ) to call launch(...) . The mainImmediate property always corresponds to the DispatcherProvider of the current CoroutineScope . runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread launchMainImmediate { dispatcherName() shouldBe main immediate }.join() } See Also launch",
      "title": "Launch main immediate"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/launch-main-immediate/#launchmainimmediate",
      "text": "fun CoroutineScope .launchMainImmediate(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - Unit ): Job (source) Launches a new coroutine without blocking the current thread and returns a reference to the coroutine as a Job . The coroutine is cancelled when the resulting job is cancelled . Extracts the DispatcherProvider from the CoroutineScope receiver, then uses its mainImmediate CoroutineDispatcher property ( coroutineContext.dispatcherProvider.mainImmediate ) to call launch(...) . The mainImmediate property always corresponds to the DispatcherProvider of the current CoroutineScope . runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread launchMainImmediate { dispatcherName() shouldBe main immediate }.join() } See Also launch",
      "title": "launchMainImmediate"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/launch-main/",
      "text": "dispatch-core / dispatch.core / kotlinx.coroutines.CoroutineScope / launchMain launchMain fun CoroutineScope .launchMain(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - Unit ): Job (source) Launches a new coroutine without blocking the current thread and returns a reference to the coroutine as a Job . The coroutine is cancelled when the resulting job is cancelled . Extracts the DispatcherProvider from the CoroutineScope receiver, then uses its main CoroutineDispatcher property ( coroutineContext.dispatcherProvider.main ) to call launch(...) . The main property always corresponds to the DispatcherProvider of the current CoroutineScope . runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread launchMain { dispatcherName() shouldBe main }.join() } See Also launch",
      "title": "Launch main"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/launch-main/#launchmain",
      "text": "fun CoroutineScope .launchMain(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - Unit ): Job (source) Launches a new coroutine without blocking the current thread and returns a reference to the coroutine as a Job . The coroutine is cancelled when the resulting job is cancelled . Extracts the DispatcherProvider from the CoroutineScope receiver, then uses its main CoroutineDispatcher property ( coroutineContext.dispatcherProvider.main ) to call launch(...) . The main property always corresponds to the DispatcherProvider of the current CoroutineScope . runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread launchMain { dispatcherName() shouldBe main }.join() } See Also launch",
      "title": "launchMain"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/launch-unconfined/",
      "text": "dispatch-core / dispatch.core / kotlinx.coroutines.CoroutineScope / launchUnconfined launchUnconfined fun CoroutineScope .launchUnconfined(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - Unit ): Job (source) Launches a new coroutine without blocking the current thread and returns a reference to the coroutine as a Job . The coroutine is cancelled when the resulting job is cancelled . Extracts the DispatcherProvider from the CoroutineScope receiver, then uses its unconfined CoroutineDispatcher property ( coroutineContext.dispatcherProvider.unconfined ) to call launch(...) . The unconfined property always corresponds to the DispatcherProvider of the current CoroutineScope . runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread launchUnconfined { dispatcherName() shouldBe unconfined }.join() } See Also launch",
      "title": "Launch unconfined"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/launch-unconfined/#launchunconfined",
      "text": "fun CoroutineScope .launchUnconfined(context: CoroutineContext = EmptyCoroutineContext, start: CoroutineStart = CoroutineStart.DEFAULT, block: suspend CoroutineScope .() - Unit ): Job (source) Launches a new coroutine without blocking the current thread and returns a reference to the coroutine as a Job . The coroutine is cancelled when the resulting job is cancelled . Extracts the DispatcherProvider from the CoroutineScope receiver, then uses its unconfined CoroutineDispatcher property ( coroutineContext.dispatcherProvider.unconfined ) to call launch(...) . The unconfined property always corresponds to the DispatcherProvider of the current CoroutineScope . runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread launchUnconfined { dispatcherName() shouldBe unconfined }.join() } See Also launch",
      "title": "launchUnconfined"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/main-dispatcher/",
      "text": "dispatch-core / dispatch.core / kotlinx.coroutines.CoroutineScope / mainDispatcher mainDispatcher val CoroutineScope .mainDispatcher: CoroutineDispatcher (source) Extracts the main CoroutineDispatcher out of the CoroutineScope , creating a new instance of a DefaultDispatcherProvider to provide one if necessary. Note that CoroutineContext is immutable, so if a new DefaultDispatcherProvider is needed, a new instance will be created each time.",
      "title": "Main dispatcher"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/main-dispatcher/#maindispatcher",
      "text": "val CoroutineScope .mainDispatcher: CoroutineDispatcher (source) Extracts the main CoroutineDispatcher out of the CoroutineScope , creating a new instance of a DefaultDispatcherProvider to provide one if necessary. Note that CoroutineContext is immutable, so if a new DefaultDispatcherProvider is needed, a new instance will be created each time.",
      "title": "mainDispatcher"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/main-immediate-dispatcher/",
      "text": "dispatch-core / dispatch.core / kotlinx.coroutines.CoroutineScope / mainImmediateDispatcher mainImmediateDispatcher val CoroutineScope .mainImmediateDispatcher: CoroutineDispatcher (source) Extracts the mainImmediate CoroutineDispatcher out of the CoroutineScope , creating a new instance of a DefaultDispatcherProvider to provide one if necessary. Note that CoroutineContext is immutable, so if a new DefaultDispatcherProvider is needed, a new instance will be created each time.",
      "title": "Main immediate dispatcher"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/main-immediate-dispatcher/#mainimmediatedispatcher",
      "text": "val CoroutineScope .mainImmediateDispatcher: CoroutineDispatcher (source) Extracts the mainImmediate CoroutineDispatcher out of the CoroutineScope , creating a new instance of a DefaultDispatcherProvider to provide one if necessary. Note that CoroutineContext is immutable, so if a new DefaultDispatcherProvider is needed, a new instance will be created each time.",
      "title": "mainImmediateDispatcher"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/unconfined-dispatcher/",
      "text": "dispatch-core / dispatch.core / kotlinx.coroutines.CoroutineScope / unconfinedDispatcher unconfinedDispatcher val CoroutineScope .unconfinedDispatcher: CoroutineDispatcher (source) Extracts the unconfined CoroutineDispatcher out of the CoroutineScope , creating a new instance of a DefaultDispatcherProvider to provide one if necessary. Note that CoroutineContext is immutable, so if a new DefaultDispatcherProvider is needed, a new instance will be created each time.",
      "title": "Unconfined dispatcher"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.-coroutine-scope/unconfined-dispatcher/#unconfineddispatcher",
      "text": "val CoroutineScope .unconfinedDispatcher: CoroutineDispatcher (source) Extracts the unconfined CoroutineDispatcher out of the CoroutineScope , creating a new instance of a DefaultDispatcherProvider to provide one if necessary. Note that CoroutineContext is immutable, so if a new DefaultDispatcherProvider is needed, a new instance will be created each time.",
      "title": "unconfinedDispatcher"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.flow.-flow/",
      "text": "dispatch-core / dispatch.core / kotlinx.coroutines.flow.Flow Extensions for kotlinx.coroutines.flow.Flow Name Summary flowOnDefault Extracts the DispatcherProvider from the coroutineContext of the collector coroutine, then uses its DispatcherProvider.default property to call flowOn(theDispatcher) , and returns the result. fun T Flow T .flowOnDefault(): Flow T flowOnIO Extracts the DispatcherProvider from the coroutineContext of the collector coroutine, then uses its DispatcherProvider.io property to call flowOn(theDispatcher) , and returns the result. fun T Flow T .flowOnIO(): Flow T flowOnMain Extracts the DispatcherProvider from the coroutineContext of the collector coroutine, then uses its DispatcherProvider.main property to call flowOn(theDispatcher) , and returns the result. fun T Flow T .flowOnMain(): Flow T flowOnMainImmediate Extracts the DispatcherProvider from the coroutineContext of the collector coroutine, then uses its DispatcherProvider.mainImmediate property to call flowOn(theDispatcher) , and returns the result. fun T Flow T .flowOnMainImmediate(): Flow T flowOnUnconfined Extracts the DispatcherProvider from the coroutineContext of the collector coroutine, then uses its DispatcherProvider.unconfined property to call flowOn(theDispatcher) , and returns the result. fun T Flow T .flowOnUnconfined(): Flow T",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.flow.-flow/#extensions-for-kotlinxcoroutinesflowflow",
      "text": "Name Summary flowOnDefault Extracts the DispatcherProvider from the coroutineContext of the collector coroutine, then uses its DispatcherProvider.default property to call flowOn(theDispatcher) , and returns the result. fun T Flow T .flowOnDefault(): Flow T flowOnIO Extracts the DispatcherProvider from the coroutineContext of the collector coroutine, then uses its DispatcherProvider.io property to call flowOn(theDispatcher) , and returns the result. fun T Flow T .flowOnIO(): Flow T flowOnMain Extracts the DispatcherProvider from the coroutineContext of the collector coroutine, then uses its DispatcherProvider.main property to call flowOn(theDispatcher) , and returns the result. fun T Flow T .flowOnMain(): Flow T flowOnMainImmediate Extracts the DispatcherProvider from the coroutineContext of the collector coroutine, then uses its DispatcherProvider.mainImmediate property to call flowOn(theDispatcher) , and returns the result. fun T Flow T .flowOnMainImmediate(): Flow T flowOnUnconfined Extracts the DispatcherProvider from the coroutineContext of the collector coroutine, then uses its DispatcherProvider.unconfined property to call flowOn(theDispatcher) , and returns the result. fun T Flow T .flowOnUnconfined(): Flow T",
      "title": "Extensions for kotlinx.coroutines.flow.Flow"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.flow.-flow/flow-on-default/",
      "text": "dispatch-core / dispatch.core / kotlinx.coroutines.flow.Flow / flowOnDefault flowOnDefault @ExperimentalCoroutinesApi fun T Flow T .flowOnDefault(): Flow T (source) Extracts the DispatcherProvider from the coroutineContext of the collector coroutine, then uses its DispatcherProvider.default property to call flowOn(theDispatcher) , and returns the result. runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread flow { dispatcherName() shouldBe default emit(Unit) }.flowOnDefault() // switch to the default dispatcher for everything upstream .collect() // collect the flow from the main dispatcher } See Also flowOn",
      "title": "Flow on default"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.flow.-flow/flow-on-default/#flowondefault",
      "text": "@ExperimentalCoroutinesApi fun T Flow T .flowOnDefault(): Flow T (source) Extracts the DispatcherProvider from the coroutineContext of the collector coroutine, then uses its DispatcherProvider.default property to call flowOn(theDispatcher) , and returns the result. runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread flow { dispatcherName() shouldBe default emit(Unit) }.flowOnDefault() // switch to the default dispatcher for everything upstream .collect() // collect the flow from the main dispatcher } See Also flowOn",
      "title": "flowOnDefault"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.flow.-flow/flow-on-i-o/",
      "text": "dispatch-core / dispatch.core / kotlinx.coroutines.flow.Flow / flowOnIO flowOnIO @ExperimentalCoroutinesApi fun T Flow T .flowOnIO(): Flow T (source) Extracts the DispatcherProvider from the coroutineContext of the collector coroutine, then uses its DispatcherProvider.io property to call flowOn(theDispatcher) , and returns the result. runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread flow { dispatcherName() shouldBe io emit(Unit) }.flowOnIO() // switch to the io dispatcher for everything upstream .collect() // collect the flow from the main dispatcher } See Also flowOn",
      "title": "Flow on i o"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.flow.-flow/flow-on-i-o/#flowonio",
      "text": "@ExperimentalCoroutinesApi fun T Flow T .flowOnIO(): Flow T (source) Extracts the DispatcherProvider from the coroutineContext of the collector coroutine, then uses its DispatcherProvider.io property to call flowOn(theDispatcher) , and returns the result. runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread flow { dispatcherName() shouldBe io emit(Unit) }.flowOnIO() // switch to the io dispatcher for everything upstream .collect() // collect the flow from the main dispatcher } See Also flowOn",
      "title": "flowOnIO"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.flow.-flow/flow-on-main-immediate/",
      "text": "dispatch-core / dispatch.core / kotlinx.coroutines.flow.Flow / flowOnMainImmediate flowOnMainImmediate @ExperimentalCoroutinesApi fun T Flow T .flowOnMainImmediate(): Flow T (source) Extracts the DispatcherProvider from the coroutineContext of the collector coroutine, then uses its DispatcherProvider.mainImmediate property to call flowOn(theDispatcher) , and returns the result. runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread flow { dispatcherName() shouldBe main immediate emit(Unit) }.flowOnMainImmediate() // switch to the mainImmediate dispatcher for everything upstream .collect() // collect the flow from the main dispatcher } See Also flowOn",
      "title": "Flow on main immediate"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.flow.-flow/flow-on-main-immediate/#flowonmainimmediate",
      "text": "@ExperimentalCoroutinesApi fun T Flow T .flowOnMainImmediate(): Flow T (source) Extracts the DispatcherProvider from the coroutineContext of the collector coroutine, then uses its DispatcherProvider.mainImmediate property to call flowOn(theDispatcher) , and returns the result. runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread flow { dispatcherName() shouldBe main immediate emit(Unit) }.flowOnMainImmediate() // switch to the mainImmediate dispatcher for everything upstream .collect() // collect the flow from the main dispatcher } See Also flowOn",
      "title": "flowOnMainImmediate"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.flow.-flow/flow-on-main/",
      "text": "dispatch-core / dispatch.core / kotlinx.coroutines.flow.Flow / flowOnMain flowOnMain @ExperimentalCoroutinesApi fun T Flow T .flowOnMain(): Flow T (source) Extracts the DispatcherProvider from the coroutineContext of the collector coroutine, then uses its DispatcherProvider.main property to call flowOn(theDispatcher) , and returns the result. runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread flow { dispatcherName() shouldBe main emit(Unit) }.flowOnMain() // switch to the main dispatcher for everything upstream .collect() // collect the flow from the default dispatcher } See Also flowOn",
      "title": "Flow on main"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.flow.-flow/flow-on-main/#flowonmain",
      "text": "@ExperimentalCoroutinesApi fun T Flow T .flowOnMain(): Flow T (source) Extracts the DispatcherProvider from the coroutineContext of the collector coroutine, then uses its DispatcherProvider.main property to call flowOn(theDispatcher) , and returns the result. runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread flow { dispatcherName() shouldBe main emit(Unit) }.flowOnMain() // switch to the main dispatcher for everything upstream .collect() // collect the flow from the default dispatcher } See Also flowOn",
      "title": "flowOnMain"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.flow.-flow/flow-on-unconfined/",
      "text": "dispatch-core / dispatch.core / kotlinx.coroutines.flow.Flow / flowOnUnconfined flowOnUnconfined @ExperimentalCoroutinesApi fun T Flow T .flowOnUnconfined(): Flow T (source) Extracts the DispatcherProvider from the coroutineContext of the collector coroutine, then uses its DispatcherProvider.unconfined property to call flowOn(theDispatcher) , and returns the result. runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread flow { dispatcherName() shouldBe unconfined emit(Unit) }.flowOnUnconfined() // switch to the unconfined dispatcher for everything upstream .collect() // collect the flow from the main dispatcher } See Also flowOn",
      "title": "Flow on unconfined"
    },
    {
      "location": "kdoc/dispatch-core/dispatch.core/kotlinx.coroutines.flow.-flow/flow-on-unconfined/#flowonunconfined",
      "text": "@ExperimentalCoroutinesApi fun T Flow T .flowOnUnconfined(): Flow T (source) Extracts the DispatcherProvider from the coroutineContext of the collector coroutine, then uses its DispatcherProvider.unconfined property to call flowOn(theDispatcher) , and returns the result. runBlocking(someDispatcherProvider) { dispatcherName() shouldBe runBlocking thread flow { dispatcherName() shouldBe unconfined emit(Unit) }.flowOnUnconfined() // switch to the unconfined dispatcher for everything upstream .collect() // collect the flow from the main dispatcher } See Also flowOn",
      "title": "flowOnUnconfined"
    },
    {
      "location": "kdoc/dispatch-detekt/",
      "text": "dispatch-detekt Contents Rules Setup Adding new dependencies Configuration Gradle Daemon bug Rules Name Description AndroidXLifecycleScope Looks for accidental usage of the androidx lifecyclescope extension. HardCodedDispatcher Detects use of a hard-coded reference to the kotlinx.coroutines.Dispatchers singleton. Setup If you don't already have Detekt set up in your project, follow the official quick start guide . After that is working, you need to add dependencies for the Detekt CLI and these extension rules to each module which will be analyzed. The easiest way to do this is to apply them from the root project -level gradle file. Adding new dependencies In root project-level build.gradle or build.gradle.kts : allprojects { dependencies { detekt( io.gitlab.arturbosch.detekt:detekt-cli:1.9.1 ) detektPlugins( com.rickbusarow.dispatch:dispatch-detekt:1.0.0-beta03 ) } } Configuration After adding the dependencies, you'll want to add parameters to your detekt config .yml file. If you don't already have a config file, you can create one by invoking: ./gradlew detektGenerateConfig Then, add the following to the bottom of the detekt-config.yml file: dispatch : active : true # disables all dispatch checks AndroidXLifecycleScope : # incorrect lifecycleScope active : true HardCodedDispatcher : # finds usage of Dispatchers.______ active : true allowDefaultDispatcher : false # if true, Detekt will ignore all usage of Dispatchers.Default allowIODispatcher : false # if true, Detekt will ignore all usage of Dispatchers.IO allowMainDispatcher : false # if true, Detekt will ignore all usage of Dispatchers.Main allowMainImmediateDispatcher : false # if true, Detekt will ignore all usage of Dispatchers.Main.immediate allowUnconfinedDispatcher : false # if true, Detekt will ignore all usage of Dispatchers.Unconfined Gradle Daemon bug There is an issue with ClassLoader caching which may cause issues the first time running Detekt. The workaround is to execute ./gradlew --stop once via command line. You should only ever need to do this one time, if at all. The fix for this has already been merged into Detekt. Packages Name Summary dispatch.detekt.rules Index All Types",
      "title": "dtekt"
    },
    {
      "location": "kdoc/dispatch-detekt/#contents",
      "text": "Rules Setup Adding new dependencies Configuration Gradle Daemon bug",
      "title": "Contents"
    },
    {
      "location": "kdoc/dispatch-detekt/#rules",
      "text": "Name Description AndroidXLifecycleScope Looks for accidental usage of the androidx lifecyclescope extension. HardCodedDispatcher Detects use of a hard-coded reference to the kotlinx.coroutines.Dispatchers singleton.",
      "title": "Rules"
    },
    {
      "location": "kdoc/dispatch-detekt/#setup",
      "text": "If you don't already have Detekt set up in your project, follow the official quick start guide . After that is working, you need to add dependencies for the Detekt CLI and these extension rules to each module which will be analyzed. The easiest way to do this is to apply them from the root project -level gradle file.",
      "title": "Setup"
    },
    {
      "location": "kdoc/dispatch-detekt/#adding-new-dependencies",
      "text": "In root project-level build.gradle or build.gradle.kts : allprojects { dependencies { detekt( io.gitlab.arturbosch.detekt:detekt-cli:1.9.1 ) detektPlugins( com.rickbusarow.dispatch:dispatch-detekt:1.0.0-beta03 ) } }",
      "title": "Adding new dependencies"
    },
    {
      "location": "kdoc/dispatch-detekt/#configuration",
      "text": "After adding the dependencies, you'll want to add parameters to your detekt config .yml file. If you don't already have a config file, you can create one by invoking: ./gradlew detektGenerateConfig Then, add the following to the bottom of the detekt-config.yml file: dispatch : active : true # disables all dispatch checks AndroidXLifecycleScope : # incorrect lifecycleScope active : true HardCodedDispatcher : # finds usage of Dispatchers.______ active : true allowDefaultDispatcher : false # if true, Detekt will ignore all usage of Dispatchers.Default allowIODispatcher : false # if true, Detekt will ignore all usage of Dispatchers.IO allowMainDispatcher : false # if true, Detekt will ignore all usage of Dispatchers.Main allowMainImmediateDispatcher : false # if true, Detekt will ignore all usage of Dispatchers.Main.immediate allowUnconfinedDispatcher : false # if true, Detekt will ignore all usage of Dispatchers.Unconfined",
      "title": "Configuration"
    },
    {
      "location": "kdoc/dispatch-detekt/#gradle-daemon-bug",
      "text": "There is an issue with ClassLoader caching which may cause issues the first time running Detekt. The workaround is to execute ./gradlew --stop once via command line. You should only ever need to do this one time, if at all. The fix for this has already been merged into Detekt.",
      "title": "Gradle Daemon bug"
    },
    {
      "location": "kdoc/dispatch-detekt/#packages",
      "text": "Name Summary dispatch.detekt.rules",
      "title": "Packages"
    },
    {
      "location": "kdoc/dispatch-detekt/#index",
      "text": "All Types",
      "title": "Index"
    },
    {
      "location": "kdoc/dispatch-detekt/alltypes/",
      "text": "Contents All Types Name Summary dispatch.detekt.rules.AndroidXLifecycleScope Detects use of androidx.lifecycle.lifecycleScope , which shares a namespace with dispatch.android.lifecycle.lifecycleScope . | dispatch.detekt.rules.HardCodedDispatcher Detects use of a hard-coded reference to the kotlinx.coroutines.Dispatchers singleton.",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-detekt/alltypes/#contents",
      "text": "",
      "title": "Contents"
    },
    {
      "location": "kdoc/dispatch-detekt/alltypes/#all-types",
      "text": "Name Summary",
      "title": "All Types"
    },
    {
      "location": "kdoc/dispatch-detekt/alltypes/#dispatchdetektrulesandroidxlifecyclescope",
      "text": "Detects use of androidx.lifecycle.lifecycleScope , which shares a namespace with dispatch.android.lifecycle.lifecycleScope . |",
      "title": "dispatch.detekt.rules.AndroidXLifecycleScope"
    },
    {
      "location": "kdoc/dispatch-detekt/alltypes/#dispatchdetektruleshardcodeddispatcher",
      "text": "Detects use of a hard-coded reference to the kotlinx.coroutines.Dispatchers singleton.",
      "title": "dispatch.detekt.rules.HardCodedDispatcher"
    },
    {
      "location": "kdoc/dispatch-detekt/dispatch.detekt.rules/",
      "text": "dispatch-detekt / dispatch.detekt.rules Package dispatch.detekt.rules Types Name Summary AndroidXLifecycleScope Detects use of androidx.lifecycle.lifecycleScope , which shares a namespace with dispatch.android.lifecycle.lifecycleScope . class AndroidXLifecycleScope : Rule HardCodedDispatcher Detects use of a hard-coded reference to the kotlinx.coroutines.Dispatchers singleton. class HardCodedDispatcher : Rule",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-detekt/dispatch.detekt.rules/#package-dispatchdetektrules",
      "text": "",
      "title": "Package dispatch.detekt.rules"
    },
    {
      "location": "kdoc/dispatch-detekt/dispatch.detekt.rules/#types",
      "text": "Name Summary AndroidXLifecycleScope Detects use of androidx.lifecycle.lifecycleScope , which shares a namespace with dispatch.android.lifecycle.lifecycleScope . class AndroidXLifecycleScope : Rule HardCodedDispatcher Detects use of a hard-coded reference to the kotlinx.coroutines.Dispatchers singleton. class HardCodedDispatcher : Rule",
      "title": "Types"
    },
    {
      "location": "kdoc/dispatch-detekt/dispatch.detekt.rules/-android-x-lifecycle-scope/",
      "text": "dispatch-detekt / dispatch.detekt.rules / AndroidXLifecycleScope AndroidXLifecycleScope class AndroidXLifecycleScope : Rule (source) Detects use of androidx.lifecycle.lifecycleScope , which shares a namespace with dispatch.android.lifecycle.lifecycleScope . The AndroidX library uses a hard-coded Dispatchers.Main and does not contain a DispatcherProvider , and also leaks its pausing behavior. Constructors Name Summary init Detects use of androidx.lifecycle.lifecycleScope , which shares a namespace with dispatch.android.lifecycle.lifecycleScope . AndroidXLifecycleScope(config: Config = Config.empty)",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-detekt/dispatch.detekt.rules/-android-x-lifecycle-scope/#androidxlifecyclescope",
      "text": "class AndroidXLifecycleScope : Rule (source) Detects use of androidx.lifecycle.lifecycleScope , which shares a namespace with dispatch.android.lifecycle.lifecycleScope . The AndroidX library uses a hard-coded Dispatchers.Main and does not contain a DispatcherProvider , and also leaks its pausing behavior.",
      "title": "AndroidXLifecycleScope"
    },
    {
      "location": "kdoc/dispatch-detekt/dispatch.detekt.rules/-android-x-lifecycle-scope/#constructors",
      "text": "Name Summary init Detects use of androidx.lifecycle.lifecycleScope , which shares a namespace with dispatch.android.lifecycle.lifecycleScope . AndroidXLifecycleScope(config: Config = Config.empty)",
      "title": "Constructors"
    },
    {
      "location": "kdoc/dispatch-detekt/dispatch.detekt.rules/-android-x-lifecycle-scope/-init-/",
      "text": "dispatch-detekt / dispatch.detekt.rules / AndroidXLifecycleScope / init init AndroidXLifecycleScope(config: Config = Config.empty) Detects use of androidx.lifecycle.lifecycleScope , which shares a namespace with dispatch.android.lifecycle.lifecycleScope . The AndroidX library uses a hard-coded Dispatchers.Main and does not contain a DispatcherProvider , and also leaks its pausing behavior.",
      "title": " init "
    },
    {
      "location": "kdoc/dispatch-detekt/dispatch.detekt.rules/-android-x-lifecycle-scope/-init-/#init",
      "text": "AndroidXLifecycleScope(config: Config = Config.empty) Detects use of androidx.lifecycle.lifecycleScope , which shares a namespace with dispatch.android.lifecycle.lifecycleScope . The AndroidX library uses a hard-coded Dispatchers.Main and does not contain a DispatcherProvider , and also leaks its pausing behavior.",
      "title": "&lt;init&gt;"
    },
    {
      "location": "kdoc/dispatch-detekt/dispatch.detekt.rules/-hard-coded-dispatcher/",
      "text": "dispatch-detekt / dispatch.detekt.rules / HardCodedDispatcher HardCodedDispatcher class HardCodedDispatcher : Rule (source) Detects use of a hard-coded reference to the kotlinx.coroutines.Dispatchers singleton. The CoroutineDispatcher 's in this singleton do not contain a DispatcherProvider , so they're unaffected by this library. Config allowDefaultDispatcher allowIODispatcher allowMainDispatcher allowMainImmediateDispatcher allowUnconfinedDispatcher Constructors Name Summary init Detects use of a hard-coded reference to the kotlinx.coroutines.Dispatchers singleton. HardCodedDispatcher(config: Config = Config.empty)",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-detekt/dispatch.detekt.rules/-hard-coded-dispatcher/#hardcodeddispatcher",
      "text": "class HardCodedDispatcher : Rule (source) Detects use of a hard-coded reference to the kotlinx.coroutines.Dispatchers singleton. The CoroutineDispatcher 's in this singleton do not contain a DispatcherProvider , so they're unaffected by this library.",
      "title": "HardCodedDispatcher"
    },
    {
      "location": "kdoc/dispatch-detekt/dispatch.detekt.rules/-hard-coded-dispatcher/#config",
      "text": "allowDefaultDispatcher allowIODispatcher allowMainDispatcher allowMainImmediateDispatcher allowUnconfinedDispatcher",
      "title": "Config"
    },
    {
      "location": "kdoc/dispatch-detekt/dispatch.detekt.rules/-hard-coded-dispatcher/#constructors",
      "text": "Name Summary init Detects use of a hard-coded reference to the kotlinx.coroutines.Dispatchers singleton. HardCodedDispatcher(config: Config = Config.empty)",
      "title": "Constructors"
    },
    {
      "location": "kdoc/dispatch-detekt/dispatch.detekt.rules/-hard-coded-dispatcher/-init-/",
      "text": "dispatch-detekt / dispatch.detekt.rules / HardCodedDispatcher / init init HardCodedDispatcher(config: Config = Config.empty) Detects use of a hard-coded reference to the kotlinx.coroutines.Dispatchers singleton. The CoroutineDispatcher 's in this singleton do not contain a DispatcherProvider , so they're unaffected by this library. Config allowDefaultDispatcher allowIODispatcher allowMainDispatcher allowMainImmediateDispatcher allowUnconfinedDispatcher",
      "title": " init "
    },
    {
      "location": "kdoc/dispatch-detekt/dispatch.detekt.rules/-hard-coded-dispatcher/-init-/#init",
      "text": "HardCodedDispatcher(config: Config = Config.empty) Detects use of a hard-coded reference to the kotlinx.coroutines.Dispatchers singleton. The CoroutineDispatcher 's in this singleton do not contain a DispatcherProvider , so they're unaffected by this library.",
      "title": "&lt;init&gt;"
    },
    {
      "location": "kdoc/dispatch-detekt/dispatch.detekt.rules/-hard-coded-dispatcher/-init-/#config",
      "text": "allowDefaultDispatcher allowIODispatcher allowMainDispatcher allowMainImmediateDispatcher allowUnconfinedDispatcher",
      "title": "Config"
    },
    {
      "location": "kdoc/dispatch-test/",
      "text": "dispatch-test Packages Name Summary dispatch.test Index All Types",
      "title": "test-core"
    },
    {
      "location": "kdoc/dispatch-test/#packages",
      "text": "Name Summary dispatch.test",
      "title": "Packages"
    },
    {
      "location": "kdoc/dispatch-test/#index",
      "text": "All Types",
      "title": "Index"
    },
    {
      "location": "kdoc/dispatch-test/alltypes/",
      "text": "All Types Name Summary dispatch.test.TestDispatcherProvider DispatcherProvider implementation for testing, where each property defaults to a TestCoroutineDispatcher . | dispatch.test.TestProvidedCoroutineScope A polymorphic testing CoroutineScope interface.",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-test/alltypes/#all-types",
      "text": "Name Summary",
      "title": "All Types"
    },
    {
      "location": "kdoc/dispatch-test/alltypes/#dispatchtesttestdispatcherprovider",
      "text": "DispatcherProvider implementation for testing, where each property defaults to a TestCoroutineDispatcher . |",
      "title": "dispatch.test.TestDispatcherProvider"
    },
    {
      "location": "kdoc/dispatch-test/alltypes/#dispatchtesttestprovidedcoroutinescope",
      "text": "A polymorphic testing CoroutineScope interface.",
      "title": "dispatch.test.TestProvidedCoroutineScope"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/",
      "text": "dispatch-test / dispatch.test Package dispatch.test Types Name Summary TestDispatcherProvider DispatcherProvider implementation for testing, where each property defaults to a TestCoroutineDispatcher . class TestDispatcherProvider : DispatcherProvider TestProvidedCoroutineScope A polymorphic testing CoroutineScope interface. interface TestProvidedCoroutineScope : TestCoroutineScope , DefaultCoroutineScope , IOCoroutineScope , MainCoroutineScope , MainImmediateCoroutineScope , UnconfinedCoroutineScope Functions Name Summary runBlockingProvided Delegates to runBlocking , but injects a DispatcherProvider into the created CoroutineScope . fun runBlockingProvided(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope .() - Unit ): Unit TestBasicDispatcherProvider \"Basic\" TestDispatcherProvider which mimics production behavior, without the automatic time control of TestCoroutineDispatcher and without the need for Dispatchers.setMain fun TestBasicDispatcherProvider(): TestDispatcherProvider TestDispatcherProvider Convenience factory function for TestDispatcherProvider , creating an implementation where all properties point to the same underlying TestCoroutineDispatcher . fun TestDispatcherProvider(dispatcher: CoroutineDispatcher ): TestDispatcherProvider testProvided Delegates to runBlockingTest , but injects a DispatcherProvider into the created TestCoroutineScope . fun testProvided(context: CoroutineContext = EmptyCoroutineContext, testBody: suspend TestCoroutineScope .() - Unit ): Unit fun TestProvidedCoroutineScope .testProvided(testBody: suspend TestCoroutineScope .() - Unit ): Unit TestProvidedCoroutineScope Creates a TestProvidedCoroutineScope implementation with optional parameters of TestCoroutineDispatcher , TestDispatcherProvider , and a generic CoroutineContext . fun TestProvidedCoroutineScope(dispatcher: TestCoroutineDispatcher = TestCoroutineDispatcher(), dispatcherProvider: TestDispatcherProvider ` = TestDispatcherProvider( dispatcher ), context: [ CoroutineContext ](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/index.html) = EmptyCoroutineContext): [ TestProvidedCoroutineScope`](-test-provided-coroutine-scope/index.md)",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/#package-dispatchtest",
      "text": "",
      "title": "Package dispatch.test"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/#types",
      "text": "Name Summary TestDispatcherProvider DispatcherProvider implementation for testing, where each property defaults to a TestCoroutineDispatcher . class TestDispatcherProvider : DispatcherProvider TestProvidedCoroutineScope A polymorphic testing CoroutineScope interface. interface TestProvidedCoroutineScope : TestCoroutineScope , DefaultCoroutineScope , IOCoroutineScope , MainCoroutineScope , MainImmediateCoroutineScope , UnconfinedCoroutineScope",
      "title": "Types"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/#functions",
      "text": "Name Summary runBlockingProvided Delegates to runBlocking , but injects a DispatcherProvider into the created CoroutineScope . fun runBlockingProvided(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope .() - Unit ): Unit TestBasicDispatcherProvider \"Basic\" TestDispatcherProvider which mimics production behavior, without the automatic time control of TestCoroutineDispatcher and without the need for Dispatchers.setMain fun TestBasicDispatcherProvider(): TestDispatcherProvider TestDispatcherProvider Convenience factory function for TestDispatcherProvider , creating an implementation where all properties point to the same underlying TestCoroutineDispatcher . fun TestDispatcherProvider(dispatcher: CoroutineDispatcher ): TestDispatcherProvider testProvided Delegates to runBlockingTest , but injects a DispatcherProvider into the created TestCoroutineScope . fun testProvided(context: CoroutineContext = EmptyCoroutineContext, testBody: suspend TestCoroutineScope .() - Unit ): Unit fun TestProvidedCoroutineScope .testProvided(testBody: suspend TestCoroutineScope .() - Unit ): Unit TestProvidedCoroutineScope Creates a TestProvidedCoroutineScope implementation with optional parameters of TestCoroutineDispatcher , TestDispatcherProvider , and a generic CoroutineContext . fun TestProvidedCoroutineScope(dispatcher: TestCoroutineDispatcher = TestCoroutineDispatcher(), dispatcherProvider: TestDispatcherProvider ` = TestDispatcherProvider( dispatcher ), context: [ CoroutineContext ](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/index.html) = EmptyCoroutineContext): [ TestProvidedCoroutineScope`](-test-provided-coroutine-scope/index.md)",
      "title": "Functions"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/-test-basic-dispatcher-provider/",
      "text": "dispatch-test / dispatch.test / TestBasicDispatcherProvider TestBasicDispatcherProvider @ExperimentalCoroutinesApi fun TestBasicDispatcherProvider(): TestDispatcherProvider (source) \"Basic\" TestDispatcherProvider which mimics production behavior, without the automatic time control of TestCoroutineDispatcher and without the need for Dispatchers.setMain The default , io , and unconfined properties just delegate to their counterparts in Dispatchers . The main and mainImmediate properties share a single dispatcher and thread as they do with the Dispatchers.setMain(...) implementation from kotlinx-coroutines-test .",
      "title": " test basic dispatcher provider"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/-test-basic-dispatcher-provider/#testbasicdispatcherprovider",
      "text": "@ExperimentalCoroutinesApi fun TestBasicDispatcherProvider(): TestDispatcherProvider (source) \"Basic\" TestDispatcherProvider which mimics production behavior, without the automatic time control of TestCoroutineDispatcher and without the need for Dispatchers.setMain The default , io , and unconfined properties just delegate to their counterparts in Dispatchers . The main and mainImmediate properties share a single dispatcher and thread as they do with the Dispatchers.setMain(...) implementation from kotlinx-coroutines-test .",
      "title": "TestBasicDispatcherProvider"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/-test-dispatcher-provider/",
      "text": "dispatch-test / dispatch.test / TestDispatcherProvider TestDispatcherProvider @ExperimentalCoroutinesApi fun TestDispatcherProvider(dispatcher: CoroutineDispatcher ): TestDispatcherProvider (source) Convenience factory function for TestDispatcherProvider , creating an implementation where all properties point to the same underlying TestCoroutineDispatcher .",
      "title": " test dispatcher provider"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/-test-dispatcher-provider/#testdispatcherprovider",
      "text": "@ExperimentalCoroutinesApi fun TestDispatcherProvider(dispatcher: CoroutineDispatcher ): TestDispatcherProvider (source) Convenience factory function for TestDispatcherProvider , creating an implementation where all properties point to the same underlying TestCoroutineDispatcher .",
      "title": "TestDispatcherProvider"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/-test-provided-coroutine-scope/",
      "text": "dispatch-test / dispatch.test / TestProvidedCoroutineScope TestProvidedCoroutineScope @ExperimentalCoroutinesApi fun TestProvidedCoroutineScope(dispatcher: TestCoroutineDispatcher = TestCoroutineDispatcher(), dispatcherProvider: TestDispatcherProvider = TestDispatcherProvider( dispatcher ), context: CoroutineContext = EmptyCoroutineContext): TestProvidedCoroutineScope (source) Creates a TestProvidedCoroutineScope implementation with optional parameters of TestCoroutineDispatcher , TestDispatcherProvider , and a generic CoroutineContext . The resultant TestProvidedCoroutineScope will utilize a single TestCoroutineDispatcher for all the CoroutineDispatcher properties of its DispatcherProvider , and the ContinuationInterceptor Key of the CoroutineContext will also return that TestCoroutineDispatcher .",
      "title": " test provided coroutine scope"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/-test-provided-coroutine-scope/#testprovidedcoroutinescope",
      "text": "@ExperimentalCoroutinesApi fun TestProvidedCoroutineScope(dispatcher: TestCoroutineDispatcher = TestCoroutineDispatcher(), dispatcherProvider: TestDispatcherProvider = TestDispatcherProvider( dispatcher ), context: CoroutineContext = EmptyCoroutineContext): TestProvidedCoroutineScope (source) Creates a TestProvidedCoroutineScope implementation with optional parameters of TestCoroutineDispatcher , TestDispatcherProvider , and a generic CoroutineContext . The resultant TestProvidedCoroutineScope will utilize a single TestCoroutineDispatcher for all the CoroutineDispatcher properties of its DispatcherProvider , and the ContinuationInterceptor Key of the CoroutineContext will also return that TestCoroutineDispatcher .",
      "title": "TestProvidedCoroutineScope"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/run-blocking-provided/",
      "text": "dispatch-test / dispatch.test / runBlockingProvided runBlockingProvided @ExperimentalCoroutinesApi fun runBlockingProvided(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope .() - Unit ): Unit (source) Delegates to runBlocking , but injects a DispatcherProvider into the created CoroutineScope . The resultant CoroutineContext will use a BlockingEventLoop as its default ContinuationInterceptor . If the context does not contain a DispatcherProvider , a TestDispatcherProvider will be created using the BlockingEventLoop interceptor. @Test fun someTest () = runBlockingProvided { val subject = SomeClass( this ) val myData = Data() subject.dataDeferred() .await() shouldBe myData } Parameters context - The base CoroutineContext which will be modified to use a TestCoroutineDispatcher and TestDispatcherProvider . EmptyCoroutineContext is used if one is not provided. See Also runBlocking testProvided",
      "title": "Run blocking provided"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/run-blocking-provided/#runblockingprovided",
      "text": "@ExperimentalCoroutinesApi fun runBlockingProvided(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope .() - Unit ): Unit (source) Delegates to runBlocking , but injects a DispatcherProvider into the created CoroutineScope . The resultant CoroutineContext will use a BlockingEventLoop as its default ContinuationInterceptor . If the context does not contain a DispatcherProvider , a TestDispatcherProvider will be created using the BlockingEventLoop interceptor. @Test fun someTest () = runBlockingProvided { val subject = SomeClass( this ) val myData = Data() subject.dataDeferred() .await() shouldBe myData }",
      "title": "runBlockingProvided"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/run-blocking-provided/#parameters",
      "text": "context - The base CoroutineContext which will be modified to use a TestCoroutineDispatcher and TestDispatcherProvider . EmptyCoroutineContext is used if one is not provided. See Also runBlocking testProvided",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/test-provided/",
      "text": "dispatch-test / dispatch.test / testProvided testProvided @ExperimentalCoroutinesApi fun testProvided(context: CoroutineContext = EmptyCoroutineContext, testBody: suspend TestCoroutineScope .() - Unit ): Unit (source) Delegates to runBlockingTest , but injects a DispatcherProvider into the created TestCoroutineScope . If the context 's ContinuationInterceptor is not a TestCoroutineDispatcher , then a new TestCoroutineDispatcher will be created. If the context does not contain a DispatcherProvider , a TestDispatcherProvider will be created using the TestCoroutineDispatcher . @Test fun someTest () = testProvided { val subject = SomeClass( this ) val myData = Data() subject.dataDeferred() .await() shouldBe myData } Parameters context - The base CoroutineContext which will be modified to use a TestCoroutineDispatcher and TestDispatcherProvider . EmptyCoroutineContext is used if one is not provided. See Also runBlockingTest runBlockingProvided @ExperimentalCoroutinesApi fun TestProvidedCoroutineScope .testProvided(testBody: suspend TestCoroutineScope .() - Unit ): Unit (source) Delegates to runBlockingTest , but injects a DispatcherProvider into the created TestCoroutineScope . If the context 's ContinuationInterceptor is not a TestCoroutineDispatcher , then a new TestCoroutineDispatcher will be created. If the context does not contain a DispatcherProvider , a TestDispatcherProvider will be created using the TestCoroutineDispatcher . @Test fun someTest () = testProvided { val subject = SomeClass( this ) val myData = Data() subject.dataDeferred() .await() shouldBe myData } val scope = TestProvidedCoroutineScope() @Test fun someTest () = scope.testProvided { val subject = SomeClass( this ) val myData = Data() subject.dataDeferred() .await() shouldBe myData } See Also runBlockingTest runBlockingProvided",
      "title": "Test provided"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/test-provided/#testprovided",
      "text": "@ExperimentalCoroutinesApi fun testProvided(context: CoroutineContext = EmptyCoroutineContext, testBody: suspend TestCoroutineScope .() - Unit ): Unit (source) Delegates to runBlockingTest , but injects a DispatcherProvider into the created TestCoroutineScope . If the context 's ContinuationInterceptor is not a TestCoroutineDispatcher , then a new TestCoroutineDispatcher will be created. If the context does not contain a DispatcherProvider , a TestDispatcherProvider will be created using the TestCoroutineDispatcher . @Test fun someTest () = testProvided { val subject = SomeClass( this ) val myData = Data() subject.dataDeferred() .await() shouldBe myData }",
      "title": "testProvided"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/test-provided/#parameters",
      "text": "context - The base CoroutineContext which will be modified to use a TestCoroutineDispatcher and TestDispatcherProvider . EmptyCoroutineContext is used if one is not provided. See Also runBlockingTest runBlockingProvided @ExperimentalCoroutinesApi fun TestProvidedCoroutineScope .testProvided(testBody: suspend TestCoroutineScope .() - Unit ): Unit (source) Delegates to runBlockingTest , but injects a DispatcherProvider into the created TestCoroutineScope . If the context 's ContinuationInterceptor is not a TestCoroutineDispatcher , then a new TestCoroutineDispatcher will be created. If the context does not contain a DispatcherProvider , a TestDispatcherProvider will be created using the TestCoroutineDispatcher . @Test fun someTest () = testProvided { val subject = SomeClass( this ) val myData = Data() subject.dataDeferred() .await() shouldBe myData } val scope = TestProvidedCoroutineScope() @Test fun someTest () = scope.testProvided { val subject = SomeClass( this ) val myData = Data() subject.dataDeferred() .await() shouldBe myData } See Also runBlockingTest runBlockingProvided",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/-test-dispatcher-provider/",
      "text": "dispatch-test / dispatch.test / TestDispatcherProvider TestDispatcherProvider @ExperimentalCoroutinesApi class TestDispatcherProvider : DispatcherProvider (source) DispatcherProvider implementation for testing, where each property defaults to a TestCoroutineDispatcher . A default version will create a different TestCoroutineDispatcher for each property. Constructors Name Summary init DispatcherProvider implementation for testing, where each property defaults to a TestCoroutineDispatcher . TestDispatcherProvider(default: CoroutineDispatcher = TestCoroutineDispatcher(), io: CoroutineDispatcher = TestCoroutineDispatcher(), main: CoroutineDispatcher = TestCoroutineDispatcher(), mainImmediate: CoroutineDispatcher = TestCoroutineDispatcher(), unconfined: CoroutineDispatcher = TestCoroutineDispatcher()) Properties Name Summary default CoroutineDispatcher generally intended for cpu-bound tasks. val default: CoroutineDispatcher io CoroutineDispatcher generally intended for blocking I/O tasks. val io: CoroutineDispatcher main CoroutineDispatcher which is confined to the \"main\" thread. val main: CoroutineDispatcher mainImmediate CoroutineDispatcher which is confined to the \"main\" thread with immediate dispatch. val mainImmediate: CoroutineDispatcher unconfined Corresponds to the Dispatchers.Unconfined property in a default implementation. val unconfined: CoroutineDispatcher",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/-test-dispatcher-provider/#testdispatcherprovider",
      "text": "@ExperimentalCoroutinesApi class TestDispatcherProvider : DispatcherProvider (source) DispatcherProvider implementation for testing, where each property defaults to a TestCoroutineDispatcher . A default version will create a different TestCoroutineDispatcher for each property.",
      "title": "TestDispatcherProvider"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/-test-dispatcher-provider/#constructors",
      "text": "Name Summary init DispatcherProvider implementation for testing, where each property defaults to a TestCoroutineDispatcher . TestDispatcherProvider(default: CoroutineDispatcher = TestCoroutineDispatcher(), io: CoroutineDispatcher = TestCoroutineDispatcher(), main: CoroutineDispatcher = TestCoroutineDispatcher(), mainImmediate: CoroutineDispatcher = TestCoroutineDispatcher(), unconfined: CoroutineDispatcher = TestCoroutineDispatcher())",
      "title": "Constructors"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/-test-dispatcher-provider/#properties",
      "text": "Name Summary default CoroutineDispatcher generally intended for cpu-bound tasks. val default: CoroutineDispatcher io CoroutineDispatcher generally intended for blocking I/O tasks. val io: CoroutineDispatcher main CoroutineDispatcher which is confined to the \"main\" thread. val main: CoroutineDispatcher mainImmediate CoroutineDispatcher which is confined to the \"main\" thread with immediate dispatch. val mainImmediate: CoroutineDispatcher unconfined Corresponds to the Dispatchers.Unconfined property in a default implementation. val unconfined: CoroutineDispatcher",
      "title": "Properties"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/-test-dispatcher-provider/-init-/",
      "text": "dispatch-test / dispatch.test / TestDispatcherProvider / init init TestDispatcherProvider(default: CoroutineDispatcher = TestCoroutineDispatcher(), io: CoroutineDispatcher = TestCoroutineDispatcher(), main: CoroutineDispatcher = TestCoroutineDispatcher(), mainImmediate: CoroutineDispatcher = TestCoroutineDispatcher(), unconfined: CoroutineDispatcher = TestCoroutineDispatcher()) DispatcherProvider implementation for testing, where each property defaults to a TestCoroutineDispatcher . A default version will create a different TestCoroutineDispatcher for each property.",
      "title": " init "
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/-test-dispatcher-provider/-init-/#init",
      "text": "TestDispatcherProvider(default: CoroutineDispatcher = TestCoroutineDispatcher(), io: CoroutineDispatcher = TestCoroutineDispatcher(), main: CoroutineDispatcher = TestCoroutineDispatcher(), mainImmediate: CoroutineDispatcher = TestCoroutineDispatcher(), unconfined: CoroutineDispatcher = TestCoroutineDispatcher()) DispatcherProvider implementation for testing, where each property defaults to a TestCoroutineDispatcher . A default version will create a different TestCoroutineDispatcher for each property.",
      "title": "&lt;init&gt;"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/-test-dispatcher-provider/default/",
      "text": "dispatch-test / dispatch.test / TestDispatcherProvider / default default val default: CoroutineDispatcher (source) CoroutineDispatcher generally intended for cpu-bound tasks. Corresponds to the Dispatchers.Default property in a default implementation. See Also Dispatchers.Default",
      "title": "Default"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/-test-dispatcher-provider/default/#default",
      "text": "val default: CoroutineDispatcher (source) CoroutineDispatcher generally intended for cpu-bound tasks. Corresponds to the Dispatchers.Default property in a default implementation. See Also Dispatchers.Default",
      "title": "default"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/-test-dispatcher-provider/io/",
      "text": "dispatch-test / dispatch.test / TestDispatcherProvider / io io val io: CoroutineDispatcher (source) CoroutineDispatcher generally intended for blocking I/O tasks. Corresponds to the Dispatchers.IO property in a default implementation. See Also Dispatchers.IO",
      "title": "Io"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/-test-dispatcher-provider/io/#io",
      "text": "val io: CoroutineDispatcher (source) CoroutineDispatcher generally intended for blocking I/O tasks. Corresponds to the Dispatchers.IO property in a default implementation. See Also Dispatchers.IO",
      "title": "io"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/-test-dispatcher-provider/main-immediate/",
      "text": "dispatch-test / dispatch.test / TestDispatcherProvider / mainImmediate mainImmediate val mainImmediate: CoroutineDispatcher (source) CoroutineDispatcher which is confined to the \"main\" thread with immediate dispatch. Corresponds to the Dispatchers.Main.immediate property in a default implementation. See Also MainCoroutineDispatcher.immediate",
      "title": "Main immediate"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/-test-dispatcher-provider/main-immediate/#mainimmediate",
      "text": "val mainImmediate: CoroutineDispatcher (source) CoroutineDispatcher which is confined to the \"main\" thread with immediate dispatch. Corresponds to the Dispatchers.Main.immediate property in a default implementation. See Also MainCoroutineDispatcher.immediate",
      "title": "mainImmediate"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/-test-dispatcher-provider/main/",
      "text": "dispatch-test / dispatch.test / TestDispatcherProvider / main main val main: CoroutineDispatcher (source) CoroutineDispatcher which is confined to the \"main\" thread. Corresponds to the Dispatchers.Main property in a default implementation. See Also Dispatchers.Main",
      "title": "Main"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/-test-dispatcher-provider/main/#main",
      "text": "val main: CoroutineDispatcher (source) CoroutineDispatcher which is confined to the \"main\" thread. Corresponds to the Dispatchers.Main property in a default implementation. See Also Dispatchers.Main",
      "title": "main"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/-test-dispatcher-provider/unconfined/",
      "text": "dispatch-test / dispatch.test / TestDispatcherProvider / unconfined unconfined val unconfined: CoroutineDispatcher (source) Corresponds to the Dispatchers.Unconfined property in a default implementation. See Also Dispatchers.Unconfined",
      "title": "Unconfined"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/-test-dispatcher-provider/unconfined/#unconfined",
      "text": "val unconfined: CoroutineDispatcher (source) Corresponds to the Dispatchers.Unconfined property in a default implementation. See Also Dispatchers.Unconfined",
      "title": "unconfined"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/-test-provided-coroutine-scope/",
      "text": "dispatch-test / dispatch.test / TestProvidedCoroutineScope TestProvidedCoroutineScope @ExperimentalCoroutinesApi interface TestProvidedCoroutineScope : TestCoroutineScope , DefaultCoroutineScope , IOCoroutineScope , MainCoroutineScope , MainImmediateCoroutineScope , UnconfinedCoroutineScope (source) A polymorphic testing CoroutineScope interface. This single interface implements: TestCoroutineScope IOCoroutineScope MainImmediateCoroutineScope This means that it can be injected into any class or function regardless of what type of CoroutineScope is required. Properties Name Summary dispatcherProvider single DispatcherProvider promise for the TestProvidedCoroutineScope abstract val dispatcherProvider: DispatcherProvider Extension Functions Name Summary testProvided Delegates to runBlockingTest , but injects a DispatcherProvider into the created TestCoroutineScope . fun TestProvidedCoroutineScope .testProvided(testBody: suspend TestCoroutineScope .() - Unit ): Unit",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/-test-provided-coroutine-scope/#testprovidedcoroutinescope",
      "text": "@ExperimentalCoroutinesApi interface TestProvidedCoroutineScope : TestCoroutineScope , DefaultCoroutineScope , IOCoroutineScope , MainCoroutineScope , MainImmediateCoroutineScope , UnconfinedCoroutineScope (source) A polymorphic testing CoroutineScope interface. This single interface implements: TestCoroutineScope IOCoroutineScope MainImmediateCoroutineScope This means that it can be injected into any class or function regardless of what type of CoroutineScope is required.",
      "title": "TestProvidedCoroutineScope"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/-test-provided-coroutine-scope/#properties",
      "text": "Name Summary dispatcherProvider single DispatcherProvider promise for the TestProvidedCoroutineScope abstract val dispatcherProvider: DispatcherProvider",
      "title": "Properties"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/-test-provided-coroutine-scope/#extension-functions",
      "text": "Name Summary testProvided Delegates to runBlockingTest , but injects a DispatcherProvider into the created TestCoroutineScope . fun TestProvidedCoroutineScope .testProvided(testBody: suspend TestCoroutineScope .() - Unit ): Unit",
      "title": "Extension Functions"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/-test-provided-coroutine-scope/dispatcher-provider/",
      "text": "dispatch-test / dispatch.test / TestProvidedCoroutineScope / dispatcherProvider dispatcherProvider abstract val dispatcherProvider: DispatcherProvider (source) single DispatcherProvider promise for the TestProvidedCoroutineScope",
      "title": "Dispatcher provider"
    },
    {
      "location": "kdoc/dispatch-test/dispatch.test/-test-provided-coroutine-scope/dispatcher-provider/#dispatcherprovider",
      "text": "abstract val dispatcherProvider: DispatcherProvider (source) single DispatcherProvider promise for the TestProvidedCoroutineScope",
      "title": "dispatcherProvider"
    },
    {
      "location": "kdoc/dispatch-test-junit4/",
      "text": "dispatch-test-junit4 Packages Name Summary dispatch.test Index All Types",
      "title": "test-junit4"
    },
    {
      "location": "kdoc/dispatch-test-junit4/#packages",
      "text": "Name Summary dispatch.test",
      "title": "Packages"
    },
    {
      "location": "kdoc/dispatch-test-junit4/#index",
      "text": "All Types",
      "title": "Index"
    },
    {
      "location": "kdoc/dispatch-test-junit4/alltypes/",
      "text": "All Types Name Summary dispatch.test.TestCoroutineRule A basic JUnit 4 TestRule which creates a new TestProvidedCoroutineScope for each test, sets Dispatchers.Main , and calls cleanupTestCoroutines afterwards.",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-test-junit4/alltypes/#all-types",
      "text": "Name Summary",
      "title": "All Types"
    },
    {
      "location": "kdoc/dispatch-test-junit4/alltypes/#dispatchtesttestcoroutinerule",
      "text": "A basic JUnit 4 TestRule which creates a new TestProvidedCoroutineScope for each test, sets Dispatchers.Main , and calls cleanupTestCoroutines afterwards.",
      "title": "dispatch.test.TestCoroutineRule"
    },
    {
      "location": "kdoc/dispatch-test-junit4/dispatch.test/",
      "text": "dispatch-test-junit4 / dispatch.test Package dispatch.test Types Name Summary TestCoroutineRule A basic JUnit 4 TestRule which creates a new TestProvidedCoroutineScope for each test, sets Dispatchers.Main , and calls cleanupTestCoroutines afterwards. class TestCoroutineRule : TestWatcher , TestProvidedCoroutineScope",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-test-junit4/dispatch.test/#package-dispatchtest",
      "text": "",
      "title": "Package dispatch.test"
    },
    {
      "location": "kdoc/dispatch-test-junit4/dispatch.test/#types",
      "text": "Name Summary TestCoroutineRule A basic JUnit 4 TestRule which creates a new TestProvidedCoroutineScope for each test, sets Dispatchers.Main , and calls cleanupTestCoroutines afterwards. class TestCoroutineRule : TestWatcher , TestProvidedCoroutineScope",
      "title": "Types"
    },
    {
      "location": "kdoc/dispatch-test-junit4/dispatch.test/-test-coroutine-rule/",
      "text": "dispatch-test-junit4 / dispatch.test / TestCoroutineRule TestCoroutineRule @ExperimentalCoroutinesApi class TestCoroutineRule : TestWatcher , TestProvidedCoroutineScope (source) A basic JUnit 4 TestRule which creates a new TestProvidedCoroutineScope for each test, sets Dispatchers.Main , and calls cleanupTestCoroutines afterwards. The rule itself implements TestProvidedCoroutineScope , so it can be used as follows: Before the test: Dispatchers.Main is set to the TestCoroutineDispatcher used by the CoroutineContext . After the test: cleanupTestCoroutines is called to ensure there are no leaking coroutines. Any unfinished coroutine will throw an UncompletedCoroutinesError . Dispatchers.Main is reset via Dispatchers.resetMain . Requires JUnit 4. dependencies { testImplementation junit:junit:4.12 -- or -- testImplementation org.junit.vintage:junit-vintage-engine:5.5.1 } @ExperimentalCoroutinesApi class TestCoroutineRuleSample { @JvmField @Rule val rule = TestCoroutineRule() @Test fun `rule should be a TestProvidedCoroutineScope` () = runBlocking { rule.shouldBeInstanceOf TestProvidedCoroutineScope () rule.launch { // use the rule like any other CoroutineScope } .join() } } @ExperimentalCoroutinesApi class TestCoroutineRuleWithFactorySample { val customScope = TestProvidedCoroutineScope( context = CoroutineName( custom name ) ) @JvmField @Rule val rule = TestCoroutineRule { customScope } @Test fun `rule should be a TestProvidedCoroutineScope` () = runBlocking { rule.shouldBeInstanceOf TestProvidedCoroutineScope () rule.launch { // use the rule like any other CoroutineScope } .join() } @Test fun `rule should be the provided custom scope` () = runBlocking { val context = rule.coroutineContext context shouldBe customScope.coroutineContext } } Parameters factory - optional factory for a custom TestProvidedCoroutineScope . If a factory is not provided, the resultant scope uses the same TestCoroutineDispatcher for each property in its TestDispatcherProvider See Also TestRule TestCoroutineScope TestProvidedCoroutineScope Constructors Name Summary init A basic JUnit 4 TestRule which creates a new TestProvidedCoroutineScope for each test, sets Dispatchers.Main , and calls cleanupTestCoroutines afterwards. TestCoroutineRule(factory: () - TestProvidedCoroutineScope = { TestProvidedCoroutineScope() }) Properties Name Summary dispatcher The underlying TestCoroutineDispatcher which is responsible for virtual time control. val dispatcher: TestCoroutineDispatcher",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-test-junit4/dispatch.test/-test-coroutine-rule/#testcoroutinerule",
      "text": "@ExperimentalCoroutinesApi class TestCoroutineRule : TestWatcher , TestProvidedCoroutineScope (source) A basic JUnit 4 TestRule which creates a new TestProvidedCoroutineScope for each test, sets Dispatchers.Main , and calls cleanupTestCoroutines afterwards. The rule itself implements TestProvidedCoroutineScope , so it can be used as follows:",
      "title": "TestCoroutineRule"
    },
    {
      "location": "kdoc/dispatch-test-junit4/dispatch.test/-test-coroutine-rule/#before-the-test",
      "text": "Dispatchers.Main is set to the TestCoroutineDispatcher used by the CoroutineContext .",
      "title": "Before the test:"
    },
    {
      "location": "kdoc/dispatch-test-junit4/dispatch.test/-test-coroutine-rule/#after-the-test",
      "text": "cleanupTestCoroutines is called to ensure there are no leaking coroutines. Any unfinished coroutine will throw an UncompletedCoroutinesError . Dispatchers.Main is reset via Dispatchers.resetMain .",
      "title": "After the test:"
    },
    {
      "location": "kdoc/dispatch-test-junit4/dispatch.test/-test-coroutine-rule/#requires-junit-4",
      "text": "dependencies { testImplementation junit:junit:4.12 -- or -- testImplementation org.junit.vintage:junit-vintage-engine:5.5.1 } @ExperimentalCoroutinesApi class TestCoroutineRuleSample { @JvmField @Rule val rule = TestCoroutineRule() @Test fun `rule should be a TestProvidedCoroutineScope` () = runBlocking { rule.shouldBeInstanceOf TestProvidedCoroutineScope () rule.launch { // use the rule like any other CoroutineScope } .join() } } @ExperimentalCoroutinesApi class TestCoroutineRuleWithFactorySample { val customScope = TestProvidedCoroutineScope( context = CoroutineName( custom name ) ) @JvmField @Rule val rule = TestCoroutineRule { customScope } @Test fun `rule should be a TestProvidedCoroutineScope` () = runBlocking { rule.shouldBeInstanceOf TestProvidedCoroutineScope () rule.launch { // use the rule like any other CoroutineScope } .join() } @Test fun `rule should be the provided custom scope` () = runBlocking { val context = rule.coroutineContext context shouldBe customScope.coroutineContext } }",
      "title": "Requires JUnit 4."
    },
    {
      "location": "kdoc/dispatch-test-junit4/dispatch.test/-test-coroutine-rule/#parameters",
      "text": "factory - optional factory for a custom TestProvidedCoroutineScope . If a factory is not provided, the resultant scope uses the same TestCoroutineDispatcher for each property in its TestDispatcherProvider See Also TestRule TestCoroutineScope TestProvidedCoroutineScope",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-test-junit4/dispatch.test/-test-coroutine-rule/#constructors",
      "text": "Name Summary init A basic JUnit 4 TestRule which creates a new TestProvidedCoroutineScope for each test, sets Dispatchers.Main , and calls cleanupTestCoroutines afterwards. TestCoroutineRule(factory: () - TestProvidedCoroutineScope = { TestProvidedCoroutineScope() })",
      "title": "Constructors"
    },
    {
      "location": "kdoc/dispatch-test-junit4/dispatch.test/-test-coroutine-rule/#properties",
      "text": "Name Summary dispatcher The underlying TestCoroutineDispatcher which is responsible for virtual time control. val dispatcher: TestCoroutineDispatcher",
      "title": "Properties"
    },
    {
      "location": "kdoc/dispatch-test-junit4/dispatch.test/-test-coroutine-rule/-init-/",
      "text": "dispatch-test-junit4 / dispatch.test / TestCoroutineRule / init init TestCoroutineRule(factory: () - TestProvidedCoroutineScope = { TestProvidedCoroutineScope() }) A basic JUnit 4 TestRule which creates a new TestProvidedCoroutineScope for each test, sets Dispatchers.Main , and calls cleanupTestCoroutines afterwards. The rule itself implements TestProvidedCoroutineScope , so it can be used as follows: Before the test: Dispatchers.Main is set to the TestCoroutineDispatcher used by the CoroutineContext . After the test: cleanupTestCoroutines is called to ensure there are no leaking coroutines. Any unfinished coroutine will throw an UncompletedCoroutinesError . Dispatchers.Main is reset via Dispatchers.resetMain . Requires JUnit 4. dependencies { testImplementation junit:junit:4.12 -- or -- testImplementation org.junit.vintage:junit-vintage-engine:5.5.1 } @ExperimentalCoroutinesApi class TestCoroutineRuleSample { @JvmField @Rule val rule = TestCoroutineRule() @Test fun `rule should be a TestProvidedCoroutineScope` () = runBlocking { rule.shouldBeInstanceOf TestProvidedCoroutineScope () rule.launch { // use the rule like any other CoroutineScope } .join() } } @ExperimentalCoroutinesApi class TestCoroutineRuleWithFactorySample { val customScope = TestProvidedCoroutineScope( context = CoroutineName( custom name ) ) @JvmField @Rule val rule = TestCoroutineRule { customScope } @Test fun `rule should be a TestProvidedCoroutineScope` () = runBlocking { rule.shouldBeInstanceOf TestProvidedCoroutineScope () rule.launch { // use the rule like any other CoroutineScope } .join() } @Test fun `rule should be the provided custom scope` () = runBlocking { val context = rule.coroutineContext context shouldBe customScope.coroutineContext } } Parameters factory - optional factory for a custom TestProvidedCoroutineScope . If a factory is not provided, the resultant scope uses the same TestCoroutineDispatcher for each property in its TestDispatcherProvider See Also TestRule TestCoroutineScope TestProvidedCoroutineScope",
      "title": " init "
    },
    {
      "location": "kdoc/dispatch-test-junit4/dispatch.test/-test-coroutine-rule/-init-/#init",
      "text": "TestCoroutineRule(factory: () - TestProvidedCoroutineScope = { TestProvidedCoroutineScope() }) A basic JUnit 4 TestRule which creates a new TestProvidedCoroutineScope for each test, sets Dispatchers.Main , and calls cleanupTestCoroutines afterwards. The rule itself implements TestProvidedCoroutineScope , so it can be used as follows:",
      "title": "&lt;init&gt;"
    },
    {
      "location": "kdoc/dispatch-test-junit4/dispatch.test/-test-coroutine-rule/-init-/#before-the-test",
      "text": "Dispatchers.Main is set to the TestCoroutineDispatcher used by the CoroutineContext .",
      "title": "Before the test:"
    },
    {
      "location": "kdoc/dispatch-test-junit4/dispatch.test/-test-coroutine-rule/-init-/#after-the-test",
      "text": "cleanupTestCoroutines is called to ensure there are no leaking coroutines. Any unfinished coroutine will throw an UncompletedCoroutinesError . Dispatchers.Main is reset via Dispatchers.resetMain .",
      "title": "After the test:"
    },
    {
      "location": "kdoc/dispatch-test-junit4/dispatch.test/-test-coroutine-rule/-init-/#requires-junit-4",
      "text": "dependencies { testImplementation junit:junit:4.12 -- or -- testImplementation org.junit.vintage:junit-vintage-engine:5.5.1 } @ExperimentalCoroutinesApi class TestCoroutineRuleSample { @JvmField @Rule val rule = TestCoroutineRule() @Test fun `rule should be a TestProvidedCoroutineScope` () = runBlocking { rule.shouldBeInstanceOf TestProvidedCoroutineScope () rule.launch { // use the rule like any other CoroutineScope } .join() } } @ExperimentalCoroutinesApi class TestCoroutineRuleWithFactorySample { val customScope = TestProvidedCoroutineScope( context = CoroutineName( custom name ) ) @JvmField @Rule val rule = TestCoroutineRule { customScope } @Test fun `rule should be a TestProvidedCoroutineScope` () = runBlocking { rule.shouldBeInstanceOf TestProvidedCoroutineScope () rule.launch { // use the rule like any other CoroutineScope } .join() } @Test fun `rule should be the provided custom scope` () = runBlocking { val context = rule.coroutineContext context shouldBe customScope.coroutineContext } }",
      "title": "Requires JUnit 4."
    },
    {
      "location": "kdoc/dispatch-test-junit4/dispatch.test/-test-coroutine-rule/-init-/#parameters",
      "text": "factory - optional factory for a custom TestProvidedCoroutineScope . If a factory is not provided, the resultant scope uses the same TestCoroutineDispatcher for each property in its TestDispatcherProvider See Also TestRule TestCoroutineScope TestProvidedCoroutineScope",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-test-junit4/dispatch.test/-test-coroutine-rule/dispatcher/",
      "text": "dispatch-test-junit4 / dispatch.test / TestCoroutineRule / dispatcher dispatcher val dispatcher: TestCoroutineDispatcher (source) The underlying TestCoroutineDispatcher which is responsible for virtual time control. See Also UncaughtExceptionCaptor DelayController",
      "title": "Dispatcher"
    },
    {
      "location": "kdoc/dispatch-test-junit4/dispatch.test/-test-coroutine-rule/dispatcher/#dispatcher",
      "text": "val dispatcher: TestCoroutineDispatcher (source) The underlying TestCoroutineDispatcher which is responsible for virtual time control. See Also UncaughtExceptionCaptor DelayController",
      "title": "dispatcher"
    },
    {
      "location": "kdoc/dispatch-test-junit5/",
      "text": "dispatch-test-junit5 Packages Name Summary dispatch.test Index All Types",
      "title": "test-junit5"
    },
    {
      "location": "kdoc/dispatch-test-junit5/#packages",
      "text": "Name Summary dispatch.test",
      "title": "Packages"
    },
    {
      "location": "kdoc/dispatch-test-junit5/#index",
      "text": "All Types",
      "title": "Index"
    },
    {
      "location": "kdoc/dispatch-test-junit5/alltypes/",
      "text": "All Types Name Summary dispatch.test.CoroutineTest Annotation for specifying a custom CoroutineTestExtension.ScopeFactory while extending a test class or function with CoroutineTestExtension . | dispatch.test.CoroutineTestExtension JUnit 5 ParameterResolver Extension for injecting and managing a TestProvidedCoroutineScope in a test instance. This creates a new instance of TestProvidedCoroutineScope each time the scope is injected, optionally using a custom ScopeFactory .",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-test-junit5/alltypes/#all-types",
      "text": "Name Summary",
      "title": "All Types"
    },
    {
      "location": "kdoc/dispatch-test-junit5/alltypes/#dispatchtestcoroutinetest",
      "text": "Annotation for specifying a custom CoroutineTestExtension.ScopeFactory while extending a test class or function with CoroutineTestExtension . |",
      "title": "dispatch.test.CoroutineTest"
    },
    {
      "location": "kdoc/dispatch-test-junit5/alltypes/#dispatchtestcoroutinetestextension",
      "text": "JUnit 5 ParameterResolver Extension for injecting and managing a TestProvidedCoroutineScope in a test instance. This creates a new instance of TestProvidedCoroutineScope each time the scope is injected, optionally using a custom ScopeFactory .",
      "title": "dispatch.test.CoroutineTestExtension"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/",
      "text": "dispatch-test-junit5 / dispatch.test Package dispatch.test Types Name Summary CoroutineTestExtension JUnit 5 ParameterResolver Extension for injecting and managing a TestProvidedCoroutineScope in a test instance. This creates a new instance of TestProvidedCoroutineScope each time the scope is injected, optionally using a custom ScopeFactory . class CoroutineTestExtension : TypeBasedParameterResolver TestProvidedCoroutineScope , BeforeEachCallback , AfterEachCallback Annotations Name Summary CoroutineTest Annotation for specifying a custom CoroutineTestExtension.ScopeFactory while extending a test class or function with CoroutineTestExtension . annotation class CoroutineTest Functions Name Summary coroutineTestExtension Factory function for creating a CoroutineTestExtension . fun coroutineTestExtension(scopeFactory: () - TestProvidedCoroutineScope = { TestProvidedCoroutineScope() }): CoroutineTestExtension",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/#package-dispatchtest",
      "text": "",
      "title": "Package dispatch.test"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/#types",
      "text": "Name Summary CoroutineTestExtension JUnit 5 ParameterResolver Extension for injecting and managing a TestProvidedCoroutineScope in a test instance. This creates a new instance of TestProvidedCoroutineScope each time the scope is injected, optionally using a custom ScopeFactory . class CoroutineTestExtension : TypeBasedParameterResolver TestProvidedCoroutineScope , BeforeEachCallback , AfterEachCallback",
      "title": "Types"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/#annotations",
      "text": "Name Summary CoroutineTest Annotation for specifying a custom CoroutineTestExtension.ScopeFactory while extending a test class or function with CoroutineTestExtension . annotation class CoroutineTest",
      "title": "Annotations"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/#functions",
      "text": "Name Summary coroutineTestExtension Factory function for creating a CoroutineTestExtension . fun coroutineTestExtension(scopeFactory: () - TestProvidedCoroutineScope = { TestProvidedCoroutineScope() }): CoroutineTestExtension",
      "title": "Functions"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/coroutine-test-extension/",
      "text": "dispatch-test-junit5 / dispatch.test / coroutineTestExtension coroutineTestExtension @ExperimentalCoroutinesApi inline fun coroutineTestExtension(crossinline scopeFactory: () - TestProvidedCoroutineScope = { TestProvidedCoroutineScope() }): CoroutineTestExtension (source) Factory function for creating a CoroutineTestExtension . class RegisterSample { @JvmField @RegisterExtension val extension = coroutineTestExtension() @Test fun `extension should be a TestProvidedCoroutineScope` () = runBlocking Unit { extension.scope.shouldBeInstanceOf TestProvidedCoroutineScope () } @Test fun `extension should automatically inject into functions` (scope: TestProvidedCoroutineScope) = runBlocking { val subject = SomeClass(scope) val resultDeferred = subject.someFunction() scope.advanceUntilIdle() resultDeferred.await() shouldBe someValue } } class RegisterWithFactorySample { @JvmField @RegisterExtension val extension = coroutineTestExtension { TestProvidedCoroutineScope(context = CoroutineName( custom name )) } @Test fun `extension should provide a scope from the custom factory` () = runBlocking { extension.scope.coroutineContext[CoroutineName] shouldBe CoroutineName( custom name ) } } Parameters scopeFactory - optional factory for a custom TestProvidedCoroutineScope . If a factory is not provided, the resultant scope uses the same TestCoroutineDispatcher for each property in its TestDispatcherProvider See Also CoroutineTestExtension CoroutineTest",
      "title": "Coroutine test extension"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/coroutine-test-extension/#coroutinetestextension",
      "text": "@ExperimentalCoroutinesApi inline fun coroutineTestExtension(crossinline scopeFactory: () - TestProvidedCoroutineScope = { TestProvidedCoroutineScope() }): CoroutineTestExtension (source) Factory function for creating a CoroutineTestExtension . class RegisterSample { @JvmField @RegisterExtension val extension = coroutineTestExtension() @Test fun `extension should be a TestProvidedCoroutineScope` () = runBlocking Unit { extension.scope.shouldBeInstanceOf TestProvidedCoroutineScope () } @Test fun `extension should automatically inject into functions` (scope: TestProvidedCoroutineScope) = runBlocking { val subject = SomeClass(scope) val resultDeferred = subject.someFunction() scope.advanceUntilIdle() resultDeferred.await() shouldBe someValue } } class RegisterWithFactorySample { @JvmField @RegisterExtension val extension = coroutineTestExtension { TestProvidedCoroutineScope(context = CoroutineName( custom name )) } @Test fun `extension should provide a scope from the custom factory` () = runBlocking { extension.scope.coroutineContext[CoroutineName] shouldBe CoroutineName( custom name ) } }",
      "title": "coroutineTestExtension"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/coroutine-test-extension/#parameters",
      "text": "scopeFactory - optional factory for a custom TestProvidedCoroutineScope . If a factory is not provided, the resultant scope uses the same TestCoroutineDispatcher for each property in its TestDispatcherProvider See Also CoroutineTestExtension CoroutineTest",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test/",
      "text": "dispatch-test-junit5 / dispatch.test / CoroutineTest CoroutineTest @ExperimentalCoroutinesApi @ExtendWith([NormalClass(value=dispatch/test/CoroutineTestExtension)]) annotation class CoroutineTest (source) Annotation for specifying a custom CoroutineTestExtension.ScopeFactory while extending a test class or function with CoroutineTestExtension . @CoroutineTest class CoroutineTestDefaultFactorySample ( val testScope: TestProvidedCoroutineScope ) { @Test fun `extension should automatically inject into test class` () = runBlocking { val subject = SomeClass(testScope) val resultDeferred = subject.someFunction() testScope.advanceUntilIdle() resultDeferred.await() shouldBe someValue } } class CoroutineTestNamedFactorySample { class TestCoroutineScopeWithJobFactory : CoroutineTestExtension.ScopeFactory() { override fun create (): TestProvidedCoroutineScope { return TestProvidedCoroutineScope(context = Job()) } } @CoroutineTest(TestCoroutineScopeWithJobFactory :: class ) class CustomFactorySample ( val testScope: TestProvidedCoroutineScope) { @Test fun `injected scope should have a Job context` () = runBlocking { testScope.coroutineContext[Job] shouldNotBe null } } } Parameters scopeFactory - optional KClass which extends CoroutineTestExtension.ScopeFactory . This class must have a default constructor An instance will be automatically initialized inside the CoroutineTestExtension and used to create custom TestProvidedCoroutineScope instances. See Also CoroutineTestExtension Constructors Name Summary init Annotation for specifying a custom CoroutineTestExtension.ScopeFactory while extending a test class or function with CoroutineTestExtension . CoroutineTest(scopeFactory: KClass * = CoroutineTestExtension.ScopeFactory::class) Properties Name Summary scopeFactory optional KClass which extends CoroutineTestExtension.ScopeFactory . This class must have a default constructor An instance will be automatically initialized inside the CoroutineTestExtension and used to create custom TestProvidedCoroutineScope instances. val scopeFactory: KClass *",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test/#coroutinetest",
      "text": "@ExperimentalCoroutinesApi @ExtendWith([NormalClass(value=dispatch/test/CoroutineTestExtension)]) annotation class CoroutineTest (source) Annotation for specifying a custom CoroutineTestExtension.ScopeFactory while extending a test class or function with CoroutineTestExtension . @CoroutineTest class CoroutineTestDefaultFactorySample ( val testScope: TestProvidedCoroutineScope ) { @Test fun `extension should automatically inject into test class` () = runBlocking { val subject = SomeClass(testScope) val resultDeferred = subject.someFunction() testScope.advanceUntilIdle() resultDeferred.await() shouldBe someValue } } class CoroutineTestNamedFactorySample { class TestCoroutineScopeWithJobFactory : CoroutineTestExtension.ScopeFactory() { override fun create (): TestProvidedCoroutineScope { return TestProvidedCoroutineScope(context = Job()) } } @CoroutineTest(TestCoroutineScopeWithJobFactory :: class ) class CustomFactorySample ( val testScope: TestProvidedCoroutineScope) { @Test fun `injected scope should have a Job context` () = runBlocking { testScope.coroutineContext[Job] shouldNotBe null } } }",
      "title": "CoroutineTest"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test/#parameters",
      "text": "scopeFactory - optional KClass which extends CoroutineTestExtension.ScopeFactory . This class must have a default constructor An instance will be automatically initialized inside the CoroutineTestExtension and used to create custom TestProvidedCoroutineScope instances. See Also CoroutineTestExtension",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test/#constructors",
      "text": "Name Summary init Annotation for specifying a custom CoroutineTestExtension.ScopeFactory while extending a test class or function with CoroutineTestExtension . CoroutineTest(scopeFactory: KClass * = CoroutineTestExtension.ScopeFactory::class)",
      "title": "Constructors"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test/#properties",
      "text": "Name Summary scopeFactory optional KClass which extends CoroutineTestExtension.ScopeFactory . This class must have a default constructor An instance will be automatically initialized inside the CoroutineTestExtension and used to create custom TestProvidedCoroutineScope instances. val scopeFactory: KClass *",
      "title": "Properties"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test/-init-/",
      "text": "dispatch-test-junit5 / dispatch.test / CoroutineTest / init init CoroutineTest(scopeFactory: KClass * = CoroutineTestExtension.ScopeFactory::class) Annotation for specifying a custom CoroutineTestExtension.ScopeFactory while extending a test class or function with CoroutineTestExtension . @CoroutineTest class CoroutineTestDefaultFactorySample ( val testScope: TestProvidedCoroutineScope ) { @Test fun `extension should automatically inject into test class` () = runBlocking { val subject = SomeClass(testScope) val resultDeferred = subject.someFunction() testScope.advanceUntilIdle() resultDeferred.await() shouldBe someValue } } class CoroutineTestNamedFactorySample { class TestCoroutineScopeWithJobFactory : CoroutineTestExtension.ScopeFactory() { override fun create (): TestProvidedCoroutineScope { return TestProvidedCoroutineScope(context = Job()) } } @CoroutineTest(TestCoroutineScopeWithJobFactory :: class ) class CustomFactorySample ( val testScope: TestProvidedCoroutineScope) { @Test fun `injected scope should have a Job context` () = runBlocking { testScope.coroutineContext[Job] shouldNotBe null } } } Parameters scopeFactory - optional KClass which extends CoroutineTestExtension.ScopeFactory . This class must have a default constructor An instance will be automatically initialized inside the CoroutineTestExtension and used to create custom TestProvidedCoroutineScope instances. See Also CoroutineTestExtension",
      "title": " init "
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test/-init-/#init",
      "text": "CoroutineTest(scopeFactory: KClass * = CoroutineTestExtension.ScopeFactory::class) Annotation for specifying a custom CoroutineTestExtension.ScopeFactory while extending a test class or function with CoroutineTestExtension . @CoroutineTest class CoroutineTestDefaultFactorySample ( val testScope: TestProvidedCoroutineScope ) { @Test fun `extension should automatically inject into test class` () = runBlocking { val subject = SomeClass(testScope) val resultDeferred = subject.someFunction() testScope.advanceUntilIdle() resultDeferred.await() shouldBe someValue } } class CoroutineTestNamedFactorySample { class TestCoroutineScopeWithJobFactory : CoroutineTestExtension.ScopeFactory() { override fun create (): TestProvidedCoroutineScope { return TestProvidedCoroutineScope(context = Job()) } } @CoroutineTest(TestCoroutineScopeWithJobFactory :: class ) class CustomFactorySample ( val testScope: TestProvidedCoroutineScope) { @Test fun `injected scope should have a Job context` () = runBlocking { testScope.coroutineContext[Job] shouldNotBe null } } }",
      "title": "&lt;init&gt;"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test/-init-/#parameters",
      "text": "scopeFactory - optional KClass which extends CoroutineTestExtension.ScopeFactory . This class must have a default constructor An instance will be automatically initialized inside the CoroutineTestExtension and used to create custom TestProvidedCoroutineScope instances. See Also CoroutineTestExtension",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test/scope-factory/",
      "text": "dispatch-test-junit5 / dispatch.test / CoroutineTest / scopeFactory scopeFactory val scopeFactory: KClass * (source) optional KClass which extends CoroutineTestExtension.ScopeFactory . This class must have a default constructor An instance will be automatically initialized inside the CoroutineTestExtension and used to create custom TestProvidedCoroutineScope instances.",
      "title": "Scope factory"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test/scope-factory/#scopefactory",
      "text": "val scopeFactory: KClass * (source) optional KClass which extends CoroutineTestExtension.ScopeFactory . This class must have a default constructor An instance will be automatically initialized inside the CoroutineTestExtension and used to create custom TestProvidedCoroutineScope instances.",
      "title": "scopeFactory"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test-extension/",
      "text": "dispatch-test-junit5 / dispatch.test / CoroutineTestExtension CoroutineTestExtension @ExperimentalCoroutinesApi class CoroutineTestExtension : TypeBasedParameterResolver TestProvidedCoroutineScope , BeforeEachCallback , AfterEachCallback (source) JUnit 5 ParameterResolver Extension for injecting and managing a TestProvidedCoroutineScope in a test instance. This creates a new instance of TestProvidedCoroutineScope each time the scope is injected, optionally using a custom ScopeFactory . If this extension is initialized via RegisterExtension , there is also a scope property which is automatically managed. Before Each: Dispatchers.Main is set to the TestCoroutineDispatcher used by the CoroutineContext . After Each: cleanupTestCoroutines is called to ensure there are no leaking coroutines. Any unfinished coroutine will throw an UncompletedCoroutinesError . Dispatchers.Main is reset via Dispatchers.resetMain . Requires JUnit 5. dependencies { testImplementation org.junit.jupiter:junit-jupiter:5.6.2 } class RegisterSample { @JvmField @RegisterExtension val extension = coroutineTestExtension() @Test fun `extension should be a TestProvidedCoroutineScope` () = runBlocking Unit { extension.scope.shouldBeInstanceOf TestProvidedCoroutineScope () } @Test fun `extension should automatically inject into functions` (scope: TestProvidedCoroutineScope) = runBlocking { val subject = SomeClass(scope) val resultDeferred = subject.someFunction() scope.advanceUntilIdle() resultDeferred.await() shouldBe someValue } } class RegisterWithFactorySample { @JvmField @RegisterExtension val extension = coroutineTestExtension { TestProvidedCoroutineScope(context = CoroutineName( custom name )) } @Test fun `extension should provide a scope from the custom factory` () = runBlocking { extension.scope.coroutineContext[CoroutineName] shouldBe CoroutineName( custom name ) } } @ExtendWith(CoroutineTestExtension :: class ) class CoroutineTestExtensionExtendWithSample ( val testScope: TestProvidedCoroutineScope ) { @Test fun `injected scope should be injected` () { testScope shouldNotBe null } } Parameters scopeFactory - optional factory for a custom TestProvidedCoroutineScope . If a factory is not provided, the resultant scope uses the same TestCoroutineDispatcher for each property in its TestDispatcherProvider See Also CoroutineTestExtension CoroutineTest Types Name Summary ScopeFactory Class used to create the TestProvidedCoroutineScope used in CoroutineTestExtension . class ScopeFactory Constructors Name Summary init JUnit 5 ParameterResolver Extension for injecting and managing a TestProvidedCoroutineScope in a test instance. This creates a new instance of TestProvidedCoroutineScope each time the scope is injected, optionally using a custom ScopeFactory . CoroutineTestExtension(scopeFactory: ScopeFactory = ScopeFactory()) Properties Name Summary scope A single TestProvidedCoroutineScope instance which is reset via cleanUpTestCoroutines after each test. val scope: TestProvidedCoroutineScope",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test-extension/#coroutinetestextension",
      "text": "@ExperimentalCoroutinesApi class CoroutineTestExtension : TypeBasedParameterResolver TestProvidedCoroutineScope , BeforeEachCallback , AfterEachCallback (source) JUnit 5 ParameterResolver Extension for injecting and managing a TestProvidedCoroutineScope in a test instance. This creates a new instance of TestProvidedCoroutineScope each time the scope is injected, optionally using a custom ScopeFactory . If this extension is initialized via RegisterExtension , there is also a scope property which is automatically managed.",
      "title": "CoroutineTestExtension"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test-extension/#before-each",
      "text": "Dispatchers.Main is set to the TestCoroutineDispatcher used by the CoroutineContext .",
      "title": "Before Each:"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test-extension/#after-each",
      "text": "cleanupTestCoroutines is called to ensure there are no leaking coroutines. Any unfinished coroutine will throw an UncompletedCoroutinesError . Dispatchers.Main is reset via Dispatchers.resetMain .",
      "title": "After Each:"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test-extension/#requires-junit-5",
      "text": "dependencies { testImplementation org.junit.jupiter:junit-jupiter:5.6.2 } class RegisterSample { @JvmField @RegisterExtension val extension = coroutineTestExtension() @Test fun `extension should be a TestProvidedCoroutineScope` () = runBlocking Unit { extension.scope.shouldBeInstanceOf TestProvidedCoroutineScope () } @Test fun `extension should automatically inject into functions` (scope: TestProvidedCoroutineScope) = runBlocking { val subject = SomeClass(scope) val resultDeferred = subject.someFunction() scope.advanceUntilIdle() resultDeferred.await() shouldBe someValue } } class RegisterWithFactorySample { @JvmField @RegisterExtension val extension = coroutineTestExtension { TestProvidedCoroutineScope(context = CoroutineName( custom name )) } @Test fun `extension should provide a scope from the custom factory` () = runBlocking { extension.scope.coroutineContext[CoroutineName] shouldBe CoroutineName( custom name ) } } @ExtendWith(CoroutineTestExtension :: class ) class CoroutineTestExtensionExtendWithSample ( val testScope: TestProvidedCoroutineScope ) { @Test fun `injected scope should be injected` () { testScope shouldNotBe null } }",
      "title": "Requires JUnit 5."
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test-extension/#parameters",
      "text": "scopeFactory - optional factory for a custom TestProvidedCoroutineScope . If a factory is not provided, the resultant scope uses the same TestCoroutineDispatcher for each property in its TestDispatcherProvider See Also CoroutineTestExtension CoroutineTest",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test-extension/#types",
      "text": "Name Summary ScopeFactory Class used to create the TestProvidedCoroutineScope used in CoroutineTestExtension . class ScopeFactory",
      "title": "Types"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test-extension/#constructors",
      "text": "Name Summary init JUnit 5 ParameterResolver Extension for injecting and managing a TestProvidedCoroutineScope in a test instance. This creates a new instance of TestProvidedCoroutineScope each time the scope is injected, optionally using a custom ScopeFactory . CoroutineTestExtension(scopeFactory: ScopeFactory = ScopeFactory())",
      "title": "Constructors"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test-extension/#properties",
      "text": "Name Summary scope A single TestProvidedCoroutineScope instance which is reset via cleanUpTestCoroutines after each test. val scope: TestProvidedCoroutineScope",
      "title": "Properties"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test-extension/-init-/",
      "text": "dispatch-test-junit5 / dispatch.test / CoroutineTestExtension / init init CoroutineTestExtension(scopeFactory: ScopeFactory = ScopeFactory()) JUnit 5 ParameterResolver Extension for injecting and managing a TestProvidedCoroutineScope in a test instance. This creates a new instance of TestProvidedCoroutineScope each time the scope is injected, optionally using a custom ScopeFactory . If this extension is initialized via RegisterExtension , there is also a scope property which is automatically managed. Before Each: Dispatchers.Main is set to the TestCoroutineDispatcher used by the CoroutineContext . After Each: cleanupTestCoroutines is called to ensure there are no leaking coroutines. Any unfinished coroutine will throw an UncompletedCoroutinesError . Dispatchers.Main is reset via Dispatchers.resetMain . Requires JUnit 5. dependencies { testImplementation org.junit.jupiter:junit-jupiter:5.6.2 } class RegisterSample { @JvmField @RegisterExtension val extension = coroutineTestExtension() @Test fun `extension should be a TestProvidedCoroutineScope` () = runBlocking Unit { extension.scope.shouldBeInstanceOf TestProvidedCoroutineScope () } @Test fun `extension should automatically inject into functions` (scope: TestProvidedCoroutineScope) = runBlocking { val subject = SomeClass(scope) val resultDeferred = subject.someFunction() scope.advanceUntilIdle() resultDeferred.await() shouldBe someValue } } class RegisterWithFactorySample { @JvmField @RegisterExtension val extension = coroutineTestExtension { TestProvidedCoroutineScope(context = CoroutineName( custom name )) } @Test fun `extension should provide a scope from the custom factory` () = runBlocking { extension.scope.coroutineContext[CoroutineName] shouldBe CoroutineName( custom name ) } } @ExtendWith(CoroutineTestExtension :: class ) class CoroutineTestExtensionExtendWithSample ( val testScope: TestProvidedCoroutineScope ) { @Test fun `injected scope should be injected` () { testScope shouldNotBe null } } Parameters scopeFactory - optional factory for a custom TestProvidedCoroutineScope . If a factory is not provided, the resultant scope uses the same TestCoroutineDispatcher for each property in its TestDispatcherProvider See Also CoroutineTestExtension CoroutineTest",
      "title": " init "
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test-extension/-init-/#init",
      "text": "CoroutineTestExtension(scopeFactory: ScopeFactory = ScopeFactory()) JUnit 5 ParameterResolver Extension for injecting and managing a TestProvidedCoroutineScope in a test instance. This creates a new instance of TestProvidedCoroutineScope each time the scope is injected, optionally using a custom ScopeFactory . If this extension is initialized via RegisterExtension , there is also a scope property which is automatically managed.",
      "title": "&lt;init&gt;"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test-extension/-init-/#before-each",
      "text": "Dispatchers.Main is set to the TestCoroutineDispatcher used by the CoroutineContext .",
      "title": "Before Each:"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test-extension/-init-/#after-each",
      "text": "cleanupTestCoroutines is called to ensure there are no leaking coroutines. Any unfinished coroutine will throw an UncompletedCoroutinesError . Dispatchers.Main is reset via Dispatchers.resetMain .",
      "title": "After Each:"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test-extension/-init-/#requires-junit-5",
      "text": "dependencies { testImplementation org.junit.jupiter:junit-jupiter:5.6.2 } class RegisterSample { @JvmField @RegisterExtension val extension = coroutineTestExtension() @Test fun `extension should be a TestProvidedCoroutineScope` () = runBlocking Unit { extension.scope.shouldBeInstanceOf TestProvidedCoroutineScope () } @Test fun `extension should automatically inject into functions` (scope: TestProvidedCoroutineScope) = runBlocking { val subject = SomeClass(scope) val resultDeferred = subject.someFunction() scope.advanceUntilIdle() resultDeferred.await() shouldBe someValue } } class RegisterWithFactorySample { @JvmField @RegisterExtension val extension = coroutineTestExtension { TestProvidedCoroutineScope(context = CoroutineName( custom name )) } @Test fun `extension should provide a scope from the custom factory` () = runBlocking { extension.scope.coroutineContext[CoroutineName] shouldBe CoroutineName( custom name ) } } @ExtendWith(CoroutineTestExtension :: class ) class CoroutineTestExtensionExtendWithSample ( val testScope: TestProvidedCoroutineScope ) { @Test fun `injected scope should be injected` () { testScope shouldNotBe null } }",
      "title": "Requires JUnit 5."
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test-extension/-init-/#parameters",
      "text": "scopeFactory - optional factory for a custom TestProvidedCoroutineScope . If a factory is not provided, the resultant scope uses the same TestCoroutineDispatcher for each property in its TestDispatcherProvider See Also CoroutineTestExtension CoroutineTest",
      "title": "Parameters"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test-extension/scope/",
      "text": "dispatch-test-junit5 / dispatch.test / CoroutineTestExtension / scope scope val scope: TestProvidedCoroutineScope (source) A single TestProvidedCoroutineScope instance which is reset via cleanUpTestCoroutines after each test.",
      "title": "Scope"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test-extension/scope/#scope",
      "text": "val scope: TestProvidedCoroutineScope (source) A single TestProvidedCoroutineScope instance which is reset via cleanUpTestCoroutines after each test.",
      "title": "scope"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test-extension/-scope-factory/",
      "text": "dispatch-test-junit5 / dispatch.test / CoroutineTestExtension / ScopeFactory ScopeFactory @ExperimentalCoroutinesApi class ScopeFactory (source) Class used to create the TestProvidedCoroutineScope used in CoroutineTestExtension . In order to provide a custom implementation of TestProvidedCoroutineScope : Create a custom factory which has a default constructor and extends this ScopeFactory Annotate your test class with CoroutineTest and pass your custom factory's KClass in as its parameter. class CoroutineTestNamedFactorySample { class TestCoroutineScopeWithJobFactory : CoroutineTestExtension.ScopeFactory() { override fun create (): TestProvidedCoroutineScope { return TestProvidedCoroutineScope(context = Job()) } } @CoroutineTest(TestCoroutineScopeWithJobFactory :: class ) class CustomFactorySample ( val testScope: TestProvidedCoroutineScope) { @Test fun `injected scope should have a Job context` () = runBlocking { testScope.coroutineContext[Job] shouldNotBe null } } } Constructors Name Summary init Class used to create the TestProvidedCoroutineScope used in CoroutineTestExtension . ScopeFactory() Functions Name Summary create Creates an instance of TestProvidedCoroutineScope . Uses the no-arg factory by default. open fun create(): TestProvidedCoroutineScope",
      "title": "Home"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test-extension/-scope-factory/#scopefactory",
      "text": "@ExperimentalCoroutinesApi class ScopeFactory (source) Class used to create the TestProvidedCoroutineScope used in CoroutineTestExtension . In order to provide a custom implementation of TestProvidedCoroutineScope : Create a custom factory which has a default constructor and extends this ScopeFactory Annotate your test class with CoroutineTest and pass your custom factory's KClass in as its parameter. class CoroutineTestNamedFactorySample { class TestCoroutineScopeWithJobFactory : CoroutineTestExtension.ScopeFactory() { override fun create (): TestProvidedCoroutineScope { return TestProvidedCoroutineScope(context = Job()) } } @CoroutineTest(TestCoroutineScopeWithJobFactory :: class ) class CustomFactorySample ( val testScope: TestProvidedCoroutineScope) { @Test fun `injected scope should have a Job context` () = runBlocking { testScope.coroutineContext[Job] shouldNotBe null } } }",
      "title": "ScopeFactory"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test-extension/-scope-factory/#constructors",
      "text": "Name Summary init Class used to create the TestProvidedCoroutineScope used in CoroutineTestExtension . ScopeFactory()",
      "title": "Constructors"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test-extension/-scope-factory/#functions",
      "text": "Name Summary create Creates an instance of TestProvidedCoroutineScope . Uses the no-arg factory by default. open fun create(): TestProvidedCoroutineScope",
      "title": "Functions"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test-extension/-scope-factory/-init-/",
      "text": "dispatch-test-junit5 / dispatch.test / CoroutineTestExtension / ScopeFactory / init init ScopeFactory() Class used to create the TestProvidedCoroutineScope used in CoroutineTestExtension . In order to provide a custom implementation of TestProvidedCoroutineScope : Create a custom factory which has a default constructor and extends this ScopeFactory Annotate your test class with CoroutineTest and pass your custom factory's KClass in as its parameter. class CoroutineTestNamedFactorySample { class TestCoroutineScopeWithJobFactory : CoroutineTestExtension.ScopeFactory() { override fun create (): TestProvidedCoroutineScope { return TestProvidedCoroutineScope(context = Job()) } } @CoroutineTest(TestCoroutineScopeWithJobFactory :: class ) class CustomFactorySample ( val testScope: TestProvidedCoroutineScope) { @Test fun `injected scope should have a Job context` () = runBlocking { testScope.coroutineContext[Job] shouldNotBe null } } }",
      "title": " init "
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test-extension/-scope-factory/-init-/#init",
      "text": "ScopeFactory() Class used to create the TestProvidedCoroutineScope used in CoroutineTestExtension . In order to provide a custom implementation of TestProvidedCoroutineScope : Create a custom factory which has a default constructor and extends this ScopeFactory Annotate your test class with CoroutineTest and pass your custom factory's KClass in as its parameter. class CoroutineTestNamedFactorySample { class TestCoroutineScopeWithJobFactory : CoroutineTestExtension.ScopeFactory() { override fun create (): TestProvidedCoroutineScope { return TestProvidedCoroutineScope(context = Job()) } } @CoroutineTest(TestCoroutineScopeWithJobFactory :: class ) class CustomFactorySample ( val testScope: TestProvidedCoroutineScope) { @Test fun `injected scope should have a Job context` () = runBlocking { testScope.coroutineContext[Job] shouldNotBe null } } }",
      "title": "&lt;init&gt;"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test-extension/-scope-factory/create/",
      "text": "dispatch-test-junit5 / dispatch.test / CoroutineTestExtension / ScopeFactory / create create open fun create(): TestProvidedCoroutineScope (source) Creates an instance of TestProvidedCoroutineScope . Uses the no-arg factory by default.",
      "title": "Create"
    },
    {
      "location": "kdoc/dispatch-test-junit5/dispatch.test/-coroutine-test-extension/-scope-factory/create/#create",
      "text": "open fun create(): TestProvidedCoroutineScope (source) Creates an instance of TestProvidedCoroutineScope . Uses the no-arg factory by default.",
      "title": "create"
    },
    {
      "location": "modules/dispatch-android-espresso/",
      "text": "Module dispatch-android-espresso Tools to provide Espresso functionality for coroutines. If an IdlingDispatcherProvider is registered with the IdlingRegistry , Espresso will wait for all associated coroutines to leave the active state before performing any assertions. Coroutines which are in a suspended state (such as a Job \"observing\" a Flow for updates) do not prevent Espresso from performing assertions. class IdlingCoroutineScopeRuleWithLifecycleSample { // Retrieve the DispatcherProvider from a dependency graph, // so that the same one is used throughout the codebase. val customDispatcherProvider = testAppComponent.customDispatcherProvider @JvmField @Rule val idlingRule = IdlingDispatcherProviderRule { IdlingDispatcherProvider(customDispatcherProvider) } /** * If you don t provide CoroutineScopes to your lifecycle components via a dependency injection framework, * you need to use the `dispatch-android-lifecycle-extensions` and `dispatch-android-viewmodel` artifacts * to ensure that the same `IdlingDispatcherProvider` is used. */ @Before fun setUp () { LifecycleScopeFactory. set { MainImmediateCoroutineScope(customDispatcherProvider) } ViewModelScopeFactory. set { MainImmediateCoroutineScope(customDispatcherProvider) } } @Test fun testThings () = runBlocking { // Now any CoroutineScope which uses the DispatcherProvider // in TestAppComponent will sync its idle state with Espresso } } Contents Types IdlingCoroutineScopes Minimum Gradle Config Types Name Description IdlingDispatcherProviderRule JUnit 4 Rule which automatically registers an IdlingDispatcherProvider with the IdlingRegistry IdlingDispatcher A CoroutineDispatcher which tracks each dispatched coroutine using a CountingIdlingResource . All actual dispatches are delegated to a provided CoroutineDispatcher . IdlingDispatcherProvider A special DispatcherProvider which guarantees that each of its properties is an IdlingDispatcher IdlingCoroutineScope A special CoroutineScope which guarantees a property of an IdlingDispatcherProvider IdlingCoroutineScopes Marker Interface Factory Function Description DefaultIdlingCoroutineScope DefaultIdlingCoroutineScope A IdlingCoroutineScope with a CoroutineDispatcher of default . IOIdlingCoroutineScope IOIdlingCoroutineScope A IdlingCoroutineScope with a CoroutineDispatcher of io . MainIdlingCoroutineScope MainIdlingCoroutineScope A IdlingCoroutineScope with a CoroutineDispatcher of main . MainImmediateIdlingCoroutineScope MainImmediateIdlingCoroutineScope A IdlingCoroutineScope with a CoroutineDispatcher of mainImmediate . UnconfinedIdlingCoroutineScope UnconfinedIdlingCoroutineScope A IdlingCoroutineScope with a CoroutineDispatcher of unconfined . Minimum Gradle Config Add to your module's build.gradle.kts : repositories { mavenCentral() } dependencies { // core implementation( org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.7 ) implementation( org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.7 ) implementation( com.rickbusarow.dispatch:dispatch-core:1.0.0-beta03 ) androidTestImplementation( com.rickbusarow.dispatch:dispatch-android-espresso:1.0.0-beta03 ) // android androidTestImplementation( androidx.test:runner:1.2.0 ) androidTestImplementation( androidx.test.espresso:espresso-core:3.2.0 ) }",
      "title": "Android-Espresso"
    },
    {
      "location": "modules/dispatch-android-espresso/#module-dispatch-android-espresso",
      "text": "Tools to provide Espresso functionality for coroutines. If an IdlingDispatcherProvider is registered with the IdlingRegistry , Espresso will wait for all associated coroutines to leave the active state before performing any assertions. Coroutines which are in a suspended state (such as a Job \"observing\" a Flow for updates) do not prevent Espresso from performing assertions. class IdlingCoroutineScopeRuleWithLifecycleSample { // Retrieve the DispatcherProvider from a dependency graph, // so that the same one is used throughout the codebase. val customDispatcherProvider = testAppComponent.customDispatcherProvider @JvmField @Rule val idlingRule = IdlingDispatcherProviderRule { IdlingDispatcherProvider(customDispatcherProvider) } /** * If you don t provide CoroutineScopes to your lifecycle components via a dependency injection framework, * you need to use the `dispatch-android-lifecycle-extensions` and `dispatch-android-viewmodel` artifacts * to ensure that the same `IdlingDispatcherProvider` is used. */ @Before fun setUp () { LifecycleScopeFactory. set { MainImmediateCoroutineScope(customDispatcherProvider) } ViewModelScopeFactory. set { MainImmediateCoroutineScope(customDispatcherProvider) } } @Test fun testThings () = runBlocking { // Now any CoroutineScope which uses the DispatcherProvider // in TestAppComponent will sync its idle state with Espresso } }",
      "title": "Module dispatch-android-espresso"
    },
    {
      "location": "modules/dispatch-android-espresso/#contents",
      "text": "Types IdlingCoroutineScopes Minimum Gradle Config",
      "title": "Contents"
    },
    {
      "location": "modules/dispatch-android-espresso/#types",
      "text": "Name Description IdlingDispatcherProviderRule JUnit 4 Rule which automatically registers an IdlingDispatcherProvider with the IdlingRegistry IdlingDispatcher A CoroutineDispatcher which tracks each dispatched coroutine using a CountingIdlingResource . All actual dispatches are delegated to a provided CoroutineDispatcher . IdlingDispatcherProvider A special DispatcherProvider which guarantees that each of its properties is an IdlingDispatcher IdlingCoroutineScope A special CoroutineScope which guarantees a property of an IdlingDispatcherProvider",
      "title": "Types"
    },
    {
      "location": "modules/dispatch-android-espresso/#idlingcoroutinescopes",
      "text": "Marker Interface Factory Function Description DefaultIdlingCoroutineScope DefaultIdlingCoroutineScope A IdlingCoroutineScope with a CoroutineDispatcher of default . IOIdlingCoroutineScope IOIdlingCoroutineScope A IdlingCoroutineScope with a CoroutineDispatcher of io . MainIdlingCoroutineScope MainIdlingCoroutineScope A IdlingCoroutineScope with a CoroutineDispatcher of main . MainImmediateIdlingCoroutineScope MainImmediateIdlingCoroutineScope A IdlingCoroutineScope with a CoroutineDispatcher of mainImmediate . UnconfinedIdlingCoroutineScope UnconfinedIdlingCoroutineScope A IdlingCoroutineScope with a CoroutineDispatcher of unconfined .",
      "title": "IdlingCoroutineScopes"
    },
    {
      "location": "modules/dispatch-android-espresso/#minimum-gradle-config",
      "text": "Add to your module's build.gradle.kts : repositories { mavenCentral() } dependencies { // core implementation( org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.7 ) implementation( org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.7 ) implementation( com.rickbusarow.dispatch:dispatch-core:1.0.0-beta03 ) androidTestImplementation( com.rickbusarow.dispatch:dispatch-android-espresso:1.0.0-beta03 ) // android androidTestImplementation( androidx.test:runner:1.2.0 ) androidTestImplementation( androidx.test.espresso:espresso-core:3.2.0 ) }",
      "title": "Minimum Gradle Config"
    },
    {
      "location": "modules/dispatch-android-lifecycle-extensions/",
      "text": "Module dispatch-android-lifecycle-extensions Contents Api One-time suspend functions Difference from AndroidX Custom CoroutineScope factories Automatic lifecycle jobs Minimum Gradle Config Api One-time suspend functions Examples import dispatch.android.* // This could be any LifecycleOwner -- Fragments, Activities, Services... class SomeScreen : Fragment() { init { // auto-created MainImmediateCoroutineScope which is lifecycle-aware lifecycleScope //... // active only when resumed . starts a fresh coroutine each time // this is a rough proxy for LiveData behavior lifecycleScope.launchEveryResume { } // active only when started . starts a fresh coroutine each time lifecycleScope.launchEveryStart { } // launch when created, automatically stop on destroy lifecycleScope.launchEveryCreate { } // it works as a normal CoroutineScope as well (because it is) lifecycleScope.launchMain { } } } class SomeApplication : Application() { override fun onCreate () { super .onCreate() // A custom factory can be set to add elements to the CoroutineContext LifecycleScopeFactory. set { MainImmediateCoroutineScope() + SomeCustomElement() } } } class SomeEspressoTest { @Before fun setUp () { // This custom factory can be used to use custom scopes for testing, // such as an idling dispatcher LifecycleScopeFactory. set { MainImmediateIdlingCoroutineScope() } } @After fun tearDown () { // The factory can also be reset to default LifecycleScopeFactory.reset() } } Difference from AndroidX This module is really just a slightly different version of androidx-lifecycle-runtime-ktx \u2014 the library which gives us the lifecycleScope property. Why not just use AndroidX? Because we need two things it doesn't offer. Custom CoroutineScope factories The way androidx-lifecycle-runtime constructs its CoroutineScope is hard-coded , which eliminates the possibility of using a custom CoroutineContext such as a DispatcherProvider or IdlingDispatcher . With dispatch.android.lifecycle , we can set a custom factory. class SomeFragmentEspressoTest { // Not part of this artifact. see dispatch-android-espresso @JvmField @Rule val idlingRule = IdlingDispatcherProviderRule() @Before fun setUp () { // set a custom factory which is applied to all newly created lifecycleScopes LifecycleScopeFactory. set { MainImmediateCoroutineScope() + idlingRule.dispatcherProvider } // now SomeFragment will use an IdlingDispatcher in its CoroutineScope } } Automatic lifecycle jobs Structured concurrency relies upon cancellation, but androidx-lifecycle-runtime.ktx doesn't cancel. It uses a special PausingDispatcher . This pausing behavior then leaks upstream, creating backpressure and potentially deadlocks. There's a bug filed in their issue tracker , but 2.2.0 got released anyway. This library's API surface is the same as that within the AndroidX version, but has a different strategy for handling lifecycle events. When a lifecycle state enters the desired range, such as at ON_RESUME , a new coroutine is created. When the state exists the range, that coroutine is cancelled . If the lifecycle state enters the desired range again, a new coroutine is created. import dispatch.android.* class SomeFragment : Fragment() { val viewModel: SomeViewModel by viewModels() init { // automatically created CoroutineScope using the factory described above lifecycleScope.launchWhenResumed { viewModel.someFlow.consume { } } } } This has the desired effect of not leaking backpressure upstream (which in this example is the viewModel ). Minimum Gradle Config Add to your module's build.gradle.kts : repositories { mavenCentral() } dependencies { implementation( org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.7 ) implementation( org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.7 ) implementation( com.rickbusarow.dispatch:dispatch-android-lifecycle-extensions:1.0.0-beta03 ) implementation( androidx.lifecycle:lifecycle-common:2.2.0 ) }",
      "title": "Module dispatch-android-lifecycle-extensions"
    },
    {
      "location": "modules/dispatch-android-lifecycle-extensions/#module-dispatch-android-lifecycle-extensions",
      "text": "",
      "title": "Module dispatch-android-lifecycle-extensions"
    },
    {
      "location": "modules/dispatch-android-lifecycle-extensions/#contents",
      "text": "Api One-time suspend functions Difference from AndroidX Custom CoroutineScope factories Automatic lifecycle jobs Minimum Gradle Config",
      "title": "Contents"
    },
    {
      "location": "modules/dispatch-android-lifecycle-extensions/#api",
      "text": "",
      "title": "Api"
    },
    {
      "location": "modules/dispatch-android-lifecycle-extensions/#one-time-suspend-functions",
      "text": "Examples import dispatch.android.* // This could be any LifecycleOwner -- Fragments, Activities, Services... class SomeScreen : Fragment() { init { // auto-created MainImmediateCoroutineScope which is lifecycle-aware lifecycleScope //... // active only when resumed . starts a fresh coroutine each time // this is a rough proxy for LiveData behavior lifecycleScope.launchEveryResume { } // active only when started . starts a fresh coroutine each time lifecycleScope.launchEveryStart { } // launch when created, automatically stop on destroy lifecycleScope.launchEveryCreate { } // it works as a normal CoroutineScope as well (because it is) lifecycleScope.launchMain { } } } class SomeApplication : Application() { override fun onCreate () { super .onCreate() // A custom factory can be set to add elements to the CoroutineContext LifecycleScopeFactory. set { MainImmediateCoroutineScope() + SomeCustomElement() } } } class SomeEspressoTest { @Before fun setUp () { // This custom factory can be used to use custom scopes for testing, // such as an idling dispatcher LifecycleScopeFactory. set { MainImmediateIdlingCoroutineScope() } } @After fun tearDown () { // The factory can also be reset to default LifecycleScopeFactory.reset() } }",
      "title": "One-time suspend functions"
    },
    {
      "location": "modules/dispatch-android-lifecycle-extensions/#difference-from-androidx",
      "text": "This module is really just a slightly different version of androidx-lifecycle-runtime-ktx \u2014 the library which gives us the lifecycleScope property. Why not just use AndroidX? Because we need two things it doesn't offer.",
      "title": "Difference from AndroidX"
    },
    {
      "location": "modules/dispatch-android-lifecycle-extensions/#custom-coroutinescope-factories",
      "text": "The way androidx-lifecycle-runtime constructs its CoroutineScope is hard-coded , which eliminates the possibility of using a custom CoroutineContext such as a DispatcherProvider or IdlingDispatcher . With dispatch.android.lifecycle , we can set a custom factory. class SomeFragmentEspressoTest { // Not part of this artifact. see dispatch-android-espresso @JvmField @Rule val idlingRule = IdlingDispatcherProviderRule() @Before fun setUp () { // set a custom factory which is applied to all newly created lifecycleScopes LifecycleScopeFactory. set { MainImmediateCoroutineScope() + idlingRule.dispatcherProvider } // now SomeFragment will use an IdlingDispatcher in its CoroutineScope } }",
      "title": "Custom CoroutineScope factories"
    },
    {
      "location": "modules/dispatch-android-lifecycle-extensions/#automatic-lifecycle-jobs",
      "text": "Structured concurrency relies upon cancellation, but androidx-lifecycle-runtime.ktx doesn't cancel. It uses a special PausingDispatcher . This pausing behavior then leaks upstream, creating backpressure and potentially deadlocks. There's a bug filed in their issue tracker , but 2.2.0 got released anyway. This library's API surface is the same as that within the AndroidX version, but has a different strategy for handling lifecycle events. When a lifecycle state enters the desired range, such as at ON_RESUME , a new coroutine is created. When the state exists the range, that coroutine is cancelled . If the lifecycle state enters the desired range again, a new coroutine is created. import dispatch.android.* class SomeFragment : Fragment() { val viewModel: SomeViewModel by viewModels() init { // automatically created CoroutineScope using the factory described above lifecycleScope.launchWhenResumed { viewModel.someFlow.consume { } } } } This has the desired effect of not leaking backpressure upstream (which in this example is the viewModel ).",
      "title": "Automatic lifecycle jobs"
    },
    {
      "location": "modules/dispatch-android-lifecycle-extensions/#minimum-gradle-config",
      "text": "Add to your module's build.gradle.kts : repositories { mavenCentral() } dependencies { implementation( org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.7 ) implementation( org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.7 ) implementation( com.rickbusarow.dispatch:dispatch-android-lifecycle-extensions:1.0.0-beta03 ) implementation( androidx.lifecycle:lifecycle-common:2.2.0 ) }",
      "title": "Minimum Gradle Config"
    },
    {
      "location": "modules/dispatch-android-lifecycle/",
      "text": "MODULE dispatch-android-lifecycle CoroutineScope functionality linked with an Android Lifecycle . Contents Types Member functions Extension functions Minimum Gradle Config Types Name Description LifecycleCoroutineScope MainCoroutineScope with a Lifecycle , capable of automatically cancelling and restarting coroutines along with that lifecycle. MinimumStatePolicy Defines the behavior of a Lifecycle -aware Job when it passes below its minimum Lifecycle.State Member functions Name Description launchOnCreate Creates a coroutine tied to a Lifecycle which will automatically enact a MinimumStatePolicy upon dropping below Lifecycle.State.CREATED launchOnStart Creates a coroutine tied to a Lifecycle which will automatically enact a MinimumStatePolicy upon dropping below Lifecycle.State.STARTED launchOnResume Creates a coroutine tied to a Lifecycle which will automatically enact a MinimumStatePolicy upon dropping below Lifecycle.State.RESUMED Extension functions LifecycleOwner extension suspending functions: Name Description onNextCreate Executes code one time upon reaching a state of Lifecycle.State.CREATED onNextStart Executes code one time upon reaching a state of Lifecycle.State.STARTED onNextResume Executes code one time upon reaching a state of Lifecycle.State.RESUMED Lifecycle extension suspending functions: Name Description onNextCreate Executes code one time upon reaching a state of Lifecycle.State.CREATED onNextStart Executes code one time upon reaching a state of Lifecycle.State.STARTED onNextResume Executes code one time upon reaching a state of Lifecycle.State.RESUMED Minimum Gradle Config Add to your module's build.gradle.kts : repositories { mavenCentral() } dependencies { implementation( org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.7 ) implementation( org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.7 ) implementation( com.rickbusarow.dispatch:dispatch-android-lifecycle:1.0.0-beta03 ) implementation( androidx.lifecycle:lifecycle-common:2.2.0 ) }",
      "title": "android-lifecycle"
    },
    {
      "location": "modules/dispatch-android-lifecycle/#module-dispatch-android-lifecycle",
      "text": "CoroutineScope functionality linked with an Android Lifecycle .",
      "title": "MODULE dispatch-android-lifecycle"
    },
    {
      "location": "modules/dispatch-android-lifecycle/#contents",
      "text": "Types Member functions Extension functions Minimum Gradle Config",
      "title": "Contents"
    },
    {
      "location": "modules/dispatch-android-lifecycle/#types",
      "text": "Name Description LifecycleCoroutineScope MainCoroutineScope with a Lifecycle , capable of automatically cancelling and restarting coroutines along with that lifecycle. MinimumStatePolicy Defines the behavior of a Lifecycle -aware Job when it passes below its minimum Lifecycle.State",
      "title": "Types"
    },
    {
      "location": "modules/dispatch-android-lifecycle/#member-functions",
      "text": "Name Description launchOnCreate Creates a coroutine tied to a Lifecycle which will automatically enact a MinimumStatePolicy upon dropping below Lifecycle.State.CREATED launchOnStart Creates a coroutine tied to a Lifecycle which will automatically enact a MinimumStatePolicy upon dropping below Lifecycle.State.STARTED launchOnResume Creates a coroutine tied to a Lifecycle which will automatically enact a MinimumStatePolicy upon dropping below Lifecycle.State.RESUMED",
      "title": "Member functions"
    },
    {
      "location": "modules/dispatch-android-lifecycle/#extension-functions",
      "text": "LifecycleOwner extension suspending functions: Name Description onNextCreate Executes code one time upon reaching a state of Lifecycle.State.CREATED onNextStart Executes code one time upon reaching a state of Lifecycle.State.STARTED onNextResume Executes code one time upon reaching a state of Lifecycle.State.RESUMED Lifecycle extension suspending functions: Name Description onNextCreate Executes code one time upon reaching a state of Lifecycle.State.CREATED onNextStart Executes code one time upon reaching a state of Lifecycle.State.STARTED onNextResume Executes code one time upon reaching a state of Lifecycle.State.RESUMED",
      "title": "Extension functions"
    },
    {
      "location": "modules/dispatch-android-lifecycle/#minimum-gradle-config",
      "text": "Add to your module's build.gradle.kts : repositories { mavenCentral() } dependencies { implementation( org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.7 ) implementation( org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.7 ) implementation( com.rickbusarow.dispatch:dispatch-android-lifecycle:1.0.0-beta03 ) implementation( androidx.lifecycle:lifecycle-common:2.2.0 ) }",
      "title": "Minimum Gradle Config"
    },
    {
      "location": "modules/dispatch-android-viewmodel/",
      "text": "Module dispatch-android-viewmodel The artifact I hope you don't need, but if you're not doing dependency injection, you probably do. Contents Examples Difference from AndroidX Custom CoroutineScope factories Automatic cancellation in onCleared() viewModelScope is not lifecycleScope Extending ViewModel Minimum Gradle Config Examples import dispatch.android.* // CoroutineViewModel is just a ViewModel with a lazy viewModelScope class SomeViewModel : CoroutineViewModel() { // ... init { // auto-creates a MainImmediateCoroutineScope which is closed in onCleared() viewModelScope. //... // multiple invocations use the same instance viewModelScope.launch { } // it works as a normal CoroutineScope (because it is) viewModelScope.launchMain { } } } class SomeApplication : Application() { override fun onCreate () { super .onCreate() // A custom factory can be set to add elements to the CoroutineContext ViewModelScopeFactory. set { MainImmediateCoroutineScope() + SomeCustomElement() } } } class SomeViewModelTest { val viewModel = SomeViewModel() @Before fun setUp () { // This custom factory can be used to use custom scopes for testing ViewModelScopeFactory. set { TestProvidedCoroutineScope() } } @After fun tearDown () { // The factory can also be reset to default ViewModelScopeFactory.reset() } @Test fun someTest () = runBlocking { // the AndroidX version is public, so it s public here as well. viewModel.viewModelScope.launch { } } } Difference from AndroidX This module is essentially a fork of androidx-lifecycle-viewmodel-ktx \u2014 the library which gives us the viewModelScope property. It exists entirely so that we can have a settable factory. This gives us a lot more options for JVM or instrumented tests, with custom dispatchers or other custom CoroutineContext elements. Custom CoroutineScope factories The way androidx-lifecycle-viewModel constructs its CoroutineScope is hard-coded , which eliminates the possibility of using a custom CoroutineContext such as a DispatcherProvider or IdlingDispatcher . With dispatch-android-lifecycle , we can set a custom factory. class SomeViewModelTest { @Before fun setUp () { // This custom factory can be used to use custom scopes for testing ViewModelScopeFactory. set { TestProvidedCoroutineScope() } // it could also return a specific instance val someTestScope = TestProvidedCoroutineScope() ViewModelScopeFactory. set { someTestScope } } @After fun tearDown () { // The factory can also be reset to default ViewModelScopeFactory.reset() } } Automatic cancellation in onCleared() Just like AndroidX, this version of viewModelScope is automatically cancelled in ViewModel.onCleared() . viewModelScope is not lifecycleScope It's important to remember that onCleared() is only called when a ViewModel is about to be destroyed -- when its associated LifecycleOwner (s) are all destroyed. This means that a viewModelScope is active while the LifecycleOwner is in the backstack. Consider this example: // Don t do this class SomeViewModel : CoroutineViewModel() { init { viewModelScope.launch { // this job will continue forever even if the ViewModel is on the backstack. someRepository.dataFlow.collect { parseData(it) } } } } A CoroutineScope in a ViewModel is better utilized for single-shot requests which shouldn't be restarted in the event of a configuration change. \"Observer\" behavior should be scoped to the associated view. // Maybe do this class SomeFragment : Fragment() { val viewModel: SomeViewModel by viewModels() init { lifecycleScope.launchWhenResumed { viewModel.dataFlow.collect { } } } } class SomeViewModel : CoroutineViewModel() { // a single shot request is made using the viewModelScope val lazyData by lazy { CompletableDeferred Data ().apply { viewModelScope.launch { complete(someRepository.getData()) } } } // collection of the Flow is done using the view s lifecycleScope, // meaning that it will stop as soon as the screen is in the backstack val dataFlow = someRepository.dataFlow.onEach { parseData(it) } } Extending ViewModel Since nothing about the clear event is actually exposed outside of ViewModel , it's necessary to extend ViewModel in order to consume it for cancelling the viewModelScope . This is especially galling since ViewModel could absolutely have just been an interface to begin with. Minimum Gradle Config Add to your module's build.gradle.kts : repositories { mavenCentral() } dependencies { implementation( org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.7 ) implementation( org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.7 ) implementation( com.rickbusarow.dispatch:dispatch-android-viewmodel:1.0.0-beta03 ) }",
      "title": "Android-viewmodel"
    },
    {
      "location": "modules/dispatch-android-viewmodel/#module-dispatch-android-viewmodel",
      "text": "The artifact I hope you don't need, but if you're not doing dependency injection, you probably do.",
      "title": "Module dispatch-android-viewmodel"
    },
    {
      "location": "modules/dispatch-android-viewmodel/#contents",
      "text": "Examples Difference from AndroidX Custom CoroutineScope factories Automatic cancellation in onCleared() viewModelScope is not lifecycleScope Extending ViewModel Minimum Gradle Config",
      "title": "Contents"
    },
    {
      "location": "modules/dispatch-android-viewmodel/#examples",
      "text": "import dispatch.android.* // CoroutineViewModel is just a ViewModel with a lazy viewModelScope class SomeViewModel : CoroutineViewModel() { // ... init { // auto-creates a MainImmediateCoroutineScope which is closed in onCleared() viewModelScope. //... // multiple invocations use the same instance viewModelScope.launch { } // it works as a normal CoroutineScope (because it is) viewModelScope.launchMain { } } } class SomeApplication : Application() { override fun onCreate () { super .onCreate() // A custom factory can be set to add elements to the CoroutineContext ViewModelScopeFactory. set { MainImmediateCoroutineScope() + SomeCustomElement() } } } class SomeViewModelTest { val viewModel = SomeViewModel() @Before fun setUp () { // This custom factory can be used to use custom scopes for testing ViewModelScopeFactory. set { TestProvidedCoroutineScope() } } @After fun tearDown () { // The factory can also be reset to default ViewModelScopeFactory.reset() } @Test fun someTest () = runBlocking { // the AndroidX version is public, so it s public here as well. viewModel.viewModelScope.launch { } } }",
      "title": "Examples"
    },
    {
      "location": "modules/dispatch-android-viewmodel/#difference-from-androidx",
      "text": "This module is essentially a fork of androidx-lifecycle-viewmodel-ktx \u2014 the library which gives us the viewModelScope property. It exists entirely so that we can have a settable factory. This gives us a lot more options for JVM or instrumented tests, with custom dispatchers or other custom CoroutineContext elements.",
      "title": "Difference from AndroidX"
    },
    {
      "location": "modules/dispatch-android-viewmodel/#custom-coroutinescope-factories",
      "text": "The way androidx-lifecycle-viewModel constructs its CoroutineScope is hard-coded , which eliminates the possibility of using a custom CoroutineContext such as a DispatcherProvider or IdlingDispatcher . With dispatch-android-lifecycle , we can set a custom factory. class SomeViewModelTest { @Before fun setUp () { // This custom factory can be used to use custom scopes for testing ViewModelScopeFactory. set { TestProvidedCoroutineScope() } // it could also return a specific instance val someTestScope = TestProvidedCoroutineScope() ViewModelScopeFactory. set { someTestScope } } @After fun tearDown () { // The factory can also be reset to default ViewModelScopeFactory.reset() } }",
      "title": "Custom CoroutineScope factories"
    },
    {
      "location": "modules/dispatch-android-viewmodel/#automatic-cancellation-in-oncleared",
      "text": "Just like AndroidX, this version of viewModelScope is automatically cancelled in ViewModel.onCleared() .",
      "title": "Automatic cancellation in onCleared()"
    },
    {
      "location": "modules/dispatch-android-viewmodel/#viewmodelscope-is-not-lifecyclescope",
      "text": "It's important to remember that onCleared() is only called when a ViewModel is about to be destroyed -- when its associated LifecycleOwner (s) are all destroyed. This means that a viewModelScope is active while the LifecycleOwner is in the backstack. Consider this example: // Don t do this class SomeViewModel : CoroutineViewModel() { init { viewModelScope.launch { // this job will continue forever even if the ViewModel is on the backstack. someRepository.dataFlow.collect { parseData(it) } } } } A CoroutineScope in a ViewModel is better utilized for single-shot requests which shouldn't be restarted in the event of a configuration change. \"Observer\" behavior should be scoped to the associated view. // Maybe do this class SomeFragment : Fragment() { val viewModel: SomeViewModel by viewModels() init { lifecycleScope.launchWhenResumed { viewModel.dataFlow.collect { } } } } class SomeViewModel : CoroutineViewModel() { // a single shot request is made using the viewModelScope val lazyData by lazy { CompletableDeferred Data ().apply { viewModelScope.launch { complete(someRepository.getData()) } } } // collection of the Flow is done using the view s lifecycleScope, // meaning that it will stop as soon as the screen is in the backstack val dataFlow = someRepository.dataFlow.onEach { parseData(it) } }",
      "title": "viewModelScope is not lifecycleScope"
    },
    {
      "location": "modules/dispatch-android-viewmodel/#extending-viewmodel",
      "text": "Since nothing about the clear event is actually exposed outside of ViewModel , it's necessary to extend ViewModel in order to consume it for cancelling the viewModelScope . This is especially galling since ViewModel could absolutely have just been an interface to begin with.",
      "title": "Extending ViewModel"
    },
    {
      "location": "modules/dispatch-android-viewmodel/#minimum-gradle-config",
      "text": "Add to your module's build.gradle.kts : repositories { mavenCentral() } dependencies { implementation( org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.7 ) implementation( org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.7 ) implementation( com.rickbusarow.dispatch:dispatch-android-viewmodel:1.0.0-beta03 ) }",
      "title": "Minimum Gradle Config"
    },
    {
      "location": "modules/dispatch-core/",
      "text": "MODULE dispatch-core Never reference Dispatchers again, and never inject a dispatchers interface into your classes. All the standard CoroutineDispatcher types are embedded in a CoroutineContext and can be accessed explicitly or via convenient extension functions . fun foo (scope: CoroutineScope) { scope.launchDefault { } scope.launchIO { } scope.launchMain { } scope.launchMainImmediate { } scope.launchUnconfined { } } You can define custom mappings via a factory , making testing much easier, or use the default, which simply maps to Dispatchers . // a standard DispatcherProvider is easy to create val myDefaultDispatchProvider = DispatcherProvider() // but they re also very extensible. This version is interchangeable and is convenient in some test scenarios. val myCustomDispatcherProvider = object : DispatcherProvider { override val default: CoroutineDispatcher = newSingleThreadCoroutineContext( default ) override val io: CoroutineDispatcher = newSingleThreadCoroutineContext( io ) override val main: CoroutineDispatcher get () = newSingleThreadCoroutineContext( main ) override val mainImmediate: CoroutineDispatcher get () = newSingleThreadCoroutineContext( mainImmediate ) override val unconfined: CoroutineDispatcher = newSingleThreadCoroutineContext( unconfined ) } Custom CoroutineScopes interfaces allow for more granularity when defining a class or function with a CoroutineScope dependency. There are also factory functions for conveniently creating any implementation, with a built-in DispatcherProvider . val mainScope = MainCoroutineScope() val someUIClass = SomeUIClass(mainScope) class SomeUIClass ( val coroutineScope: MainCoroutineScope) { fun foo () = coroutineScope.launch { // ... } } Contents Types Marker interfaces and factories Extensions Launch Async WithContext Flow Minimum Gradle Config Types Name Description DispatcherProvider Interface which provides the 5 standard CoroutineDispatcher properties of the Dispatchers object, but which can be embedded in a CoroutineContext DefaultDispatcherProvider Default implementation of DispatcherProvider which simply delegates to the corresponding properties in the Dispatchers singleton Marker interfaces and factories Name Dispatcher DefaultCoroutineScope DispatcherProvider.default IOCoroutineScope DispatcherProvider.io MainCoroutineScope DispatcherProvider.main MainImmediateCoroutineScope DispatcherProvider.mainImmediate UnconfinedCoroutineScope DispatcherProvider.unconfined Extensions Default IO Main Main.immediate Unconfined Job launchDefault launchIO launchMain launchMainImmediate launchUnconfined Deferred asyncDefault asyncIO asyncMain asyncMainImmediate asyncUnconfined suspend T withDefault withIO withMain withMainImmediate withUnconfined Flow T flowOnDefault flowOnIO flowOnMain flowOnMainImmediate flowOnUnconfined Launch fun foo (scope: CoroutineScope) { scope.launchDefault { } scope.launchIO { } scope.launchMain { } scope.launchMainImmediate { } scope.launchUnconfined { } } Async fun foo (scope: CoroutineScope) { scope.asyncDefault { } scope.asyncIO { } scope.asyncMain { } scope.asyncMainImmediate { } scope.asyncUnconfined { } } WithContext The CoroutineContext used for withContext comes from the coroutineContext top-level suspend property in kotlin.coroutines . It returns the current context, so the default , io , etc. used here are the ones defined in the CoroutineScope of the caller. There is no need to inject any other dependencies. suspend fun foo () { // note that we have no CoroutineContext withDefault { } withIO { } withMain { } withMainImmediate { } withUnconfined { } } Flow Like withContext , Flow typically doesn\u2019t get a CoroutineScope of its own. They inherit the coroutineContext from the collector in a pattern called context preservation . These new operators maintain context preservation ( they\u2019re forced to, actually ), and extract the coroutineContext from the collector. val someFlow = flow { } .flowOnDefault() .flowOnIO() .flowOnMain() .flowOnMainImmediate() .flowOnUnconfined() Minimum Gradle Config Add to your module's build.gradle.kts : repositories { mavenCentral() } dependencies { implementation( org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.7 ) implementation( org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.7 ) implementation( com.rickbusarow.dispatch:dispatch-core:1.0.0-beta03 ) }",
      "title": "Core"
    },
    {
      "location": "modules/dispatch-core/#module-dispatch-core",
      "text": "Never reference Dispatchers again, and never inject a dispatchers interface into your classes. All the standard CoroutineDispatcher types are embedded in a CoroutineContext and can be accessed explicitly or via convenient extension functions . fun foo (scope: CoroutineScope) { scope.launchDefault { } scope.launchIO { } scope.launchMain { } scope.launchMainImmediate { } scope.launchUnconfined { } } You can define custom mappings via a factory , making testing much easier, or use the default, which simply maps to Dispatchers . // a standard DispatcherProvider is easy to create val myDefaultDispatchProvider = DispatcherProvider() // but they re also very extensible. This version is interchangeable and is convenient in some test scenarios. val myCustomDispatcherProvider = object : DispatcherProvider { override val default: CoroutineDispatcher = newSingleThreadCoroutineContext( default ) override val io: CoroutineDispatcher = newSingleThreadCoroutineContext( io ) override val main: CoroutineDispatcher get () = newSingleThreadCoroutineContext( main ) override val mainImmediate: CoroutineDispatcher get () = newSingleThreadCoroutineContext( mainImmediate ) override val unconfined: CoroutineDispatcher = newSingleThreadCoroutineContext( unconfined ) } Custom CoroutineScopes interfaces allow for more granularity when defining a class or function with a CoroutineScope dependency. There are also factory functions for conveniently creating any implementation, with a built-in DispatcherProvider . val mainScope = MainCoroutineScope() val someUIClass = SomeUIClass(mainScope) class SomeUIClass ( val coroutineScope: MainCoroutineScope) { fun foo () = coroutineScope.launch { // ... } }",
      "title": "MODULE dispatch-core"
    },
    {
      "location": "modules/dispatch-core/#contents",
      "text": "Types Marker interfaces and factories Extensions Launch Async WithContext Flow Minimum Gradle Config",
      "title": "Contents"
    },
    {
      "location": "modules/dispatch-core/#types",
      "text": "Name Description DispatcherProvider Interface which provides the 5 standard CoroutineDispatcher properties of the Dispatchers object, but which can be embedded in a CoroutineContext DefaultDispatcherProvider Default implementation of DispatcherProvider which simply delegates to the corresponding properties in the Dispatchers singleton",
      "title": "Types"
    },
    {
      "location": "modules/dispatch-core/#marker-interfaces-and-factories",
      "text": "Name Dispatcher DefaultCoroutineScope DispatcherProvider.default IOCoroutineScope DispatcherProvider.io MainCoroutineScope DispatcherProvider.main MainImmediateCoroutineScope DispatcherProvider.mainImmediate UnconfinedCoroutineScope DispatcherProvider.unconfined",
      "title": "Marker interfaces and factories"
    },
    {
      "location": "modules/dispatch-core/#extensions",
      "text": "Default IO Main Main.immediate Unconfined Job launchDefault launchIO launchMain launchMainImmediate launchUnconfined Deferred asyncDefault asyncIO asyncMain asyncMainImmediate asyncUnconfined suspend T withDefault withIO withMain withMainImmediate withUnconfined Flow T flowOnDefault flowOnIO flowOnMain flowOnMainImmediate flowOnUnconfined",
      "title": "Extensions"
    },
    {
      "location": "modules/dispatch-core/#launch",
      "text": "fun foo (scope: CoroutineScope) { scope.launchDefault { } scope.launchIO { } scope.launchMain { } scope.launchMainImmediate { } scope.launchUnconfined { } }",
      "title": "Launch"
    },
    {
      "location": "modules/dispatch-core/#async",
      "text": "fun foo (scope: CoroutineScope) { scope.asyncDefault { } scope.asyncIO { } scope.asyncMain { } scope.asyncMainImmediate { } scope.asyncUnconfined { } }",
      "title": "Async"
    },
    {
      "location": "modules/dispatch-core/#withcontext",
      "text": "The CoroutineContext used for withContext comes from the coroutineContext top-level suspend property in kotlin.coroutines . It returns the current context, so the default , io , etc. used here are the ones defined in the CoroutineScope of the caller. There is no need to inject any other dependencies. suspend fun foo () { // note that we have no CoroutineContext withDefault { } withIO { } withMain { } withMainImmediate { } withUnconfined { } }",
      "title": "WithContext"
    },
    {
      "location": "modules/dispatch-core/#flow",
      "text": "Like withContext , Flow typically doesn\u2019t get a CoroutineScope of its own. They inherit the coroutineContext from the collector in a pattern called context preservation . These new operators maintain context preservation ( they\u2019re forced to, actually ), and extract the coroutineContext from the collector. val someFlow = flow { } .flowOnDefault() .flowOnIO() .flowOnMain() .flowOnMainImmediate() .flowOnUnconfined()",
      "title": "Flow"
    },
    {
      "location": "modules/dispatch-core/#minimum-gradle-config",
      "text": "Add to your module's build.gradle.kts : repositories { mavenCentral() } dependencies { implementation( org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.7 ) implementation( org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.7 ) implementation( com.rickbusarow.dispatch:dispatch-core:1.0.0-beta03 ) }",
      "title": "Minimum Gradle Config"
    },
    {
      "location": "modules/dispatch-detekt/",
      "text": "Module Dispatch-Detekt Contents Rules Setup Adding new dependencies Configuration Gradle Daemon bug Rules Name Description AndroidXLifecycleScope Looks for accidental usage of the androidx lifecyclescope extension. HardCodedDispatcher Detects use of a hard-coded reference to the kotlinx.coroutines.Dispatchers singleton. Setup If you don't already have Detekt set up in your project, follow the official quick start guide . After that is working, you need to add dependencies for the Detekt CLI and these extension rules to each module which will be analyzed. The easiest way to do this is to apply them from the root project -level gradle file. Adding new dependencies In root project-level build.gradle or build.gradle.kts : allprojects { dependencies { detekt( io.gitlab.arturbosch.detekt:detekt-cli:1.9.1 ) detektPlugins( com.rickbusarow.dispatch:dispatch-detekt:1.0.0-beta03 ) } } Configuration After adding the dependencies, you'll want to add parameters to your detekt config .yml file. If you don't already have a config file, you can create one by invoking: ./gradlew detektGenerateConfig Then, add the following to the bottom of the detekt-config.yml file: dispatch : active : true # disables all dispatch checks AndroidXLifecycleScope : # incorrect lifecycleScope active : true HardCodedDispatcher : # finds usage of Dispatchers.______ active : true allowDefaultDispatcher : false # if true, Detekt will ignore all usage of Dispatchers.Default allowIODispatcher : false # if true, Detekt will ignore all usage of Dispatchers.IO allowMainDispatcher : false # if true, Detekt will ignore all usage of Dispatchers.Main allowMainImmediateDispatcher : false # if true, Detekt will ignore all usage of Dispatchers.Main.immediate allowUnconfinedDispatcher : false # if true, Detekt will ignore all usage of Dispatchers.Unconfined Gradle Daemon bug There is an issue with ClassLoader caching which may cause issues the first time running Detekt. The workaround is to execute ./gradlew --stop once via command line. You should only ever need to do this one time, if at all. The fix for this has already been merged into Detekt.",
      "title": "Detekt"
    },
    {
      "location": "modules/dispatch-detekt/#module-dispatch-detekt",
      "text": "",
      "title": "Module Dispatch-Detekt"
    },
    {
      "location": "modules/dispatch-detekt/#contents",
      "text": "Rules Setup Adding new dependencies Configuration Gradle Daemon bug",
      "title": "Contents"
    },
    {
      "location": "modules/dispatch-detekt/#rules",
      "text": "Name Description AndroidXLifecycleScope Looks for accidental usage of the androidx lifecyclescope extension. HardCodedDispatcher Detects use of a hard-coded reference to the kotlinx.coroutines.Dispatchers singleton.",
      "title": "Rules"
    },
    {
      "location": "modules/dispatch-detekt/#setup",
      "text": "If you don't already have Detekt set up in your project, follow the official quick start guide . After that is working, you need to add dependencies for the Detekt CLI and these extension rules to each module which will be analyzed. The easiest way to do this is to apply them from the root project -level gradle file.",
      "title": "Setup"
    },
    {
      "location": "modules/dispatch-detekt/#adding-new-dependencies",
      "text": "In root project-level build.gradle or build.gradle.kts : allprojects { dependencies { detekt( io.gitlab.arturbosch.detekt:detekt-cli:1.9.1 ) detektPlugins( com.rickbusarow.dispatch:dispatch-detekt:1.0.0-beta03 ) } }",
      "title": "Adding new dependencies"
    },
    {
      "location": "modules/dispatch-detekt/#configuration",
      "text": "After adding the dependencies, you'll want to add parameters to your detekt config .yml file. If you don't already have a config file, you can create one by invoking: ./gradlew detektGenerateConfig Then, add the following to the bottom of the detekt-config.yml file: dispatch : active : true # disables all dispatch checks AndroidXLifecycleScope : # incorrect lifecycleScope active : true HardCodedDispatcher : # finds usage of Dispatchers.______ active : true allowDefaultDispatcher : false # if true, Detekt will ignore all usage of Dispatchers.Default allowIODispatcher : false # if true, Detekt will ignore all usage of Dispatchers.IO allowMainDispatcher : false # if true, Detekt will ignore all usage of Dispatchers.Main allowMainImmediateDispatcher : false # if true, Detekt will ignore all usage of Dispatchers.Main.immediate allowUnconfinedDispatcher : false # if true, Detekt will ignore all usage of Dispatchers.Unconfined",
      "title": "Configuration"
    },
    {
      "location": "modules/dispatch-detekt/#gradle-daemon-bug",
      "text": "There is an issue with ClassLoader caching which may cause issues the first time running Detekt. The workaround is to execute ./gradlew --stop once via command line. You should only ever need to do this one time, if at all. The fix for this has already been merged into Detekt.",
      "title": "Gradle Daemon bug"
    },
    {
      "location": "modules/dispatch-test-junit4/",
      "text": "MODULE dispatch-test-junit4 Contents Features Setting Dispatchers.Main This module replaces dispatch-test JUnit dependencies Minimum Gradle Config JUnit 5 interoperability Features In addition to all the functionality in dispatch-test , this module exposes a TestCoroutineRule to handle set-up and tear-down of a TestProvidedCoroutineScope . Since TestProvidedCoroutineScope is a TestCoroutineScope , this Rule also invokes cleanupTestCoroutines after the test. class SomeClassTest { @JvmField @Rule val rule = TestCoroutineRule() @Test fun `some test` () = runBlocking { val subject = SomeClass(rule) val job = subject.fireAndForget() // TODO: assertions go here } } class SomeClass ( val coroutineScope: CoroutineScope) { fun fireAndForget () = launch { } } Setting Dispatchers.Main Even though dispatch-core eliminates the need to use Dispatchers.Main in internal code, it\u2019s still possible that code which has yet to be migrated, or a third-party library is making use of the hard-coded dispatcher. Because of this, the rule still calls Dispatchers.setMain(...) in its setup and Dispatchers.resetMain() afterwards. This module replaces dispatch-test If using this module, there is no need to include the dispatch-test artifact in your dependencies. JUnit dependencies Minimum Gradle Config Because this is a JUnit 4 Rule, it requires a variant of that artifact. No external libraries are bundled as part of Dispatch, so you\u2019ll need to add it to your dependencies block yourself. The two official options would be: classic JUnit 4 org.junit.jupiter:junit-jupiter:4.13 JUnit 5 \"vintage\" org.junit.vintage:junit-vintage-engine:5.5.1 Add to your module's build.gradle.kts : repositories { mavenCentral() } dependencies { // core implementation( org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.7 ) implementation( org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.7 ) implementation( com.rickbusarow.dispatch:dispatch-core:1.0.0-beta03 ) // the junit4 artifact also provides the dispatch-test artifact testImplementation( com.rickbusarow.dispatch:dispatch-test-junit4:1.0.0-beta03 ) testImplementation( org.jetbrains.kotlinx:kotlinx-coroutines-test:1.3.7 ) } JUnit 5 interoperability Junit 5 provides a \u201cvintage\u201d (JUnit 4) artifact for legacy support (such as Robolectric or Android instrumented tests). Dispatch also supports running both in the same project by just adding both artifacts. Add to your module's build.gradle.kts : repositories { mavenCentral() } dependencies { // core implementation( org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.7 ) implementation( org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.7 ) implementation( com.rickbusarow.dispatch:dispatch-core:1.0.0-beta03 ) // the junit4 and junit5 artifacts also provides the dispatch-test artifact testImplementation( ccom.rickbusarow.dispatch:dispatch-test-junit4:1.0.0-beta03 ) testImplementation( ccom.rickbusarow.dispatch:dispatch-test-junit5:1.0.0-beta03 ) testImplementation( org.jetbrains.kotlinx:kotlinx-coroutines-test:1.3.7 ) }",
      "title": "Test-JUnit4"
    },
    {
      "location": "modules/dispatch-test-junit4/#module-dispatch-test-junit4",
      "text": "",
      "title": "MODULE dispatch-test-junit4"
    },
    {
      "location": "modules/dispatch-test-junit4/#contents",
      "text": "Features Setting Dispatchers.Main This module replaces dispatch-test JUnit dependencies Minimum Gradle Config JUnit 5 interoperability",
      "title": "Contents"
    },
    {
      "location": "modules/dispatch-test-junit4/#features",
      "text": "In addition to all the functionality in dispatch-test , this module exposes a TestCoroutineRule to handle set-up and tear-down of a TestProvidedCoroutineScope . Since TestProvidedCoroutineScope is a TestCoroutineScope , this Rule also invokes cleanupTestCoroutines after the test. class SomeClassTest { @JvmField @Rule val rule = TestCoroutineRule() @Test fun `some test` () = runBlocking { val subject = SomeClass(rule) val job = subject.fireAndForget() // TODO: assertions go here } } class SomeClass ( val coroutineScope: CoroutineScope) { fun fireAndForget () = launch { } }",
      "title": "Features"
    },
    {
      "location": "modules/dispatch-test-junit4/#setting-dispatchersmain",
      "text": "Even though dispatch-core eliminates the need to use Dispatchers.Main in internal code, it\u2019s still possible that code which has yet to be migrated, or a third-party library is making use of the hard-coded dispatcher. Because of this, the rule still calls Dispatchers.setMain(...) in its setup and Dispatchers.resetMain() afterwards.",
      "title": "Setting Dispatchers.Main"
    },
    {
      "location": "modules/dispatch-test-junit4/#this-module-replaces-dispatch-test",
      "text": "If using this module, there is no need to include the dispatch-test artifact in your dependencies.",
      "title": "This module replaces dispatch-test"
    },
    {
      "location": "modules/dispatch-test-junit4/#junit-dependencies",
      "text": "",
      "title": "JUnit dependencies"
    },
    {
      "location": "modules/dispatch-test-junit4/#minimum-gradle-config",
      "text": "Because this is a JUnit 4 Rule, it requires a variant of that artifact. No external libraries are bundled as part of Dispatch, so you\u2019ll need to add it to your dependencies block yourself. The two official options would be: classic JUnit 4 org.junit.jupiter:junit-jupiter:4.13 JUnit 5 \"vintage\" org.junit.vintage:junit-vintage-engine:5.5.1 Add to your module's build.gradle.kts : repositories { mavenCentral() } dependencies { // core implementation( org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.7 ) implementation( org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.7 ) implementation( com.rickbusarow.dispatch:dispatch-core:1.0.0-beta03 ) // the junit4 artifact also provides the dispatch-test artifact testImplementation( com.rickbusarow.dispatch:dispatch-test-junit4:1.0.0-beta03 ) testImplementation( org.jetbrains.kotlinx:kotlinx-coroutines-test:1.3.7 ) }",
      "title": "Minimum Gradle Config"
    },
    {
      "location": "modules/dispatch-test-junit4/#junit-5-interoperability",
      "text": "Junit 5 provides a \u201cvintage\u201d (JUnit 4) artifact for legacy support (such as Robolectric or Android instrumented tests). Dispatch also supports running both in the same project by just adding both artifacts. Add to your module's build.gradle.kts : repositories { mavenCentral() } dependencies { // core implementation( org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.7 ) implementation( org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.7 ) implementation( com.rickbusarow.dispatch:dispatch-core:1.0.0-beta03 ) // the junit4 and junit5 artifacts also provides the dispatch-test artifact testImplementation( ccom.rickbusarow.dispatch:dispatch-test-junit4:1.0.0-beta03 ) testImplementation( ccom.rickbusarow.dispatch:dispatch-test-junit5:1.0.0-beta03 ) testImplementation( org.jetbrains.kotlinx:kotlinx-coroutines-test:1.3.7 ) }",
      "title": "JUnit 5 interoperability"
    },
    {
      "location": "modules/dispatch-test-junit5/",
      "text": "MODULE dispatch-test-junit5 Contents Features CoroutineTest example CoroutineTestExtension example Setting Dispatchers.Main This module replaces dispatch-test JUnit dependencies Minimum Gradle Config JUnit 4 interoperability Features In addition to all the functionality in dispatch-test , this module exposes a JUnit 5 CoroutineTestExtension and CoroutineTest annotation to handle set-up and tear-down of a TestProvidedCoroutineScope . Since TestProvidedCoroutineScope is a TestCoroutineScope , this Extension also invokes cleanupTestCoroutines after the test. CoroutineTest example @CoroutineTest(CustomScopeFactory :: class ) class SomeClassTest ( val testScope: TestProvidedCoroutineScope ) { @Test fun `some test` () = runBlocking { val subject = SomeClass(testScope) val job = subject.fireAndForget() // TODO: assertions go here } } class SomeClass ( val coroutineScope: CoroutineScope) { fun fireAndForget () = launch { } } class CustomScopeFactory : CoroutineTestExtension.ScopeFactory() { override fun create () = TestProvidedCoroutineScope(context = Job()) } CoroutineTestExtension example class SomeClassTest { @JvmField @RegisterExtension val extension = CoroutineTestExtension() @Test fun `some test` (scope: TestProvidedCoroutineScope) = runBlocking { val subject = SomeClass(scope) val job = subject.fireAndForget() // TODO: assertions go here } } class SomeClass ( val coroutineScope: CoroutineScope) { fun fireAndForget () = launch { } } Setting Dispatchers.Main Even though dispatch-core eliminates the need to use Dispatchers.Main in internal code, it\u2019s still possible that code which has yet to be migrated, or a third-party library is making use of the hard-coded dispatcher. Because of this, the extension still calls Dispatchers.setMain(...) in its setup and Dispatchers.resetMain() afterwards. This module replaces dispatch-test If using this module, there is no need to include the dispatch-test artifact in your dependencies. JUnit dependencies Minimum Gradle Config Because this is a JUnit 5 Extension, it requires a the JUnit 5 artifact. No external libraries are bundled as part of Dispatch, so you\u2019ll need to add it to your dependencies block yourself. org.junit.jupiter:junit-jupiter:5.6.2 Add to your module's build.gradle.kts : repositories { mavenCentral() } dependencies { // core implementation( org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.7 ) implementation( org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.7 ) implementation( com.rickbusarow.dispatch:dispatch-core:1.0.0-beta03 ) // the junit5 artifact also provides the dispatch-test artifact testImplementation( com.rickbusarow.dispatch:dispatch-test-junit5:1.0.0-beta03 ) testImplementation( org.jetbrains.kotlinx:kotlinx-coroutines-test:1.3.7 ) testImplementation( org.junit.jupiter:junit-jupiter:5.6.2 ) } JUnit 4 interoperability Junit 4 provides a \u201cvintage\u201d (JUnit 4) artifact for legacy support (such as Robolectric or Android instrumented tests). Dispatch also supports running both in the same project by just adding both artifacts. Add to your module's build.gradle.kts : repositories { mavenCentral() } dependencies { // core implementation( org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.7 ) implementation( org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.7 ) implementation( com.rickbusarow.dispatch:dispatch-core:1.0.0-beta03 ) // the junit4 and junit5 artifacts also provides the dispatch-test artifact testImplementation( com.rickbusarow.dispatch:dispatch-test-junit4:1.0.0-beta03 ) testImplementation( com.rickbusarow.dispatch:dispatch-test-junit5:1.0.0-beta03 ) testImplementation( org.junit.jupiter:junit-jupiter:5.6.2 ) testImplementation( org.junit.vintage:junit-vintage-engine:5.6.2 ) testImplementation( org.jetbrains.kotlinx:kotlinx-coroutines-test:1.3.7 ) }",
      "title": "Test-JUnit5"
    },
    {
      "location": "modules/dispatch-test-junit5/#module-dispatch-test-junit5",
      "text": "",
      "title": "MODULE dispatch-test-junit5"
    },
    {
      "location": "modules/dispatch-test-junit5/#contents",
      "text": "Features CoroutineTest example CoroutineTestExtension example Setting Dispatchers.Main This module replaces dispatch-test JUnit dependencies Minimum Gradle Config JUnit 4 interoperability",
      "title": "Contents"
    },
    {
      "location": "modules/dispatch-test-junit5/#features",
      "text": "In addition to all the functionality in dispatch-test , this module exposes a JUnit 5 CoroutineTestExtension and CoroutineTest annotation to handle set-up and tear-down of a TestProvidedCoroutineScope . Since TestProvidedCoroutineScope is a TestCoroutineScope , this Extension also invokes cleanupTestCoroutines after the test.",
      "title": "Features"
    },
    {
      "location": "modules/dispatch-test-junit5/#coroutinetest-example",
      "text": "@CoroutineTest(CustomScopeFactory :: class ) class SomeClassTest ( val testScope: TestProvidedCoroutineScope ) { @Test fun `some test` () = runBlocking { val subject = SomeClass(testScope) val job = subject.fireAndForget() // TODO: assertions go here } } class SomeClass ( val coroutineScope: CoroutineScope) { fun fireAndForget () = launch { } } class CustomScopeFactory : CoroutineTestExtension.ScopeFactory() { override fun create () = TestProvidedCoroutineScope(context = Job()) }",
      "title": "CoroutineTest example"
    },
    {
      "location": "modules/dispatch-test-junit5/#coroutinetestextension-example",
      "text": "class SomeClassTest { @JvmField @RegisterExtension val extension = CoroutineTestExtension() @Test fun `some test` (scope: TestProvidedCoroutineScope) = runBlocking { val subject = SomeClass(scope) val job = subject.fireAndForget() // TODO: assertions go here } } class SomeClass ( val coroutineScope: CoroutineScope) { fun fireAndForget () = launch { } }",
      "title": "CoroutineTestExtension example"
    },
    {
      "location": "modules/dispatch-test-junit5/#setting-dispatchersmain",
      "text": "Even though dispatch-core eliminates the need to use Dispatchers.Main in internal code, it\u2019s still possible that code which has yet to be migrated, or a third-party library is making use of the hard-coded dispatcher. Because of this, the extension still calls Dispatchers.setMain(...) in its setup and Dispatchers.resetMain() afterwards.",
      "title": "Setting Dispatchers.Main"
    },
    {
      "location": "modules/dispatch-test-junit5/#this-module-replaces-dispatch-test",
      "text": "If using this module, there is no need to include the dispatch-test artifact in your dependencies.",
      "title": "This module replaces dispatch-test"
    },
    {
      "location": "modules/dispatch-test-junit5/#junit-dependencies",
      "text": "",
      "title": "JUnit dependencies"
    },
    {
      "location": "modules/dispatch-test-junit5/#minimum-gradle-config",
      "text": "Because this is a JUnit 5 Extension, it requires a the JUnit 5 artifact. No external libraries are bundled as part of Dispatch, so you\u2019ll need to add it to your dependencies block yourself. org.junit.jupiter:junit-jupiter:5.6.2 Add to your module's build.gradle.kts : repositories { mavenCentral() } dependencies { // core implementation( org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.7 ) implementation( org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.7 ) implementation( com.rickbusarow.dispatch:dispatch-core:1.0.0-beta03 ) // the junit5 artifact also provides the dispatch-test artifact testImplementation( com.rickbusarow.dispatch:dispatch-test-junit5:1.0.0-beta03 ) testImplementation( org.jetbrains.kotlinx:kotlinx-coroutines-test:1.3.7 ) testImplementation( org.junit.jupiter:junit-jupiter:5.6.2 ) }",
      "title": "Minimum Gradle Config"
    },
    {
      "location": "modules/dispatch-test-junit5/#junit-4-interoperability",
      "text": "Junit 4 provides a \u201cvintage\u201d (JUnit 4) artifact for legacy support (such as Robolectric or Android instrumented tests). Dispatch also supports running both in the same project by just adding both artifacts. Add to your module's build.gradle.kts : repositories { mavenCentral() } dependencies { // core implementation( org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.7 ) implementation( org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.7 ) implementation( com.rickbusarow.dispatch:dispatch-core:1.0.0-beta03 ) // the junit4 and junit5 artifacts also provides the dispatch-test artifact testImplementation( com.rickbusarow.dispatch:dispatch-test-junit4:1.0.0-beta03 ) testImplementation( com.rickbusarow.dispatch:dispatch-test-junit5:1.0.0-beta03 ) testImplementation( org.junit.jupiter:junit-jupiter:5.6.2 ) testImplementation( org.junit.vintage:junit-vintage-engine:5.6.2 ) testImplementation( org.jetbrains.kotlinx:kotlinx-coroutines-test:1.3.7 ) }",
      "title": "JUnit 4 interoperability"
    },
    {
      "location": "modules/dispatch-test/",
      "text": "MODULE dispatch-test Test helpers for the dispatch-core module. Most of the tools you need to automatically handle DispatcherProvider in your tests. (see dispatch-test-junit4 or dispatch-test-junit5 for the rest.) Contents TestDispatcherProvider Constructor with default arguments Single-arg factory Basic TestDispatcherProvider TestProvidedCoroutineScope Builders Minimum Gradle Config TestDispatcherProvider Testing version of the DispatcherProvider with three main styles of creation: Constructor with default arguments (link) Each property becomes its own TestCoroutineDispatcher by default, but may be replaced by any CoroutineDispatcher . val customTestDispatcherProvider = TestDispatcherProvider( default = newSingleThreadContext( default ), io = newSingleThreadContext( io ), main = newSingleThreadContext( main ), mainImmediate = newSingleThreadContext( main immediate ), unconfined = newSingleThreadContext( unconfined ) ) val defaultTetsDispatcherProvider = TestDispatcherProvider() Single-arg factory (link) Another option is to pass a single CoroutineDispatcher , which is then used to populate all fields. val dispatcher = newSingleThreadContext( custom ) val dispatcherProvider = TestDispatcherProvider(dispatcher) dispatcherProvider.default shouldBe myDispatcher dispatcherProvider.io shouldBe myDispatcher dispatcherProvider.main shouldBe myDispatcher dispatcherProvider.mainImmediate shouldBe myDispatcher dispatcherProvider.unconfined shouldBe myDispatcher Basic TestDispatcherProvider (link) Sometimes we want to have the normal dispatch behaviors of a production environment, just without the awkward mechanics of Dispatchers.setMain . This is essentially DefaultDispatcherProvider except with a single-threaded executor handling the \"main\" thread. fun TestBasicDispatcherProvider (): TestDispatcherProvider { val mainThread = newSingleThreadContext( main thread proxy ) return TestDispatcherProvider( default = Dispatchers.Default, io = Dispatchers.IO, main = mainThread, mainImmediate = mainThread, unconfined = Dispatchers.Unconfined ) } TestProvidedCoroutineScope (link) A polymorphic CoroutineScope which implements all the type-safe versions from dispatch-core , as well as TestCoroutineScope . This type may be injected anywhere, regardless of the requirement. Builders Sometimes, instead of explicitly creating a CoroutineScope object, we prefer to just use a coroutineScope builder function within a function. @Test fun some_test () = runBlockingProvided { someSuspendFunction() } @Test fun some_test () = testProvided { someSuspendFunctionWithADelay() } Name Description runBlockingProvided Uses runBlocking , but injects a DispatcherProvider into its CoroutineScope . Use this function if you want normal dispatch behavior. testProvided Uses runBlockingTest , but injects a DispatcherProvider into its TestCoroutineScope . Use this function if you want the explicit time control of runBlockingTest . Minimum Gradle Config Add to your module's build.gradle.kts : repositories { mavenCentral() } dependencies { // core implementation( org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.7 ) implementation( org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.7 ) implementation( com.rickbusarow.dispatch:dispatch-core:1.0.0-beta03 ) testImplementation( com.rickbusarow.dispatch:dispatch-test:1.0.0-beta03 ) testImplementation( org.jetbrains.kotlinx:kotlinx-coroutines-test:1.3.7 ) }",
      "title": "Test-Core"
    },
    {
      "location": "modules/dispatch-test/#module-dispatch-test",
      "text": "Test helpers for the dispatch-core module. Most of the tools you need to automatically handle DispatcherProvider in your tests. (see dispatch-test-junit4 or dispatch-test-junit5 for the rest.)",
      "title": "MODULE dispatch-test"
    },
    {
      "location": "modules/dispatch-test/#contents",
      "text": "TestDispatcherProvider Constructor with default arguments Single-arg factory Basic TestDispatcherProvider TestProvidedCoroutineScope Builders Minimum Gradle Config",
      "title": "Contents"
    },
    {
      "location": "modules/dispatch-test/#testdispatcherprovider",
      "text": "Testing version of the DispatcherProvider with three main styles of creation:",
      "title": "TestDispatcherProvider"
    },
    {
      "location": "modules/dispatch-test/#constructor-with-default-arguments",
      "text": "(link) Each property becomes its own TestCoroutineDispatcher by default, but may be replaced by any CoroutineDispatcher . val customTestDispatcherProvider = TestDispatcherProvider( default = newSingleThreadContext( default ), io = newSingleThreadContext( io ), main = newSingleThreadContext( main ), mainImmediate = newSingleThreadContext( main immediate ), unconfined = newSingleThreadContext( unconfined ) ) val defaultTetsDispatcherProvider = TestDispatcherProvider()",
      "title": "Constructor with default arguments"
    },
    {
      "location": "modules/dispatch-test/#single-arg-factory",
      "text": "(link) Another option is to pass a single CoroutineDispatcher , which is then used to populate all fields. val dispatcher = newSingleThreadContext( custom ) val dispatcherProvider = TestDispatcherProvider(dispatcher) dispatcherProvider.default shouldBe myDispatcher dispatcherProvider.io shouldBe myDispatcher dispatcherProvider.main shouldBe myDispatcher dispatcherProvider.mainImmediate shouldBe myDispatcher dispatcherProvider.unconfined shouldBe myDispatcher",
      "title": "Single-arg factory"
    },
    {
      "location": "modules/dispatch-test/#basic-testdispatcherprovider",
      "text": "(link) Sometimes we want to have the normal dispatch behaviors of a production environment, just without the awkward mechanics of Dispatchers.setMain . This is essentially DefaultDispatcherProvider except with a single-threaded executor handling the \"main\" thread. fun TestBasicDispatcherProvider (): TestDispatcherProvider { val mainThread = newSingleThreadContext( main thread proxy ) return TestDispatcherProvider( default = Dispatchers.Default, io = Dispatchers.IO, main = mainThread, mainImmediate = mainThread, unconfined = Dispatchers.Unconfined ) }",
      "title": "Basic TestDispatcherProvider"
    },
    {
      "location": "modules/dispatch-test/#testprovidedcoroutinescope",
      "text": "(link) A polymorphic CoroutineScope which implements all the type-safe versions from dispatch-core , as well as TestCoroutineScope . This type may be injected anywhere, regardless of the requirement.",
      "title": "TestProvidedCoroutineScope"
    },
    {
      "location": "modules/dispatch-test/#builders",
      "text": "Sometimes, instead of explicitly creating a CoroutineScope object, we prefer to just use a coroutineScope builder function within a function. @Test fun some_test () = runBlockingProvided { someSuspendFunction() } @Test fun some_test () = testProvided { someSuspendFunctionWithADelay() } Name Description runBlockingProvided Uses runBlocking , but injects a DispatcherProvider into its CoroutineScope . Use this function if you want normal dispatch behavior. testProvided Uses runBlockingTest , but injects a DispatcherProvider into its TestCoroutineScope . Use this function if you want the explicit time control of runBlockingTest .",
      "title": "Builders"
    },
    {
      "location": "modules/dispatch-test/#minimum-gradle-config",
      "text": "Add to your module's build.gradle.kts : repositories { mavenCentral() } dependencies { // core implementation( org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.7 ) implementation( org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.7 ) implementation( com.rickbusarow.dispatch:dispatch-core:1.0.0-beta03 ) testImplementation( com.rickbusarow.dispatch:dispatch-test:1.0.0-beta03 ) testImplementation( org.jetbrains.kotlinx:kotlinx-coroutines-test:1.3.7 ) }",
      "title": "Minimum Gradle Config"
    }
  ]
}
