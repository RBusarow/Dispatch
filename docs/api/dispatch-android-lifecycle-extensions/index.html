<!--
  ~ Copyright (C) 2020 Rick Busarow
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~      http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<html>
<head>
    <meta charset="UTF-8" content="width=device-width, initial-scale=1" name="viewport">
    <title>dispatch-android-lifecycle-extensions</title>
    <link href="../images/logo-icon.svg" rel="icon" type="image/svg">
    <link href="../styles/style.css" rel="Stylesheet">
    <script async="async" src="../scripts/navigationLoader.js" type="text/javascript"></script>
    <script async="async" src="../scripts/platformContentHandler.js"
            type="text/javascript"></script>
    <script async="async" src="../scripts/sourceset_dependencies.js"
            type="text/javascript"></script>
    <script async="async" src="../scripts/clipboard.js" type="text/javascript"></script>
    <link href="../styles/jetbrains-mono.css" rel="Stylesheet">
    <script>var pathToRoot = "../";</script>
</head>
<body>
<div id="container">
    <div id="leftColumn">
        <div id="logo"></div>
        <div id="paneSearch"></div>
        <div id="sideMenu"></div>
    </div>
    <div id="main">
        <div id="leftToggler"><span class="icon-toggler"></span></div>
        <div id="searchBar"></div>
        <script src="../scripts/pages.js" type="text/javascript"></script>
        <script src="../scripts/main.js" type="text/javascript"></script>
        <div id="content" pageIds="////PointingToDeclaration/">
            <div class="breadcrumbs"><a href="index.html">dispatch-android-lifecycle-extensions</a>
            </div>
            <div class="cover ">
                <h1 class="cover"><a data-name="dispatch-android-lifecycle-extensions"></a><span>dispatch-android-lifecycle-extensions</span>
                </h1>
                <div class="platform-hinted UnderCoverText"
                     data-platform-hinted="data-platform-hinted">
                    <div class="content sourceset-depenent-content" data-active=""
                         data-togglable=":dispatch-android-lifecycle-extensions:dokkaHtml/release">
                        <p class="paragraph">
                        <h2 class=""><a></a> Contents</h2>
                        <p class="paragraph">&lt;!--- TOC --&gt;</p>
                        <ul>
                            <li><p class="paragraph">#api</p></li>
                            <ul>
                                <li><p class="paragraph">#one-time-suspend-functions</p></li>
                            </ul>
                            <li><p class="paragraph">#difference-from-androidx</p></li>
                            <li><p class="paragraph">#custom-coroutinescope-factories</p></li>
                            <li><p class="paragraph">#automatic-lifecycle-jobs</p></li>
                            <li><p class="paragraph">#minimum-gradle-config</p></li>
                        </ul>
                        <p class="paragraph">&lt;!--- END --&gt;</p>
                        <h2 class=""><a></a> Api</h2>
                        <h3 class=""><a></a> One-time suspend functions</h3>
                        <p class="paragraph">Examples</p>
                        <div class="sample-container"><code class="" theme="idea">
                            <pre>import dispatch.android.*<br><br>// This could be any LifecycleOwner -- Fragments, Activities, Services...<br>class SomeScreen : Fragment() {<br><br>  init {<br><br>    // auto-created MainImmediateCoroutineScope which is lifecycle-aware<br>    lifecycleScope //...<br><br>    // active only when &quot;resumed&quot;.  starts a fresh coroutine each time<br>    // this is a rough proxy for LiveData behavior<br>    lifecycleScope.launchEveryResume {  }<br><br>    // active only when &quot;started&quot;.  starts a fresh coroutine each time<br>    lifecycleScope.launchEveryStart {  }<br><br>    // launch when created, automatically stop on destroy<br>    lifecycleScope.launchEveryCreate {  }<br><br>    // it works as a normal CoroutineScope as well (because it is)<br>    lifecycleScope.launchMain {  }<br><br>  }<br>}</pre>
                        </code></div>
                        <div class="sample-container"><code class="" theme="idea">
                            <pre>class SomeApplication : Application() {<br>  override fun onCreate() {<br>    super.onCreate()<br>    // A custom factory can be set to add elements to the CoroutineContext<br>    LifecycleScopeFactory.set { MainImmediateContext() + SomeCustomElement() }<br>  }<br>}</pre>
                        </code></div>
                        <div class="sample-container"><code class="" theme="idea">
                            <pre>class SomeEspressoTest {<br>  @Before<br>  fun setUp() {<br>    // This custom factory can be used to use custom scopes for testing,<br>    // such as an idling dispatcher<br>    LifecycleScopeFactory.set { MainImmediateIdlingCoroutineScope().coroutineContext }<br>  }<br><br>  @After<br>  fun tearDown() {<br>    // The factory can also be reset to default<br>    LifecycleScopeFactory.reset()<br>  }<br>}</pre>
                        </code></div>
                        <h2 class=""><a></a> Difference from AndroidX</h2>
                        <p class="paragraph">This module is really just a slightly different version
                            of
                            <a href="https://developer.android.com/jetpack/androidx/releases/lifecycle">androidx-lifecycle-runtime-ktx</a>
                            â€” the library which gives us the <a
                                    href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-master-dev:lifecycle/lifecycle-runtime-ktx/src/main/java/androidx/lifecycle/Lifecycle.kt;l=44">lifecycleScope</a>
                            property.</p>
                        <p class="paragraph">Why not just use AndroidX? Because we need two things
                            it doesn't offer.</p>
                        <h2 class=""><a></a> Custom CoroutineScope factories</h2>
                        <p class="paragraph">The way <code>androidx-lifecycle-runtime</code>
                            constructs its <a
                                    href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">CoroutineScope</a>
                            is
                            <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-master-dev:lifecycle/lifecycle-runtime-ktx/src/main/java/androidx/lifecycle/Lifecycle.kt;l=44">hard-coded</a>,
                            which eliminates the possibility of using a custom <a
                                    href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/">CoroutineContext</a>
                            such as a <code>DispatcherProvider</code> or <a
                                    href="https://rbusarow.github.io/Dispatch/dispatch-android-espresso//dispatch.android.espresso/-idling-dispatcher/index.html">IdlingDispatcher</a>.
                            With <code>dispatch.android.lifecycle</code>, we can set a custom
                            factory.</p>
                        <div class="sample-container"><code class="" theme="idea">
                            <pre>class SomeFragmentEspressoTest {<br><br>  // Not part of this artifact.  see dispatch-android-espresso<br>  @JvmField @Rule val idlingRule = IdlingDispatcherProviderRule()<br><br>  @Before<br>  fun setUp() {<br>    // set a custom factory which is applied to all newly created lifecycleScopes<br>    LifecycleScopeFactory.set {<br>      MainImmediateContext() + idlingRule.dispatcherProvider<br>    }<br><br>    // now SomeFragment will use an IdlingDispatcher in its CoroutineScope<br>  }<br>}</pre>
                        </code></div>
                        <h2 class=""><a></a> Automatic lifecycle jobs</h2>
                        <p class="paragraph">Structured concurrency relies upon cancellation, but <a
                                href="https://developer.android.com/jetpack/androidx/releases/lifecycle">androidx-lifecycle-runtime.ktx</a>
                            doesn't cancel. It uses a special <a
                                    href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-master-dev:lifecycle/lifecycle-runtime-ktx/src/main/java/androidx/lifecycle/PausingDispatcher.kt">PausingDispatcher</a>.
                            This pausing behavior then leaks upstream, creating backpressure and
                            potentially deadlocks.</p>
                        <p class="paragraph">There's a <a
                                href="https://issuetracker.google.com/issues/146370660">bug filed in
                            their issue tracker</a>, but 2.2.0 got released anyway.</p>
                        <p class="paragraph">This library's API surface is the same as that within
                            the AndroidX version, but has a different strategy for handling
                            lifecycle events. When a lifecycle state enters the desired range, such
                            as at <code>ON_RESUME</code>, a new coroutine is created. When the state
                            exists the range, that coroutine is cancelled. If the lifecycle state
                            enters the desired range again, a new coroutine is created.</p>
                        <div class="sample-container"><code class="" theme="idea">
                            <pre>import dispatch.android.*<br><br>class SomeFragment : Fragment() {<br><br>  val viewModel: SomeViewModel by viewModels()<br><br>  init {<br>    // automatically created CoroutineScope using the factory described above<br>    lifecycleScope.launchWhenResumed {<br>      viewModel.someFlow.consume {  }<br>    }<br>  }<br><br>}</pre>
                        </code></div>
                        <p class="paragraph">This has the desired effect of not leaking backpressure
                            upstream (which in this example is the <code>viewModel</code>).</p>
                        <h2 class=""><a></a> Minimum Gradle Config</h2>
                        <p class="paragraph">Add to your module's <code>build.gradle.kts</code>:</p>
                        <div class="sample-container"><code class="" theme="idea">
                            <pre>repositories {<br>  mavenCentral()<br>}<br><br>dependencies {<br><br>  implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.8&quot;)<br>  implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.8&quot;)<br>  implementation(&quot;com.rickbusarow.dispatch:dispatch-android-lifecycle-extensions:1.0.0-beta04&quot;)<br><br>  implementation(&quot;androidx.lifecycle:lifecycle-common:2.2.0&quot;)<br>}</pre>
                        </code></div>
                        <p class="paragraph">&lt;!--- MODULE dispatch-core--&gt;</p>
                        <p class="paragraph">&lt;!--- INDEX --&gt;</p>
                        <p class="paragraph">&lt;!--- MODULE dispatch-test--&gt;</p>
                        <p class="paragraph">&lt;!--- INDEX --&gt;</p>
                        <p class="paragraph">&lt;!--- MODULE dispatch-test-junit4--&gt;</p>
                        <p class="paragraph">&lt;!--- INDEX --&gt;</p>
                        <p class="paragraph">&lt;!--- MODULE dispatch-test-junit5--&gt;</p>
                        <p class="paragraph">&lt;!--- INDEX --&gt;</p>
                        <p class="paragraph">&lt;!--- MODULE dispatch-android-espresso--&gt;</p>
                        <p class="paragraph">&lt;!--- INDEX --&gt;</p>
                        <p class="paragraph">&lt;!--- MODULE dispatch-android-lifecycle--&gt;</p>
                        <p class="paragraph">&lt;!--- INDEX --&gt;</p>
                        <p class="paragraph">&lt;!--- MODULE dispatch-android-viewmodel--&gt;</p>
                        <p class="paragraph">&lt;!--- INDEX --&gt;</p>
                        <p class="paragraph">&lt;!--- MODULE dispatch-android-viewmodel--&gt;</p>
                        <p class="paragraph">&lt;!--- INDEX --&gt;</p>
                        <p class="paragraph">&lt;!--- END --&gt;</p></p><p class="paragraph">
                        <h2 class=""><a></a> Contents</h2>
                        <p class="paragraph">&lt;!--- TOC --&gt;</p>
                        <ul>
                            <li><p class="paragraph">#api</p></li>
                            <ul>
                                <li><p class="paragraph">#one-time-suspend-functions</p></li>
                            </ul>
                            <li><p class="paragraph">#difference-from-androidx</p></li>
                            <li><p class="paragraph">#custom-coroutinescope-factories</p></li>
                            <li><p class="paragraph">#automatic-lifecycle-jobs</p></li>
                            <li><p class="paragraph">#minimum-gradle-config</p></li>
                        </ul>
                        <p class="paragraph">&lt;!--- END --&gt;</p>
                        <h2 class=""><a></a> Api</h2>
                        <h3 class=""><a></a> One-time suspend functions</h3>
                        <p class="paragraph">Examples</p>
                        <div class="sample-container"><code class="" theme="idea">
                            <pre>import dispatch.android.*<br><br>// This could be any LifecycleOwner -- Fragments, Activities, Services...<br>class SomeScreen : Fragment() {<br><br>  init {<br><br>    // auto-created MainImmediateCoroutineScope which is lifecycle-aware<br>    lifecycleScope //...<br><br>    // active only when &quot;resumed&quot;.  starts a fresh coroutine each time<br>    // this is a rough proxy for LiveData behavior<br>    lifecycleScope.launchEveryResume {  }<br><br>    // active only when &quot;started&quot;.  starts a fresh coroutine each time<br>    lifecycleScope.launchEveryStart {  }<br><br>    // launch when created, automatically stop on destroy<br>    lifecycleScope.launchEveryCreate {  }<br><br>    // it works as a normal CoroutineScope as well (because it is)<br>    lifecycleScope.launchMain {  }<br><br>  }<br>}</pre>
                        </code></div>
                        <div class="sample-container"><code class="" theme="idea">
                            <pre>class SomeApplication : Application() {<br>  override fun onCreate() {<br>    super.onCreate()<br>    // A custom factory can be set to add elements to the CoroutineContext<br>    LifecycleScopeFactory.set { MainImmediateContext() + SomeCustomElement() }<br>  }<br>}</pre>
                        </code></div>
                        <div class="sample-container"><code class="" theme="idea">
                            <pre>class SomeEspressoTest {<br>  @Before<br>  fun setUp() {<br>    // This custom factory can be used to use custom scopes for testing,<br>    // such as an idling dispatcher<br>    LifecycleScopeFactory.set { MainImmediateIdlingCoroutineScope().coroutineContext }<br>  }<br><br>  @After<br>  fun tearDown() {<br>    // The factory can also be reset to default<br>    LifecycleScopeFactory.reset()<br>  }<br>}</pre>
                        </code></div>
                        <h2 class=""><a></a> Difference from AndroidX</h2>
                        <p class="paragraph">This module is really just a slightly different version
                            of
                            <a href="https://developer.android.com/jetpack/androidx/releases/lifecycle">androidx-lifecycle-runtime-ktx</a>
                            â€” the library which gives us the <a
                                    href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-master-dev:lifecycle/lifecycle-runtime-ktx/src/main/java/androidx/lifecycle/Lifecycle.kt;l=44">lifecycleScope</a>
                            property.</p>
                        <p class="paragraph">Why not just use AndroidX? Because we need two things
                            it doesn't offer.</p>
                        <h2 class=""><a></a> Custom CoroutineScope factories</h2>
                        <p class="paragraph">The way <code>androidx-lifecycle-runtime</code>
                            constructs its <a
                                    href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">CoroutineScope</a>
                            is
                            <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-master-dev:lifecycle/lifecycle-runtime-ktx/src/main/java/androidx/lifecycle/Lifecycle.kt;l=44">hard-coded</a>,
                            which eliminates the possibility of using a custom <a
                                    href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/">CoroutineContext</a>
                            such as a <code>DispatcherProvider</code> or <a
                                    href="https://rbusarow.github.io/Dispatch/dispatch-android-espresso//dispatch.android.espresso/-idling-dispatcher/index.html">IdlingDispatcher</a>.
                            With <code>dispatch.android.lifecycle</code>, we can set a custom
                            factory.</p>
                        <div class="sample-container"><code class="" theme="idea">
                            <pre>class SomeFragmentEspressoTest {<br><br>  // Not part of this artifact.  see dispatch-android-espresso<br>  @JvmField @Rule val idlingRule = IdlingDispatcherProviderRule()<br><br>  @Before<br>  fun setUp() {<br>    // set a custom factory which is applied to all newly created lifecycleScopes<br>    LifecycleScopeFactory.set {<br>      MainImmediateContext() + idlingRule.dispatcherProvider<br>    }<br><br>    // now SomeFragment will use an IdlingDispatcher in its CoroutineScope<br>  }<br>}</pre>
                        </code></div>
                        <h2 class=""><a></a> Automatic lifecycle jobs</h2>
                        <p class="paragraph">Structured concurrency relies upon cancellation, but <a
                                href="https://developer.android.com/jetpack/androidx/releases/lifecycle">androidx-lifecycle-runtime.ktx</a>
                            doesn't cancel. It uses a special <a
                                    href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-master-dev:lifecycle/lifecycle-runtime-ktx/src/main/java/androidx/lifecycle/PausingDispatcher.kt">PausingDispatcher</a>.
                            This pausing behavior then leaks upstream, creating backpressure and
                            potentially deadlocks.</p>
                        <p class="paragraph">There's a <a
                                href="https://issuetracker.google.com/issues/146370660">bug filed in
                            their issue tracker</a>, but 2.2.0 got released anyway.</p>
                        <p class="paragraph">This library's API surface is the same as that within
                            the AndroidX version, but has a different strategy for handling
                            lifecycle events. When a lifecycle state enters the desired range, such
                            as at <code>ON_RESUME</code>, a new coroutine is created. When the state
                            exists the range, that coroutine is cancelled. If the lifecycle state
                            enters the desired range again, a new coroutine is created.</p>
                        <div class="sample-container"><code class="" theme="idea">
                            <pre>import dispatch.android.*<br><br>class SomeFragment : Fragment() {<br><br>  val viewModel: SomeViewModel by viewModels()<br><br>  init {<br>    // automatically created CoroutineScope using the factory described above<br>    lifecycleScope.launchWhenResumed {<br>      viewModel.someFlow.consume {  }<br>    }<br>  }<br><br>}</pre>
                        </code></div>
                        <p class="paragraph">This has the desired effect of not leaking backpressure
                            upstream (which in this example is the <code>viewModel</code>).</p>
                        <h2 class=""><a></a> Minimum Gradle Config</h2>
                        <p class="paragraph">Add to your module's <code>build.gradle.kts</code>:</p>
                        <div class="sample-container"><code class="" theme="idea">
                            <pre>repositories {<br>  mavenCentral()<br>}<br><br>dependencies {<br><br>  implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.8&quot;)<br>  implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.8&quot;)<br>  implementation(&quot;com.rickbusarow.dispatch:dispatch-android-lifecycle-extensions:1.0.0-beta04&quot;)<br><br>  implementation(&quot;androidx.lifecycle:lifecycle-common:2.2.0&quot;)<br>}</pre>
                        </code></div>
                        <p class="paragraph">&lt;!--- MODULE dispatch-core--&gt;</p>
                        <p class="paragraph">&lt;!--- INDEX --&gt;</p>
                        <p class="paragraph">&lt;!--- MODULE dispatch-test--&gt;</p>
                        <p class="paragraph">&lt;!--- INDEX --&gt;</p>
                        <p class="paragraph">&lt;!--- MODULE dispatch-test-junit4--&gt;</p>
                        <p class="paragraph">&lt;!--- INDEX --&gt;</p>
                        <p class="paragraph">&lt;!--- MODULE dispatch-test-junit5--&gt;</p>
                        <p class="paragraph">&lt;!--- INDEX --&gt;</p>
                        <p class="paragraph">&lt;!--- MODULE dispatch-android-espresso--&gt;</p>
                        <p class="paragraph">&lt;!--- INDEX --&gt;</p>
                        <p class="paragraph">&lt;!--- MODULE dispatch-android-lifecycle--&gt;</p>
                        <p class="paragraph">&lt;!--- INDEX --&gt;</p>
                        <p class="paragraph">&lt;!--- MODULE dispatch-android-viewmodel--&gt;</p>
                        <p class="paragraph">&lt;!--- INDEX --&gt;</p>
                        <p class="paragraph">&lt;!--- MODULE dispatch-android-viewmodel--&gt;</p>
                        <p class="paragraph">&lt;!--- INDEX --&gt;</p>
                        <p class="paragraph">&lt;!--- END --&gt;</p></p><p class="paragraph">
                        <h2 class=""><a></a> Contents</h2>
                        <p class="paragraph">&lt;!--- TOC --&gt;</p>
                        <ul>
                            <li><p class="paragraph">#api</p></li>
                            <ul>
                                <li><p class="paragraph">#one-time-suspend-functions</p></li>
                            </ul>
                            <li><p class="paragraph">#difference-from-androidx</p></li>
                            <li><p class="paragraph">#custom-coroutinescope-factories</p></li>
                            <li><p class="paragraph">#automatic-lifecycle-jobs</p></li>
                            <li><p class="paragraph">#minimum-gradle-config</p></li>
                        </ul>
                        <p class="paragraph">&lt;!--- END --&gt;</p>
                        <h2 class=""><a></a> Api</h2>
                        <h3 class=""><a></a> One-time suspend functions</h3>
                        <p class="paragraph">Examples</p>
                        <div class="sample-container"><code class="" theme="idea">
                            <pre>import dispatch.android.*<br><br>// This could be any LifecycleOwner -- Fragments, Activities, Services...<br>class SomeScreen : Fragment() {<br><br>  init {<br><br>    // auto-created MainImmediateCoroutineScope which is lifecycle-aware<br>    lifecycleScope //...<br><br>    // active only when &quot;resumed&quot;.  starts a fresh coroutine each time<br>    // this is a rough proxy for LiveData behavior<br>    lifecycleScope.launchEveryResume {  }<br><br>    // active only when &quot;started&quot;.  starts a fresh coroutine each time<br>    lifecycleScope.launchEveryStart {  }<br><br>    // launch when created, automatically stop on destroy<br>    lifecycleScope.launchEveryCreate {  }<br><br>    // it works as a normal CoroutineScope as well (because it is)<br>    lifecycleScope.launchMain {  }<br><br>  }<br>}</pre>
                        </code></div>
                        <div class="sample-container"><code class="" theme="idea">
                            <pre>class SomeApplication : Application() {<br>  override fun onCreate() {<br>    super.onCreate()<br>    // A custom factory can be set to add elements to the CoroutineContext<br>    LifecycleScopeFactory.set { MainImmediateContext() + SomeCustomElement() }<br>  }<br>}</pre>
                        </code></div>
                        <div class="sample-container"><code class="" theme="idea">
                            <pre>class SomeEspressoTest {<br>  @Before<br>  fun setUp() {<br>    // This custom factory can be used to use custom scopes for testing,<br>    // such as an idling dispatcher<br>    LifecycleScopeFactory.set { MainImmediateIdlingCoroutineScope().coroutineContext }<br>  }<br><br>  @After<br>  fun tearDown() {<br>    // The factory can also be reset to default<br>    LifecycleScopeFactory.reset()<br>  }<br>}</pre>
                        </code></div>
                        <h2 class=""><a></a> Difference from AndroidX</h2>
                        <p class="paragraph">This module is really just a slightly different version
                            of
                            <a href="https://developer.android.com/jetpack/androidx/releases/lifecycle">androidx-lifecycle-runtime-ktx</a>
                            â€” the library which gives us the <a
                                    href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-master-dev:lifecycle/lifecycle-runtime-ktx/src/main/java/androidx/lifecycle/Lifecycle.kt;l=44">lifecycleScope</a>
                            property.</p>
                        <p class="paragraph">Why not just use AndroidX? Because we need two things
                            it doesn't offer.</p>
                        <h2 class=""><a></a> Custom CoroutineScope factories</h2>
                        <p class="paragraph">The way <code>androidx-lifecycle-runtime</code>
                            constructs its <a
                                    href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">CoroutineScope</a>
                            is
                            <a href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-master-dev:lifecycle/lifecycle-runtime-ktx/src/main/java/androidx/lifecycle/Lifecycle.kt;l=44">hard-coded</a>,
                            which eliminates the possibility of using a custom <a
                                    href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/">CoroutineContext</a>
                            such as a <code>DispatcherProvider</code> or <a
                                    href="https://rbusarow.github.io/Dispatch/dispatch-android-espresso//dispatch.android.espresso/-idling-dispatcher/index.html">IdlingDispatcher</a>.
                            With <code>dispatch.android.lifecycle</code>, we can set a custom
                            factory.</p>
                        <div class="sample-container"><code class="" theme="idea">
                            <pre>class SomeFragmentEspressoTest {<br><br>  // Not part of this artifact.  see dispatch-android-espresso<br>  @JvmField @Rule val idlingRule = IdlingDispatcherProviderRule()<br><br>  @Before<br>  fun setUp() {<br>    // set a custom factory which is applied to all newly created lifecycleScopes<br>    LifecycleScopeFactory.set {<br>      MainImmediateContext() + idlingRule.dispatcherProvider<br>    }<br><br>    // now SomeFragment will use an IdlingDispatcher in its CoroutineScope<br>  }<br>}</pre>
                        </code></div>
                        <h2 class=""><a></a> Automatic lifecycle jobs</h2>
                        <p class="paragraph">Structured concurrency relies upon cancellation, but <a
                                href="https://developer.android.com/jetpack/androidx/releases/lifecycle">androidx-lifecycle-runtime.ktx</a>
                            doesn't cancel. It uses a special <a
                                    href="https://cs.android.com/androidx/platform/frameworks/support/+/androidx-master-dev:lifecycle/lifecycle-runtime-ktx/src/main/java/androidx/lifecycle/PausingDispatcher.kt">PausingDispatcher</a>.
                            This pausing behavior then leaks upstream, creating backpressure and
                            potentially deadlocks.</p>
                        <p class="paragraph">There's a <a
                                href="https://issuetracker.google.com/issues/146370660">bug filed in
                            their issue tracker</a>, but 2.2.0 got released anyway.</p>
                        <p class="paragraph">This library's API surface is the same as that within
                            the AndroidX version, but has a different strategy for handling
                            lifecycle events. When a lifecycle state enters the desired range, such
                            as at <code>ON_RESUME</code>, a new coroutine is created. When the state
                            exists the range, that coroutine is cancelled. If the lifecycle state
                            enters the desired range again, a new coroutine is created.</p>
                        <div class="sample-container"><code class="" theme="idea">
                            <pre>import dispatch.android.*<br><br>class SomeFragment : Fragment() {<br><br>  val viewModel: SomeViewModel by viewModels()<br><br>  init {<br>    // automatically created CoroutineScope using the factory described above<br>    lifecycleScope.launchWhenResumed {<br>      viewModel.someFlow.consume {  }<br>    }<br>  }<br><br>}</pre>
                        </code></div>
                        <p class="paragraph">This has the desired effect of not leaking backpressure
                            upstream (which in this example is the <code>viewModel</code>).</p>
                        <h2 class=""><a></a> Minimum Gradle Config</h2>
                        <p class="paragraph">Add to your module's <code>build.gradle.kts</code>:</p>
                        <div class="sample-container"><code class="" theme="idea">
                            <pre>repositories {<br>  mavenCentral()<br>}<br><br>dependencies {<br><br>  implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.3.8&quot;)<br>  implementation(&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.3.8&quot;)<br>  implementation(&quot;com.rickbusarow.dispatch:dispatch-android-lifecycle-extensions:1.0.0-beta04&quot;)<br><br>  implementation(&quot;androidx.lifecycle:lifecycle-common:2.2.0&quot;)<br>}</pre>
                        </code></div>
                        <p class="paragraph">&lt;!--- MODULE dispatch-core--&gt;</p>
                        <p class="paragraph">&lt;!--- INDEX --&gt;</p>
                        <p class="paragraph">&lt;!--- MODULE dispatch-test--&gt;</p>
                        <p class="paragraph">&lt;!--- INDEX --&gt;</p>
                        <p class="paragraph">&lt;!--- MODULE dispatch-test-junit4--&gt;</p>
                        <p class="paragraph">&lt;!--- INDEX --&gt;</p>
                        <p class="paragraph">&lt;!--- MODULE dispatch-test-junit5--&gt;</p>
                        <p class="paragraph">&lt;!--- INDEX --&gt;</p>
                        <p class="paragraph">&lt;!--- MODULE dispatch-android-espresso--&gt;</p>
                        <p class="paragraph">&lt;!--- INDEX --&gt;</p>
                        <p class="paragraph">&lt;!--- MODULE dispatch-android-lifecycle--&gt;</p>
                        <p class="paragraph">&lt;!--- INDEX --&gt;</p>
                        <p class="paragraph">&lt;!--- MODULE dispatch-android-viewmodel--&gt;</p>
                        <p class="paragraph">&lt;!--- INDEX --&gt;</p>
                        <p class="paragraph">&lt;!--- MODULE dispatch-android-viewmodel--&gt;</p>
                        <p class="paragraph">&lt;!--- INDEX --&gt;</p>
                        <p class="paragraph">&lt;!--- END --&gt;</p></p></div>
                </div>
            </div>
            <h2 class=""><a data-name="packages"></a>Packages</h2>
            <div class="table"><a
                    data-name="dispatch.android.lifecycle////PointingToDeclaration/"></a>
                <div class="table-row"
                     data-filterable-current=":dispatch-android-lifecycle-extensions:dokkaHtml/release"
                     data-filterable-set=":dispatch-android-lifecycle-extensions:dokkaHtml/release">
                    <div class="main-subrow "><span><a href="dispatch.android.lifecycle/index.html">dispatch.android.lifecycle</a><span
                            class="anchor-wrapper"><span class="anchor-icon"
                                                         pointing-to="dispatch.android.lifecycle////PointingToDeclaration/"><svg
                            fill="none" height="24" viewBox="0 0 24 24" width="24"
                            xmlns="http://www.w3.org/2000/svg">
    <path d="M21.2496 5.3C20.3496 4.5 19.2496 4 18.0496 4C16.8496 4 15.6496 4.5 14.8496 5.3L10.3496 9.8L11.7496 11.2L16.2496 6.7C17.2496 5.7 18.8496 5.7 19.8496 6.7C20.8496 7.7 20.8496 9.3 19.8496 10.3L15.3496 14.8L16.7496 16.2L21.2496 11.7C22.1496 10.8 22.5496 9.7 22.5496 8.5C22.5496 7.3 22.1496 6.2 21.2496 5.3Z"/>
    <path d="M8.35 16.7998C7.35 17.7998 5.75 17.7998 4.75 16.7998C3.75 15.7998 3.75 14.1998 4.75 13.1998L9.25 8.6998L7.85 7.2998L3.35 11.7998C1.55 13.5998 1.55 16.3998 3.35 18.1998C4.25 19.0998 5.35 19.4998 6.55 19.4998C7.75 19.4998 8.85 19.0998 9.75 18.1998L14.25 13.6998L12.85 12.2998L8.35 16.7998Z"/>
</svg></span>
                    <div class="copy-popup-wrapper "><svg fill="none" height="18"
                                                          viewBox="0 0 18 18" width="18"
                                                          xmlns="http://www.w3.org/2000/svg">
    <path d="M18 9C18 14 14 18 9 18C4 18 0 14 0 9C0 4 4 0 9 0C14 0 18 4 18 9ZM14.2 6.2L12.8 4.8L7.5 10.1L5.3 7.8L3.8 9.2L7.5 13L14.2 6.2Z"
          fill="#4DBB5F"/>
</svg><span>Link copied to clipboard</span></div>
                  </span></span></div>
                </div>
            </div>
        </div>
        <div class="footer"><span class="go-to-top-icon"><a href="#container"><svg fill="none"
                                                                                   height="10"
                                                                                   viewBox="0 0 12 10"
                                                                                   width="12"
                                                                                   xmlns="http://www.w3.org/2000/svg">
    <path d="M11.3337 9.66683H0.666992L6.00033 3.66683L11.3337 9.66683Z" fill="black"/>
    <path d="M0.666992 0.333496H11.3337V1.66683H0.666992V0.333496Z" fill="black"/>
</svg></a></span><span>Â© 2020 Copyright</span><span class="pull-right"><span>Sponsored and developed by dokka</span><a
                href="https://github.com/Kotlin/dokka"><span class="padded-icon"><svg fill="none"
                                                                                      height="8"
                                                                                      viewBox="0 0 8 8"
                                                                                      width="8"
                                                                                      xmlns="http://www.w3.org/2000/svg">
    <path d="M8 0H2.3949L4.84076 2.44586L0 7.28662L0.713376 8L5.55414 3.15924L8 5.6051V0Z"
          fill="black"/>
</svg></span></a></span></div>
    </div>
</div>
</body>
</html>

